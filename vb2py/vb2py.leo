<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.309787234043">
	<global_window_position top="1" left="-5" height="958" width="1175"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="pap.120703001453" a="E"><vh>Code</vh>
<v t="pap.120703001453.1"><vh>__init__.py</vh></v>
<v t="pap.120703001453.2"><vh>utils.py</vh>
<v t="pap.120703001453.3"><vh>Path utils</vh></v>
</v>
<v t="pap.120703001453.4"><vh>logger.py</vh></v>
<v t="pap.120703001453.5"><vh>converter.py</vh>
<v t="pap.120703001453.6"><vh>&lt;&lt; Documentation &gt;&gt;</vh></v>
<v t="pap.120703001453.7"><vh>&lt;&lt; Declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.8"><vh>&lt;&lt; Error classes &gt;&gt;</vh></v>
<v t="pap.120703001453.9"><vh>class VBConverter</vh>
<v t="pap.120703001453.10"><vh>__init__</vh></v>
<v t="pap.120703001453.11" a="E"><vh>doConversion</vh>
<v t="pap.20041207001955"><vh>&lt;&lt; Handle references &gt;&gt;</vh></v>
<v t="pap.120703001453.12"><vh>&lt;&lt; Handle forms &gt;&gt;</vh></v>
<v t="pap.120703001453.13"><vh>&lt;&lt; Handle modules &gt;&gt;</vh></v>
<v t="pap.120703001453.14"><vh>&lt;&lt; Handle classes &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.15" a="E"><vh>logText</vh></v>
<v t="pap.20041207002557" a="E"><vh>handleReferences</vh>
<v t="pap.20041207004101.1"><vh>&lt;&lt; Add to project &gt;&gt;</vh></v>
<v t="pap.20041207004101"><vh>&lt;&lt; Resolve References &gt;&gt;</vh></v>
</v>
</v>
<v t="pap.120703001453.16" a="E"><vh>class BaseParser</vh>
<v t="pap.120703001453.17"><vh>__init__</vh></v>
<v t="pap.20070224183443"><vh>readFileContent</vh></v>
<v t="pap.120703001453.18"><vh>doValidation</vh></v>
<v t="pap.120703001453.19"><vh>findMany</vh></v>
<v t="pap.120703001453.20"><vh>findOne</vh></v>
<v t="pap.120703001453.21"><vh>splitSectionByMarker</vh></v>
<v t="pap.120703001453.22"><vh>_getPattern</vh></v>
<v t="pap.120703001453.23"><vh>parseCode</vh></v>
<v t="pap.120703001453.24"><vh>getContainer</vh></v>
<v t="pap.120703001453.25" a="E"><vh>writeToFile</vh></v>
</v>
<v t="pap.120703001453.26"><vh>class ProjectParser</vh>
<v t="pap.120703001453.27"><vh>doParse</vh></v>
<v t="pap.120703001453.28"><vh>doValidation</vh></v>
</v>
<v t="pap.120703001453.29"><vh>class FileParser</vh>
<v t="pap.120703001453.30"><vh>doParse</vh></v>
<v t="pap.120703001453.31"><vh>doValidation</vh></v>
</v>
<v t="pap.120703001453.32" a="E"><vh>class FormParser</vh>
<v t="pap.120703001453.33" a="E"><vh>doParse</vh>
<v t="pap.120703001453.34"><vh>&lt;&lt; Split off code section &gt;&gt;</vh></v>
<v t="pap.120703001453.35"><vh>&lt;&lt; Add controls to form namespace &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.36" a="E"><vh>parseForm</vh>
<v t="pap.120703001453.37"><vh>&lt;&lt; Get name of form class &gt;&gt;</vh></v>
<v t="pap.120703001453.38"><vh>&lt;&lt; Begin class conversion &gt;&gt;</vh></v>
<v t="pap.120703001453.39"><vh>&lt;&lt; Convert properties &gt;&gt;</vh></v>
<v t="pap.120703001453.40"><vh>&lt;&lt; Convert object references &gt;&gt;</vh></v>
<v t="pap.120703001453.41"><vh>&lt;&lt; Menu shortcuts &gt;&gt;</vh></v>
<v t="pap.120703001453.42"><vh>&lt;&lt; Remove meaningless bits &gt;&gt;</vh></v>
<v t="pap.120703001453.43"><vh>&lt;&lt; Remove references to frx file &gt;&gt;</vh></v>
<v t="pap.120703001453.44"><vh>&lt;&lt; Hex numbers &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.45"><vh>groupOptionButtons</vh></v>
<v t="pap.120703001453.46"><vh>getContainer</vh></v>
</v>
<v t="pap.120703001453.47" a="E"><vh>class ModuleParser</vh>
<v t="pap.120703001453.48"><vh>doParse</vh></v>
<v t="pap.120703001453.49"><vh>getContainer</vh></v>
<v t="pap.120703001453.50"><vh>writeToFile</vh></v>
</v>
<v t="pap.120703001453.51"><vh>class ClassParser</vh>
<v t="pap.120703001453.52"><vh>getContainer</vh></v>
</v>
<v t="pap.120703001453.53" a="E"><vh>class BaseResource</vh>
<v t="pap.120703001453.54"><vh>__init__</vh></v>
<v t="pap.120703001453.55" a="E"><vh>updateFrom</vh>
<v t="pap.120703001453.56"><vh>&lt;&lt; Main properties &gt;&gt;</vh></v>
<v t="pap.120703001453.57"><vh>&lt;&lt; Components &gt;&gt;</vh></v>
<v t="pap.120703001453.58"><vh>&lt;&lt; Menus &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.59"><vh>updateCode</vh></v>
<v t="pap.120703001453.60"><vh>addMenus</vh></v>
<v t="pap.120703001453.61"><vh>writeToFile</vh></v>
</v>
<v t="pap.20041207005308"><vh>class ExternalRefParser</vh>
<v t="pap.20041207005609"><vh>__init__</vh></v>
</v>
<v t="pap.120703001453.62"><vh>class NameSpace</vh></v>
<v t="pap.120703001453.63" a="E"><vh>main</vh>
<v t="pap.120703001453.64"><vh>&lt;&lt; Parse options &gt;&gt;</vh></v>
<v t="pap.120703001453.65"><vh>&lt;&lt; Validate arguments &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.66"><vh>importTarget		</vh></v>
<v t="pap.120703001453.67"><vh>renderTo</vh></v>
<v t="pap.120703001453.68"><vh>usage</vh></v>
<v t="pap.120703001453.69"><vh>supports</vh></v>
</v>
<v t="pap.120703001453.70"><vh>GUI resources</vh>
<v t="pap.120703001453.71"><vh>__init__.py</vh></v>
<v t="pap.120703001453.72" a="E"><vh>PythonCard</vh>
<v t="pap.120703001453.73"><vh>__init__.py</vh></v>
<v t="pap.120703001453.74"><vh>basesource.txt</vh></v>
<v t="pap.120703001453.75"><vh>basesource.py</vh></v>
<v t="pap.120703001453.76" a="E"><vh>controls.py</vh>
<v t="pap.120703001453.77"><vh>&lt;&lt; Events &gt;&gt;</vh>
<v t="pap.120703001453.78"><vh>class ControlEvent</vh>
<v t="pap.120703001453.79"><vh>__init__</vh></v>
<v t="pap.120703001453.80"><vh>updateMethodDefinition</vh></v>
</v>
</v>
<v t="pap.120703001453.81" a="E"><vh>class VBControl</vh>
<v t="pap.120703001453.82"><vh>_getPropertyList</vh></v>
<v t="pap.120703001453.83"><vh>_getControlList</vh></v>
<v t="pap.120703001453.84"><vh>_getControlsOfType</vh></v>
<v t="pap.120703001453.85"><vh>_getContainerControls</vh></v>
<v t="pap.120703001453.86"><vh>_get</vh></v>
<v t="pap.120703001453.87"><vh>_realName</vh></v>
<v t="pap.120703001453.88"><vh>_getControlEntry</vh></v>
<v t="pap.120703001453.89"><vh>_getClassSpecificControlEntries</vh></v>
<v t="pap.120703001453.90"><vh>_mapNameReference</vh></v>
<v t="pap.120703001453.91"><vh>_attributeTranslation</vh></v>
<v t="pap.120703001453.92"><vh>_processChildObjects</vh></v>
<v t="pap.120703001453.93"><vh>_getEvents</vh></v>
<v t="pap.120703001453.94"><vh>_getAttribute</vh></v>
<v t="PAP.20040425194848"><vh>_getPyCardColours</vh></v>
</v>
<v t="pap.120703001453.95" a="E"><vh>Main controls</vh>
<v t="pap.120703001453.96"><vh>Menu</vh></v>
<v t="pap.120703001453.97"><vh>CommandButton</vh></v>
<v t="pap.120703001453.98"><vh>ComboBox</vh></v>
<v t="pap.120703001453.99"><vh>ListBox</vh></v>
<v t="pap.120703001453.100"><vh>Label</vh></v>
<v t="pap.120703001453.101"><vh>Image</vh></v>
<v t="pap.120703001453.102"><vh>CheckBox</vh></v>
<v t="pap.120703001453.103"><vh>TextBox</vh></v>
<v t="pap.120703001453.104"><vh>Form</vh></v>
<v t="pap.120703001453.105"><vh>Font</vh></v>
<v t="PAP.20040801194015"><vh>Timer</vh></v>
<v t="pap.120703001453.106"><vh>Frame</vh></v>
<v t="pap.120703001453.107"><vh>OptionButton</vh></v>
<v t="PAP.20040425191919"><vh>TreeView</vh></v>
<v t="PAP.20040425191919.1"><vh>ImageList</vh></v>
<v t="pap.120703001453.108"><vh>VBUnknownControl</vh></v>
</v>
</v>
<v t="pap.120703001453.109"><vh>resource.py</vh>
<v t="pap.120703001453.110"><vh>&lt;&lt; Event translation &gt;&gt;</vh></v>
<v t="pap.120703001453.111"><vh>class Resource</vh>
<v t="pap.120703001453.112"><vh>&lt;&lt; PyCardResource declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.113"><vh>__init__</vh></v>
<v t="pap.120703001453.114"><vh>writeToFile</vh>
<v t="pap.120703001453.115"><vh>&lt;&lt; Resource file &gt;&gt;</vh></v>
<v t="pap.120703001453.116"><vh>&lt;&lt; Code file &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.117"><vh>controlclasses.py</vh>
<v t="pap.120703001453.118"><vh>VBWidget</vh></v>
<v t="pap.120703001453.119" a="E"><vh>VBWrapped</vh>
<v t="pap.120703001453.120"><vh>__new__</vh></v>
<v t="pap.120703001453.121"><vh>createProperties</vh></v>
<v t="pap.120703001453.122"><vh>createIndexedProperties</vh></v>
<v t="pap.120703001453.123"><vh>createMethodLookup</vh></v>
<v t="pap.120703001453.124"><vh>createAttributeLookup</vh></v>
<v t="PAP.20040811222221"><vh>createAttributeSet</vh></v>
</v>
</v>
<v t="pap.120703001453.1248"><vh>Subclassing PythonCard classes</vh>
<v t="PAP.20040202234151"><vh>__init__.py</vh></v>
<v t="pap.120703001453.588"><vh>vbbutton.py</vh></v>
<v t="pap.120703001453.589"><vh>vbstatictext.py</vh></v>
<v t="PAP.20040801200221"><vh>vbtimer.py</vh></v>
<v t="pap.120703001453.590"><vh>vbtextfield.py</vh></v>
<v t="pap.120703001453.599"><vh>vbtextarea.py</vh></v>
<v t="pap.120703001453.598"><vh>vbcheckbox.py</vh></v>
<v t="pap.120703001453.1249" a="E"><vh>Image Controls</vh>
<v t="pap.120703001453.1250"><vh>vbbitmapcanvas.py</vh>
<v t="pap.120703001453.1251"><vh>Picture</vh></v>
</v>
<v t="pap.120703001453.101"><vh>Image</vh></v>
<v t="pap.120703001453.531"><vh>LoadPicture</vh></v>
</v>
<v t="pap.120703001453.591" a="E"><vh>vbcombobox.py</vh>
<v t="pap.120703001453.592"><vh>AddItem</vh></v>
<v t="pap.120703001453.593"><vh>getNumber</vh></v>
<v t="pap.120703001453.594"><vh>getSelectionIndex</vh></v>
<v t="pap.120703001453.595"><vh>delete</vh></v>
</v>
<v t="pap.120703001453.596"><vh>vblist.py</vh>
<v t="pap.120703001453.597"><vh>AddItem</vh></v>
</v>
<v t="PAP.20040425193458"><vh>vbimagelist.py</vh>
<v t="PAP.20040425193458.1"><vh>dummy</vh></v>
</v>
<v t="PAP.20040425193947"><vh>vbtreeview.py</vh>
<v t="PAP.20040429014548" a="E"><vh>class VBTreeView</vh>
<v t="PAP.20040429014548.1"><vh>&lt;&lt; class VBTreeView declarations &gt;&gt;</vh></v>
<v t="PAP.20040425193947.1"><vh>__init__</vh></v>
<v t="PAP.20040429014548.2"><vh>SelectedItem</vh></v>
</v>
<v t="PAP.20040427002005" a="E"><vh>class TreeNodeCollection</vh>
<v t="PAP.20040427002005.1"><vh>&lt;&lt; class TreeNodeCollection declarations &gt;&gt;</vh></v>
<v t="PAP.20040427002005.2"><vh>__init__</vh></v>
<v t="PAP.20040429014548.3"><vh>_initTree</vh></v>
<v t="PAP.20040427002005.3"><vh>Clear</vh></v>
<v t="PAP.20040428003630"><vh>Add</vh></v>
<v t="PAP.20040429020941"><vh>__iter__</vh></v>
</v>
</v>
</v>
</v>
<v t="pap.120703001453.125" a="E"><vh>Tkinter</vh>
<v t="pap.120703001453.126"><vh>__init__.py</vh></v>
<v t="pap.120703001453.127" a="E"><vh>resource.py</vh>
<v t="pap.120703001453.128"><vh>&lt;&lt; Event translation &gt;&gt;</vh></v>
<v t="pap.120703001453.129"><vh>__init__</vh></v>
<v t="pap.120703001453.130"><vh>writeToFile</vh></v>
</v>
<v t="pap.120703001453.131"><vh>controls.py</vh>
<v t="pap.120703001453.132"><vh>class VBControl</vh>
<v t="pap.120703001453.133"><vh>_getPropertyList</vh></v>
<v t="pap.120703001453.134"><vh>_getControlList</vh></v>
<v t="pap.120703001453.135"><vh>_getControlsOfType</vh></v>
<v t="pap.120703001453.136"><vh>_getContainerControls</vh></v>
<v t="pap.120703001453.137"><vh>_get</vh></v>
<v t="pap.120703001453.138"><vh>_realName</vh></v>
<v t="pap.120703001453.139"><vh>_getControlEntry</vh></v>
<v t="pap.120703001453.140"><vh>_getClassSpecificControlEntries</vh></v>
<v t="pap.120703001453.141"><vh>_mapNameReference</vh></v>
<v t="pap.120703001453.142"><vh>_attributeTranslation</vh></v>
<v t="pap.120703001453.143"><vh>_processChildObjects</vh></v>
</v>
<v t="pap.120703001453.144"><vh>Main controls</vh>
<v t="pap.120703001453.145"><vh>Menu</vh></v>
<v t="pap.120703001453.146"><vh>CommandButton</vh></v>
<v t="pap.120703001453.147"><vh>ComboBox</vh></v>
<v t="pap.120703001453.148"><vh>ListBox</vh></v>
<v t="pap.120703001453.149"><vh>Label</vh></v>
<v t="pap.120703001453.150"><vh>CheckBox</vh></v>
<v t="pap.120703001453.151"><vh>TextBox</vh></v>
<v t="pap.120703001453.152"><vh>Form</vh></v>
<v t="pap.120703001453.153"><vh>Frame</vh></v>
<v t="pap.120703001453.154"><vh>OptionButton</vh></v>
<v t="pap.120703001453.155"><vh>VBUnknownControl</vh></v>
</v>
</v>
<v t="pap.120703001453.156"><vh>basesource.py</vh>
<v t="pap.120703001453.157"><vh>&lt;&lt; basesource declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.158"><vh>class App</vh>
<v t="pap.120703001453.159"><vh>&lt;&lt; class App declarations &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="pap.120703001453.160" a="E"><vh>Parsing and converting code</vh>
<v t="pap.120703001453.161" a="E" tnodeList="pap.120703001453.161,pap.120703001453.162,pap.120703001453.163,pap.120703001453.164,pap.120703001453.165,pap.120703001453.166,pap.120703001453.167,pap.120703001453.168,pap.120703001453.169,pap.120703001453.170,pap.120703001453.171,pap.120703001453.172,pap.120703001453.173,pap.120703001453.174,pap.120703001453.175,pap.120703001453.176,pap.120703001453.177,pap.120703001453.178,pap.120703001453.179,pap.120703001453.180,pap.120703001453.181,pap.120703001453.182,pap.120703001453.183,pap.120703001453.184,pap.120703001453.185,pap.120703001453.186,pap.120703001453.187,pap.120703001453.188,pap.120703001453.189,pap.120703001453.190,pap.120703001453.191,pap.120703001453.192,pap.120703001453.193,pap.120703001453.194,pap.120703001453.195,pap.120703001453.196,pap.120703001453.197,pap.120703001453.198,pap.120703001453.199"><vh>@file vbgrammar.txt</vh>
<v t="pap.120703001453.162" a="E"><vh>Basic building blocks</vh>
<v t="pap.120703001453.163"><vh>Basic elements</vh></v>
<v t="pap.120703001453.164"><vh>Blocks and lines</vh></v>
<v t="pap.120703001453.165"><vh>Statements</vh></v>
<v t="pap.120703001453.166"><vh>Keywords</vh></v>
<v t="pap.120703001453.167"><vh>Expressions</vh></v>
<v t="pap.120703001453.168"><vh>Line (connecting points)</vh></v>
</v>
<v t="pap.120703001453.169"><vh>Single statements</vh>
<v t="pap.120703001453.170"><vh>Assigment</vh></v>
<v t="pap.120703001453.171"><vh>Comment</vh></v>
<v t="pap.120703001453.172"><vh>External libraries</vh></v>
<v t="pap.120703001453.173"><vh>Labels and GoTo</vh></v>
<v t="pap.120703001453.174"><vh>Dim</vh></v>
<v t="pap.120703001453.175"><vh>On Error Goto</vh></v>
<v t="pap.120703001453.176"><vh>Print / Get</vh></v>
<v t="pap.120703001453.177"><vh>Seek</vh></v>
<v t="pap.120703001453.178"><vh>Open/Close</vh></v>
<v t="pap.120703001453.179"><vh>Calls</vh></v>
<v t="pap.120703001453.180"><vh>Resume statement</vh></v>
<v t="pap.120703001453.181"><vh>Exit statement</vh></v>
<v t="pap.120703001453.182"><vh>Name statement</vh></v>
<v t="pap.120703001453.183"><vh>End statement</vh></v>
<v t="pap.120703001453.184"><vh>Event definition</vh></v>
</v>
<v t="pap.120703001453.185" a="E"><vh>Compound statements</vh>
<v t="pap.120703001453.186"><vh>Do/While etc</vh></v>
<v t="pap.120703001453.187"><vh>Select case</vh></v>
<v t="pap.120703001453.188"><vh>If</vh></v>
<v t="pap.120703001453.189"><vh>For and for each</vh></v>
<v t="pap.120703001453.190"><vh>Subs and functions</vh></v>
<v t="pap.120703001453.191"><vh>Properties</vh></v>
<v t="pap.120703001453.192"><vh>User Types</vh></v>
<v t="pap.120703001453.193"><vh>With</vh></v>
<v t="pap.120703001453.194"><vh>Enumerations</vh></v>
</v>
<v t="pap.120703001453.195"><vh>Non VB stuff</vh>
<v t="pap.120703001453.196"><vh>Class file headers</vh></v>
<v t="pap.120703001453.197"><vh>vb2py Directives</vh></v>
<v t="pap.120703001453.198"><vh>attribute statement</vh></v>
<v t="pap.120703001453.199"><vh>option_statement</vh></v>
</v>
</v>
<v t="pap.120703001453.200" a="E"><vh>vbparser.py</vh>
<v t="pap.120703001453.201"><vh>&lt;&lt; Imports &gt;&gt;</vh></v>
<v t="pap.120703001453.202"><vh>&lt;&lt; Error Classes &gt;&gt;</vh></v>
<v t="pap.120703001453.203"><vh>&lt;&lt; Definitions &gt;&gt;</vh></v>
<v t="pap.120703001453.204" a="E"><vh>Utility functions</vh>
<v t="pap.120703001453.205"><vh>convertToElements</vh></v>
<v t="pap.120703001453.206" a="E"><vh>buildParseTree</vh>
<v t="pap.20070224191421"><vh>&lt;&lt; Build Parser &gt;&gt;</vh></v>
<v t="pap.120703001453.208"><vh>&lt;&lt; Handle failure &gt;&gt;</vh></v>
</v>
<v t="pap.20070224185447"><vh>makeSafeFromUnicode</vh></v>
<v t="pap.20070224185546"><vh>makeUnicodeFromSafe</vh></v>
<v t="pap.120703001453.209"><vh>parseVB</vh></v>
<v t="PAP.20040801193506"><vh>getAST</vh></v>
<v t="pap.120703001453.210"><vh>renderCodeStructure</vh></v>
<v t="pap.120703001453.211"><vh>convertVBtoPython</vh></v>
<v t="pap.120703001453.212"><vh>applyPlugins</vh></v>
<v t="pap.120703001453.213"><vh>parseVBFile</vh>
<v t="pap.120703001453.214"><vh>&lt;&lt; Get text &gt;&gt;</vh></v>
<v t="pap.120703001453.215"><vh>&lt;&lt; Choose appropriate container &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.216" a="EM"><vh>parserclasses.py</vh>
<v t="pap.120703001453.217"><vh>&lt;&lt; Definitions &gt;&gt;</vh></v>
<v t="pap.120703001453.218" a="E"><vh>Base classes</vh>
<v t="pap.120703001453.219" a="E"><vh>VBElement </vh>
<v t="pap.120703001453.220"><vh>__init__</vh></v>
<v t="pap.120703001453.221"><vh>printTree</vh></v>
</v>
<v t="pap.120703001453.222"><vh>VBFailedElement</vh>
<v t="pap.120703001453.223"><vh>__init__</vh></v>
</v>
<v t="pap.120703001453.224"><vh>VBNamespace </vh>
<v t="pap.120703001453.225"><vh>&lt;&lt; VBNamespace declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.226" a="E"><vh>__init__</vh>
<v t="pap.120703001453.227"><vh>&lt;&lt; Get indenting Options &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.228" a="E"><vh>General methods</vh>
<v t="pap.120703001453.248"><vh>amGlobal</vh></v>
<v t="pap.120703001453.234"><vh>assignParent</vh></v>
<v t="pap.120703001453.233"><vh>asString</vh></v>
<v t="pap.120703001453.253"><vh>checkIfFunction</vh></v>
<v t="pap.120703001453.244"><vh>checkOptionChoice</vh></v>
<v t="pap.120703001453.245"><vh>checkOptionYesNo</vh></v>
<v t="pap.120703001453.251"><vh>containsStatements</vh></v>
<v t="pap.120703001453.232"><vh>createExtractHandler</vh></v>
<v t="PAP.20040429002230"><vh>filterListByClass</vh></v>
<v t="pap.120703001453.235"><vh>finalizeObject</vh></v>
<v t="pap.120703001453.240"><vh>findParentOfClass</vh></v>
<v t="pap.120703001453.230"><vh>getHandler</vh>
<v t="pap.120703001453.231"><vh>&lt;&lt; Create class handler &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.242"><vh>getIndent</vh></v>
<v t="pap.120703001453.241"><vh>getLocalNameFor</vh></v>
<v t="pap.120703001453.238"><vh>getParentProperty</vh></v>
<v t="pap.120703001453.243"><vh>getWarning</vh></v>
<v t="pap.120703001453.236"><vh>handleSubObject</vh></v>
<v t="pap.120703001453.252"><vh>isAFunction</vh></v>
<v t="pap.120703001453.229"><vh>processElement</vh></v>
<v t="pap.120703001453.249"><vh>registerAsGlobal</vh></v>
<v t="pap.120703001453.250"><vh>registerImportRequired</vh></v>
<v t="pap.120703001453.237"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.247"><vh>resolveLocalName</vh></v>
<v t="pap.120703001453.246"><vh>resolveName</vh></v>
<v t="pap.120703001453.239"><vh>searchParentProperty</vh></v>
</v>
<v t="pap.120703001453.254"><vh>Handlers</vh>
<v t="pap.120703001453.255"><vh>handle_scope</vh></v>
<v t="pap.120703001453.256"><vh>handle_line_end</vh></v>
</v>
</v>
<v t="pap.120703001453.257"><vh>VBConsumer</vh></v>
<v t="pap.120703001453.258"><vh>VBUnrendered</vh></v>
<v t="pap.120703001453.259"><vh>VBMessage</vh></v>
<v t="pap.120703001453.260"><vh>VBMissingArgument</vh></v>
<v t="pap.120703001453.261"><vh>VBCodeBlock</vh>
<v t="pap.120703001453.262"><vh>__init__</vh></v>
<v t="pap.120703001453.263"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.264"><vh>VBUnrenderedBlock</vh></v>
<v t="pap.120703001453.265"><vh>VBOptionalCodeBlock</vh>
<v t="pap.120703001453.266"><vh>containsStatements</vh></v>
</v>
<v t="pap.120703001453.267"><vh>VBVariable </vh>
<v t="pap.120703001453.268"><vh>&lt;&lt; VBVariable declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.269"><vh>__init__</vh></v>
<v t="pap.120703001453.270"><vh>finalizeObject</vh></v>
<v t="pap.120703001453.271"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.272"><vh>VBSizeDefinition</vh>
<v t="pap.120703001453.273"><vh>__init__</vh></v>
<v t="pap.120703001453.274"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.275"><vh>Objects</vh>
<v t="pap.120703001453.276"><vh>VBObject</vh>
<v t="pap.120703001453.277" a="E"><vh>__init__</vh></v>
<v t="pap.120703001453.278"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.279"><vh>finalizeObject</vh></v>
<v t="pap.120703001453.280"><vh>asString</vh></v>
<v t="PAP.20040429002230.1"><vh>fnPart</vh></v>
<v t="PAP.20040429002230.2"><vh>_renderPartialObject</vh></v>
</v>
<v t="pap.120703001453.281"><vh>VBLHSObject</vh></v>
<v t="pap.120703001453.282"><vh>VBAttribute</vh></v>
<v t="pap.120703001453.283"><vh>VBParameterList</vh>
<v t="pap.120703001453.284"><vh>__init__</vh></v>
<v t="pap.120703001453.285"><vh>renderAsCode</vh></v>
</v>
<v t="PAP.20040428010229" a="E"><vh>VBMissingPositional</vh>
<v t="PAP.20040428010229.1"><vh>__init__</vh></v>
<v t="PAP.20040428010229.2"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.286"><vh>Expression</vh>
<v t="pap.120703001453.287" a="E"><vh>VBExpression</vh>
<v t="pap.120703001453.288"><vh>__init__</vh></v>
<v t="pap.120703001453.289"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.290"><vh>checkForOperatorGroupings</vh></v>
</v>
<v t="pap.120703001453.291" a="E"><vh>Expression parts</vh>
<v t="pap.120703001453.292" a="E"><vh>VBParExpression</vh>
<v t="pap.120703001453.293"><vh>__init__</vh></v>
<v t="pap.120703001453.294"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.295"><vh>checkForOperatorGroupings</vh></v>
</v>
<v t="pap.120703001453.296"><vh>VBPoint</vh>
<v t="pap.120703001453.297"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.298" a="E"><vh>VBExpressionPart</vh>
<v t="pap.120703001453.299"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.300"><vh>finalizeObject</vh></v>
</v>
<v t="pap.120703001453.301"><vh>VBOperation</vh>
<v t="pap.120703001453.302"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.303"><vh>finalizeObject</vh></v>
</v>
<v t="pap.120703001453.304"><vh>VBStringLiteral</vh>
<v t="pap.120703001453.305"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.306" a="E"><vh>VBDateLiteral</vh>
<v t="pap.120703001453.307"><vh>renderAsCode</vh></v>
</v>
</v>
</v>
</v>
<v t="pap.120703001453.308"><vh>Project and Module classes</vh>
<v t="pap.120703001453.309" a="E"><vh>VBProject</vh>
<v t="pap.120703001453.310"><vh>__init__</vh></v>
<v t="pap.120703001453.311"><vh>resolveLocalName</vh></v>
</v>
<v t="pap.120703001453.312" a="E"><vh>VBModule </vh>
<v t="pap.120703001453.313"><vh>__init__</vh></v>
<v t="pap.120703001453.314"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.315"><vh>importStatements</vh></v>
<v t="pap.120703001453.316"><vh>renderDeclarations</vh></v>
<v t="pap.120703001453.317"><vh>renderBlocks</vh></v>
<v t="pap.120703001453.318"><vh>extractDocStrings</vh></v>
<v t="pap.120703001453.319"><vh>renderDocStrings</vh></v>
<v t="pap.120703001453.320"><vh>renderModuleHeader</vh></v>
<v t="pap.120703001453.321"><vh>resolveLocalName</vh></v>
<v t="pap.120703001453.322"><vh>enforcePrivateName</vh></v>
<v t="PAP.20040427013100"><vh>setCustomModulesAsGlobals</vh></v>
</v>
<v t="pap.120703001453.323"><vh>VBClassModule</vh>
<v t="pap.120703001453.324"><vh>__init__</vh></v>
<v t="pap.120703001453.325"><vh>renderModuleHeader</vh></v>
<v t="pap.120703001453.326"><vh>resolveLocalName</vh></v>
<v t="pap.20041206014616"><vh>assignParent</vh></v>
</v>
<v t="pap.120703001453.327"><vh>VBCodeModule</vh>
<v t="pap.120703001453.328"><vh>enforcePrivateName</vh></v>
</v>
<v t="pap.120703001453.329"><vh>VBFormModule</vh></v>
<v t="pap.20041207004405" a="E"><vh>VBCOMExternalModule</vh>
<v t="pap.20041207012020"><vh>__init__</vh></v>
<v t="pap.20041207011116"><vh>renderDeclarations</vh></v>
</v>
</v>
<v t="pap.120703001453.330"><vh>Single Statements</vh>
<v t="pap.120703001453.331" a="E"><vh>VBVariableDefinition</vh>
<v t="pap.120703001453.332"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.333"><vh>VBConstant </vh>
<v t="pap.120703001453.334"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.335"><vh>VBReDim</vh>
<v t="pap.120703001453.336"><vh>__init__</vh></v>
<v t="pap.120703001453.337"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.338"><vh>VBAssignment</vh>
<v t="pap.120703001453.339"><vh>__init__</vh></v>
<v t="pap.120703001453.340"><vh>asString</vh></v>
<v t="pap.120703001453.341"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.342"><vh>checkForModuleGlobals</vh></v>
</v>
<v t="pap.120703001453.343"><vh>VBSpecialAssignment</vh>
<v t="pap.120703001453.344"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.345"><vh>VBLSet</vh></v>
<v t="pap.120703001453.346"><vh>VBRSet</vh></v>
<v t="pap.120703001453.347"><vh>VBSet</vh>
<v t="pap.120703001453.348"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.349"><vh>VBEnd</vh>
<v t="pap.120703001453.350"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.351"><vh>VBCall</vh>
<v t="pap.120703001453.352"><vh>__init__</vh></v>
<v t="pap.120703001453.353"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.354"><vh>Exit Statement</vh>
<v t="pap.120703001453.355"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.356"><vh>VBComment</vh>
<v t="pap.120703001453.357"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.358"><vh>asString</vh></v>
</v>
<v t="pap.120703001453.359"><vh>VBLabel</vh></v>
<v t="pap.120703001453.360"><vh>File related</vh>
<v t="pap.120703001453.361"><vh>VBOpen</vh>
<v t="pap.120703001453.362"><vh>__init__</vh></v>
<v t="pap.120703001453.363"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.364"><vh>VBClose</vh>
<v t="pap.120703001453.365"><vh>__init__</vh></v>
<v t="pap.120703001453.366"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.367"><vh>VBSeek</vh>
<v t="pap.120703001453.368"><vh>__init__</vh></v>
<v t="pap.120703001453.369"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.370"><vh>VBInput</vh>
<v t="pap.120703001453.371"><vh>__init__</vh></v>
<v t="pap.120703001453.372"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.373"><vh>VBLineInput</vh></v>
<v t="pap.120703001453.374"><vh>VBPrint</vh>
<v t="pap.120703001453.375"><vh>__init__</vh></v>
<v t="pap.120703001453.376"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.377"><vh>VBPrintSeparator</vh>
<v t="pap.120703001453.378"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.379"><vh>VBName</vh>
<v t="pap.120703001453.380"><vh>__init__</vh></v>
<v t="pap.120703001453.381"><vh>renderAsCode</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.382" a="E"><vh>Compound Statements</vh>
<v t="pap.120703001453.383"><vh>VBUserType</vh>
<v t="pap.120703001453.384"><vh>__init__</vh></v>
<v t="pap.120703001453.385"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.386"><vh>VBSubroutine </vh>
<v t="pap.120703001453.387"><vh>__init__</vh></v>
<v t="pap.120703001453.388"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.389"><vh>renderParameters</vh></v>
<v t="pap.120703001453.390" a="E"><vh>resolveLocalName</vh></v>
<v t="pap.120703001453.391"><vh>renderGlobalStatement</vh></v>
<v t="pap.120703001453.392"><vh>assignParent</vh></v>
</v>
<v t="pap.120703001453.393"><vh>VBFunction</vh>
<v t="pap.120703001453.394"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.395"><vh>If</vh>
<v t="pap.120703001453.396"><vh>VBIf</vh>
<v t="pap.120703001453.397"><vh>__init__</vh></v>
<v t="pap.120703001453.398"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.399"><vh>VBElseIf</vh>
<v t="pap.120703001453.400"><vh>__init__</vh></v>
<v t="pap.120703001453.401"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.402"><vh>VBInlineIf</vh>
<v t="pap.120703001453.403"><vh>__init__</vh></v>
<v t="pap.120703001453.404"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.405" a="E"><vh>Select</vh>
<v t="pap.120703001453.406" a="E"><vh>VBSelect</vh>
<v t="pap.120703001453.407"><vh>__init__</vh></v>
<v t="pap.120703001453.408"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.409"><vh>getSelectVariable</vh></v>
</v>
<v t="pap.120703001453.410"><vh>VBCaseBlock</vh>
<v t="pap.120703001453.411"><vh>__init__</vh></v>
</v>
<v t="pap.120703001453.412"><vh>VBCaseItem</vh>
<v t="pap.120703001453.413"><vh>renderAsCode</vh>
<v t="PAP.20040122010006"><vh>&lt;&lt; Handle single expression &gt;&gt;</vh></v>
</v>
</v>
<v t="pap.120703001453.414"><vh>VBCaseElse</vh>
<v t="pap.120703001453.415"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.416" a="E"><vh>VBFor</vh>
<v t="pap.120703001453.417"><vh>__init__</vh></v>
<v t="pap.120703001453.418"><vh>renderAsCode</vh></v>
<v t="pap.20070225000746"><vh>handleDottedName</vh></v>
</v>
<v t="pap.120703001453.419" a="E"><vh>VBForEach</vh>
<v t="pap.120703001453.420"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.421"><vh>While</vh>
<v t="pap.120703001453.422"><vh>__init__</vh></v>
<v t="pap.120703001453.423"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.424"><vh>Do</vh>
<v t="pap.120703001453.425"><vh>__init__</vh></v>
<v t="pap.120703001453.426"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.427"><vh>VBWith</vh>
<v t="pap.120703001453.428"><vh>__init__</vh></v>
<v t="pap.120703001453.429"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.430"><vh>VBProperty</vh>
<v t="pap.120703001453.431"><vh>__init__</vh></v>
<v t="pap.120703001453.432"><vh>renderPropertyGroup</vh></v>
</v>
<v t="pap.120703001453.433"><vh>Enums</vh>
<v t="pap.120703001453.434"><vh>VBEnum</vh>
<v t="pap.120703001453.435"><vh>__init__</vh></v>
<v t="pap.120703001453.436"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.437"><vh>VBEnumItem</vh>
<v t="pap.120703001453.438"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.439"><vh>Non-VB Classes</vh>
<v t="pap.120703001453.440"><vh>VB2PYDirective </vh>
<v t="pap.120703001453.441"><vh>__init__</vh></v>
<v t="pap.120703001453.442"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.443"><vh>assignParent</vh></v>
</v>
<v t="pap.120703001453.444"><vh>VBPass</vh></v>
<v t="pap.120703001453.445"><vh>VBRenderDirect</vh></v>
<v t="pap.120703001453.446"><vh>VBNothing</vh></v>
<v t="pap.120703001453.447"><vh>VBParserFailure</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.448"><vh>VB mimic fns and classes</vh>
<v t="pap.120703001453.449"><vh>vbclasses.py</vh>
<v t="pap.120703001453.450"><vh>Collection class</vh>
<v t="pap.120703001453.451"><vh>Hidden methods</vh>
<v t="pap.120703001453.452"><vh>__init__</vh></v>
<v t="pap.120703001453.453"><vh>__setitem__</vh></v>
<v t="pap.120703001453.454"><vh>__getitem__</vh></v>
<v t="pap.120703001453.455"><vh>__delitem__</vh></v>
<v t="pap.120703001453.456"><vh>__call__</vh></v>
<v t="pap.120703001453.457"><vh>__iter__</vh></v>
<v t="pap.120703001453.458"><vh>_getElement</vh></v>
<v t="pap.120703001453.459"><vh>_order</vh></v>
</v>
<v t="pap.120703001453.460"><vh>Add</vh></v>
<v t="pap.120703001453.461"><vh>Count</vh></v>
<v t="pap.120703001453.462"><vh>Remove</vh></v>
<v t="pap.120703001453.463"><vh>Item</vh></v>
</v>
<v t="pap.120703001453.464"><vh>Debug</vh></v>
<v t="pap.120703001453.465"><vh>Time</vh></v>
<v t="pap.120703001453.466"><vh>Integer</vh></v>
<v t="pap.120703001453.467"><vh>Single</vh></v>
<v t="pap.120703001453.468"><vh>Double</vh></v>
<v t="pap.120703001453.469"><vh>Long</vh></v>
<v t="pap.120703001453.470"><vh>Boolean</vh></v>
<v t="pap.120703001453.471"><vh>Byte</vh></v>
<v t="pap.120703001453.472"><vh>Object</vh></v>
<v t="pap.120703001453.473"><vh>Variant</vh></v>
<v t="pap.120703001453.474"><vh>FixedString</vh></v>
<v t="pap.120703001453.475"><vh>IsMissing</vh></v>
<v t="pap.120703001453.476"><vh>VBArray</vh>
<v t="pap.120703001453.477"><vh>__init__</vh></v>
<v t="pap.120703001453.478"><vh>__call__</vh></v>
<v t="pap.120703001453.479"><vh>__setitem__</vh></v>
<v t="pap.120703001453.480"><vh>__getitem__</vh></v>
<v t="pap.120703001453.481"><vh>__ubound__</vh></v>
<v t="pap.120703001453.482"><vh>__lbound__</vh></v>
<v t="pap.120703001453.483"><vh>__contents__</vh></v>
<v t="pap.120703001453.484"><vh>__copyto__</vh></v>
<v t="pap.120703001453.485"><vh>createFromData</vh></v>
<v t="pap.120703001453.486"><vh>erase</vh></v>
</v>
<v t="pap.120703001453.487"><vh>VBFiles</vh>
<v t="pap.120703001453.488"><vh>__init__</vh></v>
<v t="pap.120703001453.489"><vh>openFile</vh></v>
<v t="pap.120703001453.490"><vh>closeFile</vh></v>
<v t="pap.120703001453.491"><vh>getInput</vh></v>
<v t="pap.120703001453.492"><vh>getLineInput</vh></v>
<v t="pap.120703001453.493"><vh>writeText</vh></v>
<v t="pap.120703001453.494"><vh>seekFile</vh></v>
<v t="pap.120703001453.495"><vh>getFile</vh></v>
<v t="pap.120703001453.496"><vh>getChars</vh></v>
<v t="pap.120703001453.497"><vh>getOpenChannels</vh></v>
<v t="PAP.20040131184456"><vh>EOF</vh></v>
</v>
<v t="pap.120703001453.498"><vh>App</vh></v>
</v>
<v t="pap.120703001453.499"><vh>vbfunctions.py</vh>
<v t="pap.120703001453.500"><vh>&lt;&lt; Error classes &gt;&gt;</vh></v>
<v t="pap.120703001453.533"><vh>Array</vh></v>
<v t="pap.120703001453.509"><vh>CBool</vh></v>
<v t="pap.120703001453.538"><vh>Choose</vh></v>
<v t="pap.120703001453.530"><vh>CreateObject</vh></v>
<v t="pap.120703001453.520"><vh>Dir</vh></v>
<v t="PAP.20040126231438"><vh>Environ</vh></v>
<v t="pap.120703001453.521"><vh>Erase</vh></v>
<v t="PAP.20040131184456.1"><vh>EOF</vh></v>
<v t="PAP.20040123194620"><vh>FileLen</vh></v>
<v t="PAP.20040130005556"><vh>Filter</vh></v>
<v t="pap.120703001453.525"><vh>FreeFile</vh></v>
<v t="pap.120703001453.514"><vh>Hex</vh></v>
<v t="pap.120703001453.535"><vh>IIf</vh></v>
<v t="pap.120703001453.524"><vh>Input</vh></v>
<v t="pap.120703001453.515"><vh>InStr</vh></v>
<v t="PAP.20040124130157"><vh>InStrRev</vh></v>
<v t="pap.120703001453.510"><vh>Int / CByte / CInt / CLng</vh></v>
<v t="pap.120703001453.534"><vh>IsArray</vh></v>
<v t="pap.120703001453.517"><vh>IsNumeric</vh></v>
<v t="pap.120703001453.537"><vh>Join</vh></v>
<v t="pap.120703001453.526"><vh>Lcase / Ucase</vh></v>
<v t="pap.120703001453.505"><vh>Left</vh></v>
<v t="pap.120703001453.518"><vh>Like</vh></v>
<v t="pap.120703001453.531"><vh>LoadPicture</vh></v>
<v t="PAP.20040126223432"><vh>Lof</vh></v>
<v t="pap.120703001453.512"><vh>Log / Exp </vh></v>
<v t="pap.120703001453.522"><vh>LSet</vh></v>
<v t="pap.20070203154528"><vh>MakeDate</vh></v>
<v t="pap.120703001453.507"><vh>Mid</vh></v>
<v t="pap.120703001453.513"><vh>Oct</vh></v>
<v t="PAP.20040126232735"><vh>RGB</vh></v>
<v t="PAP.20040130002515"><vh>Replace</vh></v>
<v t="pap.120703001453.506"><vh>Right</vh></v>
<v t="pap.120703001453.532"><vh>Rnd/Randomize</vh></v>
<v t="pap.120703001453.523"><vh>RSet</vh></v>
<v t="pap.120703001453.519"><vh>Seek</vh></v>
<v t="pap.120703001453.541"><vh>Settings Support</vh>
<v t="pap.120703001453.542"><vh>_OptionsDB</vh></v>
<v t="pap.120703001453.543"><vh>GetSetting</vh></v>
<v t="pap.120703001453.544"><vh>GetAllSettings</vh></v>
<v t="pap.120703001453.545"><vh>SaveSetting</vh></v>
<v t="pap.120703001453.546"><vh>DeleteSetting</vh></v>
</v>
<v t="pap.120703001453.508"><vh>Sgn</vh></v>
<v t="pap.120703001453.527"><vh>Space / Spc / String</vh></v>
<v t="pap.120703001453.540"><vh>Split</vh></v>
<v t="pap.120703001453.511"><vh>Sqr + Trig fns</vh></v>
<v t="pap.120703001453.536"><vh>StrReverse</vh></v>
<v t="pap.120703001453.539"><vh>Switch</vh></v>
<v t="PAP.20040126223803"><vh>Timer</vh></v>
<v t="pap.120703001453.528"><vh>Trim / Ltrim / Rtrim</vh></v>
<v t="pap.120703001453.529"><vh>UBound / LBound</vh></v>
<v t="pap.120703001453.516"><vh>Val</vh></v>
<v t="pap.120703001453.502"><vh>vbForRange</vh></v>
<v t="pap.120703001453.504"><vh>vbGetEventArgs</vh></v>
<v t="pap.120703001453.501"><vh>VBMissingArgument</vh></v>
<v t="PAP.20040428015634"><vh>VBGetMissingArgument</vh></v>
<v t="pap.120703001453.503"><vh>vbObjectInitialize</vh></v>
<v t="pap.120703001453.547"><vh>Existing python intrinsics</vh></v>
</v>
<v t="pap.120703001453.548"><vh>@file-asis settings.ini</vh></v>
<v t="pap.120703001453.549"><vh>vbdebug.py</vh></v>
<v t="PAP.20040427002644" a="E"><vh>Custom Modules</vh>
<v t="PAP.20040427015439"><vh>__init__.py</vh></v>
<v t="PAP.20040427002644.1"><vh>comctllib.py</vh>
<v t="PAP.20040428002958"><vh>&lt;&lt; Constants &gt;&gt;</vh></v>
<v t="PAP.20040427002644.2" a="E"><vh>class Node</vh>
<v t="PAP.20040427002644.3"><vh>&lt;&lt; class Node declarations &gt;&gt;</vh></v>
<v t="PAP.20040427002644.4"><vh>__init__</vh></v>
<v t="PAP.20040429020941.1"><vh>Key</vh></v>
<v t="PAP.20040429020941.2"><vh>Expanded</vh></v>
</v>
</v>
</v>
</v>
<v t="pap.120703001453.550"><vh>Configuration</vh>
<v t="pap.120703001453.551" a="E" tnodeList="pap.120703001453.551,PAP.20040202230624,pap.20070203192530,PAP.20040202230624.1,PAP.20040202230624.2,PAP.20040202230624.3,PAP.20040202230624.4,PAP.20040202230624.5,PAP.20040202230624.6,PAP.20040202230624.7,PAP.20040427003436"><vh>@file vb2py.ini</vh>
<v t="PAP.20040202230624"><vh>General</vh></v>
<v t="pap.20070203192530"><vh>Style</vh></v>
<v t="PAP.20040202230624.1"><vh>Functions</vh></v>
<v t="PAP.20040202230624.2"><vh>Select</vh></v>
<v t="PAP.20040202230624.3"><vh>Labels</vh></v>
<v t="PAP.20040202230624.4"><vh>With</vh></v>
<v t="PAP.20040202230624.5"><vh>Properties</vh></v>
<v t="PAP.20040202230624.6"><vh>Classes</vh></v>
<v t="PAP.20040202230624.7"><vh>Logger</vh></v>
<v t="PAP.20040427003436"><vh>CustomIncludes</vh></v>
</v>
<v t="pap.120703001453.552"><vh>config.py</vh></v>
</v>
<v t="pap.120703001453.553"><vh>Extensions and plugins</vh>
<v t="pap.120703001453.554"><vh>__init__.py</vh></v>
<v t="pap.120703001453.555" a="E"><vh>Plug-ins</vh>
<v t="pap.120703001453.556"><vh>loadAllPlugins</vh></v>
<v t="pap.120703001453.557"><vh>disableLogging</vh></v>
<v t="pap.120703001453.558"><vh>BasePlugin</vh>
<v t="pap.120703001453.559"><vh>__init__</vh></v>
<v t="pap.120703001453.560"><vh>preProcessVBText</vh></v>
<v t="pap.120703001453.561"><vh>postProcessPythonText</vh></v>
<v t="pap.120703001453.562"><vh>disable</vh></v>
<v t="pap.120703001453.563"><vh>isEnabled</vh></v>
<v t="pap.120703001453.564"><vh>__cmp__</vh></v>
</v>
<v t="pap.120703001453.565"><vh>ReTextMarkup</vh>
<v t="pap.120703001453.566"><vh>preProcessVBText</vh></v>
<v t="pap.120703001453.567"><vh>postProcessPythonText</vh></v>
<v t="pap.120703001453.568"><vh>processText</vh></v>
</v>
<v t="pap.120703001453.569"><vh>RenderHookPlugin</vh>
<v t="pap.120703001453.570"><vh>__init__</vh></v>
<v t="pap.120703001453.571"><vh>addMarkup</vh></v>
</v>
<v t="pap.120703001453.572" a="E"><vh>SystemPlugins</vh></v>
</v>
<v t="pap.120703001453.573" a="E"><vh>Examples</vh>
<v t="pap.120703001453.574"><vh>testplugin1</vh></v>
</v>
<v t="pap.120703001453.575" a="E"><vh>Core plugins</vh>
<v t="PAP.20040824000823" a="E"><vh>recordset.py</vh></v>
<v t="pap.120703001453.576"><vh>continuations.py</vh></v>
<v t="pap.120703001453.577"><vh>removetypes.py</vh></v>
<v t="pap.120703001453.578"><vh>classmethods.py</vh></v>
<v t="pap.120703001453.579"><vh>nothingtonone.py</vh></v>
<v t="pap.120703001453.580"><vh>attributenames.py</vh></v>
</v>
</v>
<v t="pap.120703001453.581"><vh>Package</vh>
<v t="pap.120703001453.582" a="E"><vh>setup.py</vh>
<v t="pap.120703001453.583"><vh>Supporting functions</vh></v>
</v>
<v t="pap.120703001453.584"><vh>MANIFEST.in</vh></v>
<v t="pap.120703001453.585"><vh>@file-asis README.txt</vh></v>
<v t="pap.120703001453.586"><vh>@file-asis LICENCE.txt</vh></v>
</v>
</v>
<v t="pap.20070203003154"><vh>GUI</vh>
<v t="pap.20070203103920"><vh>Main Window</vh>
<v t="pap.20070203003154.1" a="E"
expanded="pap.20070203003154.3,pap.20070203003154.31,"><vh>@thin vb2pyGUI.pyw</vh></v>
<v t="pap.20070203004134"><vh>@thin vb2pyGUI.rsrc.py</vh></v>
</v>
<v t="pap.20070203103920.1"><vh>Find Dialog</vh>
<v t="pap.20070203003236"
expanded="pap.20070203003236.2,"><vh>@thin finddialog.py</vh></v>
<v t="pap.20070203103920.2" tnodeList="pap.20070203103920.2"><vh>@file finddialog.rsrc.py</vh></v>
</v>
<v t="pap.20070203103920.3"><vh>Testing Form</vh>
<v t="pap.20070203003321"><vh>@thin testingview.py</vh></v>
</v>
<v t="pap.20070203103920.4"><vh>Options Form</vh>
<v t="pap.20070203003353" a="E"><vh>@thin vb2pyOptions.py</vh></v>
</v>
<v t="pap.20070203162417"><vh>UI</vh>
<v t="pap.20070203162417.1"
expanded="pap.20070203162417.3,"><vh>@thin vb2pyMain.py</vh></v>
<v t="pap.20070203162417.6"><vh>@thin vb2pyMain.rsrc.py</vh></v>
<v t="pap.20070203172243.1" a="E"
expanded="pap.20070203172243.3,"><vh>@thin interactive.py</vh></v>
<v t="pap.20070203172243.5"><vh>@thin interactive.rsrc.py</vh></v>
</v>
</v>
<v t="pap.120703001453.600" a="E"><vh>Testing</vh>
<v t="pap.120703001453.601"><vh>__init__.py</vh></v>
<v t="pap.120703001453.602" a="E"><vh>Mini parser for quick testing</vh>
<v t="pap.120703001453.656"><vh>For</vh></v>
</v>
<v t="pap.120703001453.604" a="E"><vh>Test Parsing</vh>
<v t="pap.120703001453.605"><vh>Single statements</vh>
<v t="pap.120703001453.606"><vh>Assignment</vh></v>
<v t="pap.120703001453.607"><vh>Expressions</vh></v>
<v t="pap.120703001453.608"><vh>ByVal and ByRef</vh></v>
<v t="pap.120703001453.609"><vh>Comments</vh></v>
<v t="pap.120703001453.610"><vh>Directives</vh></v>
<v t="pap.120703001453.611"><vh>Continuations</vh></v>
<v t="pap.120703001453.612"><vh>Dim etc</vh>
<v t="pap.120703001453.613"><vh>Simple dims</vh></v>
<v t="pap.120703001453.614"><vh>Arrays and ReDims</vh></v>
<v t="pap.120703001453.615"><vh>Constants</vh></v>
<v t="pap.120703001453.616"><vh>Oddities</vh></v>
</v>
<v t="pap.120703001453.617"><vh>Calls</vh></v>
<v t="pap.120703001453.618"><vh>Labels and Goto's</vh></v>
<v t="pap.120703001453.619"><vh>Multi statement lines</vh></v>
<v t="pap.120703001453.620"><vh>Open/Close</vh></v>
<v t="pap.120703001453.621"><vh>Print#, Get# etc</vh></v>
<v t="pap.120703001453.622"><vh>External libraries</vh></v>
<v t="pap.120703001453.623"><vh>On Error</vh></v>
<v t="pap.120703001453.624"><vh>Lines (join two points)</vh></v>
<v t="pap.120703001453.625"><vh>Name statement</vh></v>
<v t="pap.120703001453.626"><vh>Attribute statement</vh></v>
<v t="pap.120703001453.627"><vh>Enum statement</vh></v>
<v t="pap.120703001453.628"><vh>Types</vh></v>
<v t="pap.120703001453.629"><vh>Option</vh></v>
<v t="pap.120703001453.630"><vh>End Statement</vh></v>
<v t="pap.120703001453.631"><vh>Events</vh></v>
<v t="pap.120703001453.603"><vh>Debug</vh></v>
<v t="PAP.20040824001655"><vh>Recordsets</vh></v>
<v t="pap.20070224180440"><vh>Unicode</vh></v>
</v>
<v t="pap.120703001453.632" a="E"><vh>Compound statements</vh>
<v t="pap.120703001453.633"><vh>If</vh>
<v t="pap.120703001453.634"><vh>Just If</vh></v>
<v t="pap.120703001453.635"><vh>If  Else</vh></v>
<v t="pap.120703001453.636"><vh>If  ElseIf</vh></v>
<v t="pap.120703001453.637"><vh>If  ElseIf Else</vh></v>
<v t="pap.120703001453.638"><vh>Nested If</vh></v>
<v t="pap.120703001453.639"><vh>Inline If</vh></v>
<v t="pap.120703001453.640"><vh>#if</vh></v>
</v>
<v t="pap.120703001453.641"><vh>Subroutines</vh>
<v t="pap.120703001453.642"><vh>Simple subroutine</vh></v>
<v t="pap.120703001453.643"><vh>Subroutine with arguments</vh></v>
<v t="pap.120703001453.644"><vh>Subroutine with typed arguments</vh></v>
<v t="pap.120703001453.645"><vh>Subroutine with optional typed arguments</vh></v>
<v t="pap.120703001453.646"><vh>Subroutine with ByVal args</vh></v>
<v t="PAP.20040131185143"><vh>Subroutine with space</vh></v>
</v>
<v t="pap.120703001453.647"><vh>Functions</vh>
<v t="pap.120703001453.648"><vh>Simple Function</vh></v>
<v t="pap.120703001453.649"><vh>Function with arguments</vh></v>
<v t="pap.120703001453.650"><vh>Function with typed arguments</vh></v>
<v t="pap.120703001453.651"><vh>Function with optional typed arguments</vh></v>
<v t="pap.120703001453.652"><vh>Function with ByVal args</vh></v>
</v>
<v t="pap.120703001453.653"><vh>Properties</vh></v>
<v t="pap.120703001453.654"><vh>Select</vh></v>
<v t="pap.120703001453.655" a="E"><vh>For statements</vh>
<v t="pap.120703001453.656"><vh>For</vh></v>
<v t="pap.120703001453.657"><vh>For each</vh></v>
</v>
<v t="pap.120703001453.658"><vh>Do While etc</vh>
<v t="pap.120703001453.659"><vh>While/Wend</vh></v>
<v t="pap.120703001453.660"><vh>Do While / Loop</vh></v>
<v t="pap.120703001453.661"><vh>Do Loop</vh></v>
<v t="pap.120703001453.662"><vh>Do Loop While</vh></v>
<v t="pap.120703001453.663"><vh>Do Loop Until</vh></v>
<v t="pap.120703001453.664"><vh>Do Until</vh></v>
</v>
<v t="pap.120703001453.665"><vh>Types</vh></v>
<v t="pap.120703001453.666"><vh>With</vh></v>
<v t="pap.120703001453.667"><vh>Class and module header</vh></v>
<v t="pap.120703001453.668"><vh>Enumerations</vh></v>
</v>
<v t="pap.120703001453.669"><vh>Failing tests</vh></v>
</v>
<v t="pap.120703001453.670" a="E"><vh>Test Basic Conversion</vh>
<v t="pap.120703001453.671"><vh>Basic Testing Framework</vh>
<v t="PAP.20040125002850"><vh>getTestMethod</vh>
<v t="pap.120703001453.672"><vh>&lt;&lt; Parse VB &gt;&gt;</vh></v>
<v t="pap.120703001453.673"><vh>&lt;&lt; Execute the Python code &gt;&gt;</vh></v>
<v t="pap.120703001453.674"><vh>&lt;&lt; Work out what is expected &gt;&gt;</vh></v>
<v t="pap.120703001453.675"><vh>&lt;&lt; Check for discrepancies &gt;&gt;</vh></v>
</v>
<v t="PAP.20040125002850.1"><vh>getScriptTestMethod</vh></v>
</v>
<v t="pap.120703001453.676"><vh>Variable assignment</vh>
<v t="pap.120703001453.677"><vh>General</vh></v>
<v t="pap.120703001453.678"><vh>General - Let</vh></v>
<v t="pap.120703001453.679"><vh>Expressions</vh></v>
<v t="pap.120703001453.680"><vh>Set</vh></v>
<v t="pap.120703001453.681"><vh>With type markers</vh></v>
<v t="pap.120703001453.682"><vh>Conditionals</vh></v>
<v t="pap.120703001453.683"><vh>LSet</vh></v>
<v t="pap.120703001453.684"><vh>RSet</vh></v>
</v>
<v t="pap.120703001453.685"><vh>Ifs</vh>
<v t="pap.120703001453.686"><vh>Single If</vh>
<v t="pap.120703001453.687"><vh>If</vh></v>
<v t="pap.120703001453.688"><vh>If with else</vh></v>
<v t="pap.120703001453.689"><vh>If with elseif</vh></v>
</v>
<v t="pap.120703001453.690"><vh>Nested If</vh>
<v t="pap.120703001453.691"><vh>If</vh></v>
<v t="pap.120703001453.692"><vh>If with else</vh></v>
<v t="pap.120703001453.693"><vh>If with elseif</vh></v>
</v>
<v t="pap.120703001453.694"><vh>Inline If</vh></v>
</v>
<v t="pap.120703001453.695"><vh>Select</vh>
<v t="pap.120703001453.696"><vh>Simple select</vh></v>
<v t="pap.120703001453.697"><vh>Select with numerical range</vh></v>
<v t="pap.120703001453.698"><vh>Select with multiple values</vh></v>
<v t="pap.120703001453.699"><vh>Nested Select with multiple values</vh></v>
<v t="PAP.20040122000733"><vh>Using Is</vh></v>
</v>
<v t="pap.120703001453.700" a="E"><vh>Test For</vh>
<v t="pap.120703001453.701" a="V"><vh>Basic For</vh></v>
<v t="pap.120703001453.702"><vh>Nested For</vh></v>
<v t="pap.120703001453.703"><vh>For each</vh></v>
<v t="pap.120703001453.704"><vh>Non-integer</vh></v>
</v>
<v t="pap.120703001453.705"><vh>While and friends</vh>
<v t="pap.120703001453.706"><vh>While / Wend</vh></v>
<v t="pap.120703001453.707"><vh>Do While Loop</vh></v>
<v t="pap.120703001453.708"><vh>Do Loop</vh></v>
<v t="pap.120703001453.709"><vh>Do Loop Until</vh></v>
<v t="pap.120703001453.710"><vh>Do Until Loop</vh></v>
</v>
<v t="pap.120703001453.711"><vh>Functions</vh>
<v t="pap.120703001453.712"><vh>Simple fn</vh></v>
<v t="pap.120703001453.713"><vh>Recursion</vh></v>
<v t="pap.120703001453.714"><vh>Fn arguments</vh></v>
<v t="pap.120703001453.715"><vh>Named arguments</vh></v>
<v t="PAP.20040428003630.1"><vh>Missing positional arguments</vh></v>
</v>
<v t="pap.120703001453.716"><vh>Subroutines</vh>
<v t="pap.120703001453.717"><vh>Simple sub</vh></v>
<v t="pap.120703001453.718"><vh>Recursion</vh></v>
<v t="pap.120703001453.719"><vh>Optional arguments</vh></v>
<v t="pap.120703001453.720"><vh>Named arguments</vh></v>
</v>
<v t="pap.120703001453.721"><vh>Dims and arrays</vh>
<v t="pap.120703001453.722"><vh>Simple dims</vh></v>
<v t="pap.120703001453.723"><vh>Redims</vh></v>
<v t="pap.120703001453.724"><vh>Complex</vh></v>
<v t="pap.120703001453.725"><vh>Empty dims</vh></v>
<v t="PAP.20040427002005.4"><vh>Dims in functions</vh></v>
</v>
<v t="pap.120703001453.726"><vh>VB intrinsic functions I</vh>
<v t="pap.120703001453.727"><vh>String manipulation</vh></v>
<v t="pap.120703001453.728"><vh>String functions</vh></v>
<v t="pap.120703001453.729"><vh>General Functions</vh></v>
<v t="pap.120703001453.730"><vh>Converting types</vh></v>
<v t="pap.120703001453.731"><vh>Converting bases</vh></v>
<v t="pap.120703001453.732"><vh>Maths</vh></v>
<v t="pap.120703001453.733"><vh>Random</vh></v>
<v t="pap.120703001453.734"><vh>UBound</vh></v>
<v t="pap.120703001453.735"><vh>LBound</vh></v>
<v t="pap.120703001453.736"><vh>Val</vh></v>
<v t="pap.120703001453.737"><vh>Array</vh></v>
</v>
<v t="pap.120703001453.738" a="E"><vh>VB intrinsic functions II</vh>
<v t="pap.120703001453.739"><vh>IsArray</vh></v>
<v t="pap.120703001453.740"><vh>IIf</vh></v>
<v t="pap.120703001453.741"><vh>StrReverse</vh></v>
<v t="pap.120703001453.742"><vh>Choose</vh></v>
<v t="pap.120703001453.743"><vh>Join</vh></v>
<v t="pap.120703001453.744"><vh>Switch</vh></v>
<v t="pap.120703001453.745"><vh>Split</vh></v>
<v t="PAP.20040123193549"><vh>FileLen</vh></v>
<v t="PAP.20040126223058"><vh>Lof</vh></v>
<v t="PAP.20040126230303"><vh>Environ</vh></v>
</v>
<v t="PAP.20040125002850.2"><vh>VB intrinsic functions III</vh>
<v t="PAP.20040125002850.3"><vh>InStrRev</vh></v>
<v t="PAP.20040126225358"><vh>Timer</vh></v>
<v t="PAP.20040126231743"><vh>RGB</vh></v>
<v t="PAP.20040129235941"><vh>Round</vh></v>
<v t="PAP.20040130001614"><vh>Replace</vh></v>
<v t="PAP.20040130003725"><vh>Filter</vh></v>
</v>
<v t="pap.120703001453.746"><vh>Operators</vh>
<v t="pap.120703001453.747"><vh>Like</vh></v>
<v t="pap.120703001453.748"><vh>Xor</vh></v>
</v>
<v t="pap.120703001453.749"><vh>Types</vh>
<v t="pap.120703001453.750"><vh>Simple Types</vh></v>
<v t="pap.120703001453.751"><vh>Arrays of types</vh></v>
</v>
<v t="pap.120703001453.752"><vh>Files</vh>
<v t="pap.120703001453.753"><vh>Open/read/close</vh></v>
<v t="pap.120703001453.754"><vh>Open/print/close</vh></v>
<v t="pap.120703001453.755"><vh>Bare/Multiple close</vh></v>
<v t="pap.120703001453.756"><vh>Seek</vh></v>
<v t="pap.120703001453.757"><vh>Dir</vh></v>
<v t="pap.120703001453.758"><vh>FreeFile</vh></v>
<v t="pap.120703001453.759"><vh>ChDir</vh></v>
<v t="pap.120703001453.760"><vh>Kill</vh></v>
<v t="pap.120703001453.761"><vh>MkDir</vh></v>
<v t="pap.120703001453.762"><vh>RmDir</vh></v>
<v t="pap.120703001453.763"><vh>Name</vh></v>
<v t="pap.120703001453.764"><vh>FileCopy</vh></v>
<v t="PAP.20040130001231"><vh>Input</vh></v>
<v t="PAP.20040131184456.2"><vh>EOF</vh></v>
</v>
<v t="pap.120703001453.765"><vh>With</vh>
<v t="pap.120703001453.766"><vh>Basic</vh></v>
<v t="pap.120703001453.767"><vh>Nesting</vh></v>
</v>
<v t="pap.120703001453.768"><vh>Enums</vh>
<v t="pap.120703001453.769"><vh>Basic enum tests</vh></v>
</v>
<v t="pap.120703001453.770"><vh>Random</vh>
<v t="pap.120703001453.771"><vh>Random tests</vh></v>
</v>
<v t="pap.120703001453.772"><vh>Constants</vh>
<v t="pap.120703001453.773"><vh>Simple</vh></v>
</v>
<v t="pap.120703001453.774"><vh>Settings</vh>
<v t="pap.120703001453.775"><vh>Get and Set</vh></v>
<v t="pap.120703001453.776"><vh>GetAllSettings</vh></v>
<v t="pap.120703001453.777"><vh>DeleteSetting</vh></v>
</v>
<v t="pap.120703001453.778" a="E"><vh>Erase</vh>
<v t="pap.120703001453.779"><vh>Simple test</vh></v>
</v>
<v t="pap.120703001453.780"><vh>External references/CreateObject</vh>
<v t="pap.120703001453.781"><vh>CreateObject</vh></v>
</v>
<v t="pap.120703001453.782"><vh>Failing tests</vh>
<v t="pap.120703001453.783"><vh>Fn ByRef arguments</vh></v>
<v t="pap.120703001453.784"><vh>Sub ByRef arguments</vh></v>
</v>
</v>
<v t="pap.120703001453.785"><vh>Test More Complex Conversion</vh>
<v t="pap.120703001453.786"><vh>Complex Testing Framework</vh>
<v t="pap.120703001453.787"><vh>&lt;&lt; Parse VB &gt;&gt;</vh></v>
<v t="pap.120703001453.788" a="E"><vh>&lt;&lt; Execute the Python code &gt;&gt;</vh></v>
<v t="pap.120703001453.789"><vh>&lt;&lt; Check assertions &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.790" a="EM"><vh>Class methods and functions</vh>
<v t="pap.120703001453.791"><vh>Simple methods</vh></v>
<v t="pap.120703001453.792"><vh>Simple functions</vh></v>
<v t="PAP.20040428020405"><vh>Missing positional arguments</vh></v>
<v t="pap.120703001453.793"><vh>Private methods</vh></v>
<v t="pap.120703001453.794"><vh>Class initialize and terminate</vh></v>
<v t="pap.120703001453.795"><vh>Class properties</vh></v>
<v t="pap.120703001453.796"><vh>Converting Me</vh></v>
</v>
<v t="pap.120703001453.797"><vh>Code module locals</vh>
<v t="pap.120703001453.798"><vh>Module locals</vh></v>
</v>
<v t="pap.120703001453.799"><vh>Properties</vh>
<v t="pap.120703001453.800"><vh>Simple property</vh></v>
<v t="pap.120703001453.801"><vh>Multiple properties</vh></v>
<v t="pap.120703001453.802"><vh>Misc</vh></v>
</v>
<v t="pap.120703001453.803"><vh>Private data</vh>
<v t="pap.120703001453.804"><vh>Simple private data</vh></v>
<v t="pap.120703001453.805"><vh>Private subs</vh></v>
<v t="pap.120703001453.806"><vh>Private fns</vh></v>
<v t="pap.120703001453.807"><vh>Private properties</vh></v>
</v>
<v t="pap.120703001453.808"><vh>Globals</vh>
<v t="pap.120703001453.809"><vh>setUp</vh></v>
<v t="pap.120703001453.810"><vh>testSimple</vh></v>
<v t="pap.120703001453.811"><vh>testSimpleNoLookup</vh></v>
<v t="pap.120703001453.812"><vh>testLocalsShadowGlobals</vh></v>
<v t="pap.120703001453.813"><vh>testParametersShadowGlobals</vh></v>
<v t="pap.120703001453.814"><vh>testPropertyShadowGlobals</vh></v>
<v t="pap.120703001453.815"><vh>testSub/FnGlobals</vh></v>
<v t="pap.120703001453.816"><vh>testGlobalButLocalHere</vh></v>
</v>
<v t="pap.20041206011550" a="EM"><vh>Imports</vh>
<v t="pap.20041206011605"><vh>testImportClassToModule</vh></v>
</v>
<v t="PAP.20040427003836"><vh>testcustomimport.py</vh>
<v t="PAP.20040427003836.1" a="E"><vh>TestCustomImport</vh>
<v t="PAP.20040427003836.2"><vh>setUp</vh></v>
<v t="PAP.20040427003836.3"><vh>testComctlLib</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.817"><vh>Test VB Mimic functions</vh>
<v t="pap.120703001453.818"><vh>Test Collection</vh>
<v t="pap.120703001453.819"><vh>testAddNumeric</vh></v>
<v t="pap.120703001453.820"><vh>testAddBeforeNumeric</vh></v>
<v t="pap.120703001453.821"><vh>testAddAfterNumeric</vh></v>
<v t="pap.120703001453.822"><vh>testAddText</vh></v>
<v t="pap.120703001453.823"><vh>testAddTextandNumeric</vh></v>
<v t="pap.120703001453.824"><vh>testItemNumeric</vh></v>
<v t="pap.120703001453.825"><vh>testItemText</vh></v>
<v t="pap.120703001453.826"><vh>testRemoveNumeric</vh></v>
<v t="pap.120703001453.827"><vh>testRemoveText</vh></v>
</v>
<v t="pap.120703001453.828"><vh>Test ObjectDefinition</vh>
<v t="pap.120703001453.829"><vh>test1D</vh></v>
<v t="pap.120703001453.830"><vh>test1DOffsetRange</vh></v>
<v t="pap.120703001453.831"><vh>test2D</vh></v>
<v t="pap.120703001453.832"><vh>test2DOffsetRange</vh></v>
<v t="pap.120703001453.833"><vh>test1DIteration</vh></v>
<v t="pap.120703001453.834"><vh>test1DIterationOffsetRange</vh></v>
<v t="pap.120703001453.835"><vh>test2DIteration</vh></v>
<v t="pap.120703001453.836"><vh>test2DIterationOffsetRange</vh></v>
</v>
</v>
<v t="pap.120703001453.837"><vh>Test Configuration</vh>
<v t="pap.120703001453.838"><vh>&lt;&lt; Setup info &gt;&gt;</vh></v>
<v t="pap.120703001453.839"><vh>Config Object</vh>
<v t="pap.120703001453.840"><vh>testGetConfig</vh></v>
<v t="pap.120703001453.841"><vh>testGetConfigMissing</vh></v>
<v t="pap.120703001453.842"><vh>testSetLocalOveride</vh></v>
<v t="pap.120703001453.843"><vh>testSetLocalOverideDoesntExist</vh></v>
<v t="pap.120703001453.844"><vh>testRemoveLocalOveride</vh></v>
</v>
<v t="pap.120703001453.845" a="E"><vh>Options</vh>
<v t="pap.120703001453.846"><vh>General</vh>
<v t="pap.120703001453.847"><vh>testSpaceOrTab</vh></v>
<v t="pap.120703001453.848"><vh>testIndentAmount</vh></v>
<v t="pap.120703001453.849"><vh>testRespectPrivateStatus</vh></v>
<v t="pap.120703001453.850"><vh>testPrivateDataPrefix</vh></v>
</v>
<v t="pap.120703001453.851"><vh>Functions</vh>
<v t="pap.120703001453.852"><vh>testFunctionVariable</vh></v>
<v t="pap.120703001453.853"><vh>testPreInitVariable</vh></v>
</v>
<v t="pap.120703001453.854" a="E"><vh>Select</vh>
<v t="pap.120703001453.855"><vh>testSelectVariable</vh></v>
<v t="pap.120703001453.856"><vh>testSelectVariableIndex</vh></v>
<v t="pap.120703001453.857"><vh>testEvalVariable</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.858"><vh>Test Plugins</vh>
<v t="pap.120703001453.859"><vh>testattributenames.py</vh>
<v t="pap.120703001453.860"><vh>testAll</vh></v>
</v>
</v>
<v t="PAP.20040125002850.4"><vh>scripttest.py</vh>
<v t="PAP.20040125002850.5"><vh>&lt;&lt; Error Classes &gt;&gt;</vh></v>
<v t="PAP.20040125002850.6"><vh>runTestCode</vh></v>
<v t="PAP.20040125002850.7"><vh>findVars</vh></v>
<v t="PAP.20040125002850.8"><vh>findDirectives</vh></v>
<v t="PAP.20040126003633"><vh>sendOutput</vh></v>
<v t="PAP.20040125002850.9"><vh>testCode</vh></v>
</v>
<v t="pap.120703001453.861"><vh>testall.py</vh></v>
<v t="PAP.20040123192735" tnodeList="PAP.20040123192735"><vh>@file test\vbtestfile.txt</vh></v>
</v>
<v t="pap.120703001453.862"><vh>Sandbox</vh>
<v t="pap.120703001453.863"><vh>__init__.py</vh></v>
<v t="pap.120703001453.864"><vh>commandline.py</vh></v>
<v t="pap.120703001453.865" a="E"><vh>makedocs.py</vh>
<v t="pap.120703001453.866"><vh>&lt;&lt; fn doAutomaticVBConversion &gt;&gt;</vh></v>
<v t="pap.120703001453.867"><vh>&lt;&lt; fn addToTemplate &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.868"><vh>dofile.py</vh></v>
<v t="pap.120703001453.869" a="E"><vh>Experiments</vh>
<v t="pap.120703001453.870"><vh>ByRef approaches</vh></v>
</v>
<v t="pap.120703001453.871"><vh>makeconstants.py</vh>
<v t="pap.120703001453.872"><vh>Key Codes</vh></v>
<v t="pap.120703001453.873"><vh>Form Codes</vh></v>
<v t="pap.120703001453.874"><vh>Colour Codes</vh></v>
<v t="pap.120703001453.875"><vh>Dir etc Codes</vh></v>
<v t="pap.120703001453.876"><vh>File Attribute Codes</vh></v>
<v t="pap.120703001453.877"><vh>Miscellaneous Codes</vh></v>
<v t="pap.120703001453.878"><vh>MsgBox Codes</vh></v>
<v t="pap.120703001453.879"><vh>Shell Codes</vh></v>
<v t="pap.120703001453.880"><vh>Special Folder Codes</vh></v>
<v t="pap.120703001453.881"><vh>StrConv Codes</vh></v>
<v t="pap.120703001453.882"><vh>System Colour Codes</vh></v>
<v t="pap.120703001453.883"><vh>Var Type Codes</vh></v>
</v>
<v t="pap.120703001453.884"><vh>convertasp.py</vh>
<v t="pap.120703001453.885"><vh>&lt;&lt; convertasp declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.886"><vh>translateScript</vh></v>
</v>
<v t="pap.120703001453.887"><vh>makeproperties.py</vh>
<v t="pap.120703001453.888"><vh>&lt;&lt; tlbrowse declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.889"><vh>class TypeBrowseDialog</vh>
<v t="pap.120703001453.890"><vh>&lt;&lt; class TypeBrowseDialog declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.891"><vh>Old methods</vh>
<v t="pap.120703001453.892"><vh>__init__</vh></v>
<v t="pap.120703001453.893"><vh>OnAttachedObjectDeath</vh></v>
<v t="pap.120703001453.894"><vh>_SetupMenu</vh></v>
<v t="pap.120703001453.895"><vh>OnFileOpen</vh></v>
<v t="pap.120703001453.896"><vh>OnInitDialog</vh></v>
<v t="pap.120703001453.897"><vh>_SetupTLB</vh></v>
<v t="pap.120703001453.898"><vh>_SetListviewTextItems</vh></v>
<v t="pap.120703001453.899"><vh>SetupAllInfoTypes</vh></v>
<v t="pap.120703001453.900"><vh>_GetMainInfoTypes</vh></v>
<v t="pap.120703001453.901"><vh>_GetMethodInfoTypes</vh></v>
<v t="pap.120703001453.902"><vh>CmdTypeListbox</vh></v>
<v t="pap.120703001453.903"><vh>_GetRealMemberPos</vh></v>
<v t="pap.120703001453.904"><vh>CmdMemberListbox</vh></v>
<v t="pap.120703001453.905"><vh>GetTemplate</vh></v>
</v>
<v t="pap.120703001453.906"><vh>New</vh>
<v t="pap.120703001453.907"><vh>dumpProperties</vh></v>
<v t="pap.120703001453.908"><vh>getTypes</vh></v>
<v t="pap.120703001453.909"><vh>getMembers</vh></v>
<v t="pap.120703001453.910"><vh>getAll</vh></v>
</v>
</v>
<v t="pap.120703001453.911"><vh>class VBControlObject</vh>
<v t="pap.120703001453.912"><vh>__init__</vh></v>
<v t="pap.120703001453.913"><vh>addProperty</vh></v>
<v t="pap.120703001453.914"><vh>addMethod</vh></v>
<v t="pap.120703001453.915"><vh>__repr__</vh></v>
</v>
<v t="pap.120703001453.916"><vh>class VBMethod</vh>
<v t="pap.120703001453.917"><vh>__init__</vh></v>
<v t="pap.120703001453.918"><vh>__repr__</vh></v>
<v t="pap.120703001453.919"><vh>__str__</vh></v>
</v>
<v t="pap.120703001453.920"><vh>enumerate</vh></v>
<v t="pap.120703001453.921"><vh>&lt;&lt; Convert to HTML &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.922"><vh>@file sandbox/filetesting.py</vh></v>
<v t="PAP.20040124130157.1"><vh>Using the Windows Script host</vh>
<v t="PAP.20040125001102"><vh>&lt;&lt; Error Classes &gt;&gt;</vh></v>
<v t="PAP.20040124130157.2"><vh>runTestCode</vh></v>
<v t="PAP.20040124130157.3"><vh>findVars</vh></v>
<v t="PAP.20040124130157.4"><vh>findDirectives</vh></v>
<v t="PAP.20040125001102.1"><vh>testCode</vh></v>
</v>
<v t="PAP.20040131003417"><vh>Generating Stub VB class</vh>
<v t="PAP.20040131003417.1"><vh>makevbclass.py</vh>
<v t="PAP.20040131003417.2"><vh>&lt;&lt; Declarations &gt;&gt;</vh></v>
<v t="PAP.20040131003417.3"><vh>&lt;&lt; Error classes &gt;&gt;</vh></v>
<v t="PAP.20040131003417.4"><vh>makeVBClass</vh></v>
<v t="PAP.20040131003417.5"><vh>makeVBClassFile</vh></v>
<v t="PAP.20040131003417.6"><vh>makeVBMethod</vh></v>
<v t="PAP.20040131003417.7"><vh>__main__</vh></v>
</v>
</v>
<v t="PAP.20040427013100.1"><vh>customimport.py</vh></v>
<v t="PAP.20040801174621"><vh>remoteservice.py</vh></v>
</v>
<v t="pap.120703001453.923"><vh>Contributions</vh>
<v t="pap.120703001453.450"><vh>Collection class</vh>
<v t="pap.120703001453.451"><vh>Hidden methods</vh>
<v t="pap.120703001453.452"><vh>__init__</vh></v>
<v t="pap.120703001453.453"><vh>__setitem__</vh></v>
<v t="pap.120703001453.454"><vh>__getitem__</vh></v>
<v t="pap.120703001453.455"><vh>__delitem__</vh></v>
<v t="pap.120703001453.456"><vh>__call__</vh></v>
<v t="pap.120703001453.457"><vh>__iter__</vh></v>
<v t="pap.120703001453.458"><vh>_getElement</vh></v>
<v t="pap.120703001453.459"><vh>_order</vh></v>
</v>
<v t="pap.120703001453.460"><vh>Add</vh></v>
<v t="pap.120703001453.461"><vh>Count</vh></v>
<v t="pap.120703001453.462"><vh>Remove</vh></v>
<v t="pap.120703001453.463"><vh>Item</vh></v>
</v>
<v t="pap.120703001453.924"><vh>Floating point range</vh></v>
<v t="pap.120703001453.925"><vh>Pointer implementation</vh></v>
<v t="PAP.20040430190921"><vh>Closure approach to byref arguments</vh></v>
<v t="pap.120703001453.926"><vh>this()</vh></v>
<v t="pap.120703001453.927"><vh>Getting the path of the script</vh></v>
<v t="pap.120703001453.928"><vh>Websites</vh></v>
<v t="PAP.20040824001912"><vh>Recordset stuff</vh>
<v t="PAP.20040824000823"><vh>recordset.py</vh></v>
<v t="PAP.20040824001655"><vh>Recordsets</vh></v>
</v>
</v>
<v t="pap.120703001453.929"><vh>Old stuff</vh>
<v t="pap.120703001453.930"><vh>vbparser.py</vh></v>
<v t="pap.120703001453.931"><vh>spexample.py</vh></v>
<v t="pap.120703001453.932"><vh>testparser.py</vh>
<v t="pap.120703001453.933"><vh>TestLines</vh></v>
<v t="pap.120703001453.934"><vh>TestSubFnBlock</vh>
<v t="pap.120703001453.935"><vh>&lt;&lt; Single sub &gt;&gt;</vh></v>
</v>
</v>
<v t="pap.120703001453.936"><vh>vbcode.py</vh>
<v t="pap.120703001453.937"><vh>&lt;&lt; Documentation &gt;&gt;</vh></v>
<v t="pap.120703001453.938"><vh>&lt;&lt; Declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.939"><vh>class BaseVariable</vh>
<v t="pap.120703001453.940"><vh>__init__</vh></v>
</v>
<v t="pap.120703001453.941"><vh>class BaseNameSpace</vh>
<v t="pap.120703001453.942"><vh>&lt;&lt; BaseNameSpace declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.943"><vh>__init__</vh></v>
<v t="pap.120703001453.944"><vh>initVariablesFromText</vh></v>
</v>
<v t="pap.120703001453.945"><vh>class BaseModule</vh>
<v t="pap.120703001453.946"><vh>__init__</vh></v>
<v t="pap.120703001453.947"><vh>initFromText</vh></v>
<v t="pap.120703001453.948"><vh>initFunctionsFromText</vh></v>
</v>
</v>
<v t="pap.120703001453.949" a="E"><vh>EBNF</vh></v>
<v t="pap.120703001453.950"><vh>From vb2py</vh>
<v t="pap.120703001453.951"><vh>&lt;&lt; Rename VB events &gt;&gt;</vh></v>
<v t="pap.120703001453.952"><vh>class VBCodeBlock</vh>
<v t="pap.120703001453.953"><vh>&lt;&lt; VBCodeBlock declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.954"><vh>__init__</vh></v>
<v t="pap.120703001453.955"><vh>convertCode</vh>
<v t="pap.120703001453.956"><vh>&lt;&lt; Translate VB keywords &gt;&gt;</vh></v>
<v t="pap.120703001453.957"><vh>&lt;&lt; Add return &gt;&gt;</vh></v>
</v>
<v t="pap.120703001453.958"><vh>mapNamespaces</vh>
<v t="pap.120703001453.959"><vh>&lt;&lt; Map control names &gt;&gt;</vh></v>
<v t="pap.120703001453.960"><vh>&lt;&lt; Map sub and fn names &gt;&gt;</vh></v>
</v>
</v>
<v t="pap.120703001453.961"><vh>class VBBaseControl</vh>
<v t="pap.120703001453.962"><vh>_getPropertyList</vh></v>
<v t="pap.120703001453.963"><vh>_getControlList</vh></v>
<v t="pap.120703001453.964"><vh>_getControlsOfType</vh></v>
<v t="pap.120703001453.965"><vh>_getContainerControls</vh></v>
<v t="pap.120703001453.966"><vh>_get</vh></v>
<v t="pap.120703001453.967"><vh>_realName</vh></v>
<v t="pap.120703001453.968"><vh>_getControlEntry</vh></v>
<v t="pap.120703001453.969"><vh>_getClassSpecificControlEntries</vh></v>
<v t="pap.120703001453.970"><vh>_mapNameReference</vh></v>
<v t="pap.120703001453.971"><vh>_attributeTranslation</vh></v>
<v t="pap.120703001453.972"><vh>_processChildObjects</vh></v>
</v>
</v>
<v t="pap.120703001453.973"><vh>Collection</vh></v>
<v t="pap.120703001453.974" a="E"><vh>PythonCard object</vh>
<v t="pap.120703001453.975"><vh>vbbutton.py as subclass</vh></v>
<v t="pap.120703001453.976"><vh>vbbutton.py as proxy 1st attempt</vh></v>
</v>
<v t="pap.120703001453.977"><vh>testparse.py</vh></v>
</v>
<v t="pap.120703001453.978"><vh>Documentation</vh>
<v t="pap.120703001453.979"><vh>__init__.py</vh></v>
<v t="pap.120703001453.980" a="E"><vh>User Guide</vh>
<v t="pap.120703001453.981"><vh>@rst doc/index.htm</vh></v>
<v t="pap.120703001453.982"><vh>@rst doc/reference.htm</vh></v>
<v t="pap.120703001453.983"><vh>@file-asis doc/default.css</vh></v>
<v t="pap.120703001453.984"><vh>General Files</vh>
<v t="pap.120703001453.985"><vh>@rst doc/notimplemented.htm</vh></v>
<v t="pap.120703001453.986"><vh>@rst doc/unsupported.htm</vh></v>
<v t="pap.120703001453.987"><vh>@rst doc/about.htm</vh></v>
</v>
<v t="pap.120703001453.988" a="E"><vh>Installation</vh>
<v t="pap.120703001453.989"><vh>@rst doc/installation.htm</vh></v>
</v>
<v t="pap.120703001453.990"><vh>Usage</vh>
<v t="pap.120703001453.991"><vh>@rst doc/commandline.htm</vh></v>
<v t="pap.120703001453.992"><vh>@rst doc/gui.htm</vh>
<v t="pap.120703001453.993"><vh>Converting Entire Projects</vh></v>
<v t="pap.120703001453.994"><vh>Converting Code Fragments</vh></v>
<v t="pap.120703001453.995"><vh>Changing options</vh></v>
</v>
<v t="pap.120703001453.996"><vh>@rst doc/optionslist.htm</vh>
<v t="pap.120703001453.997"><vh>General</vh>
<v t="pap.120703001453.998"><vh>IndentCharacter</vh></v>
<v t="pap.120703001453.999"><vh>IndentAmount</vh></v>
<v t="pap.120703001453.1000"><vh>AttentionMarker</vh></v>
<v t="pap.120703001453.1001"><vh>WarnAboutUnrenderedCode</vh></v>
<v t="pap.120703001453.1002"><vh>LoadUserPlugins</vh></v>
<v t="pap.120703001453.1003"><vh>LoggingLevel</vh></v>
<v t="pap.120703001453.1004"><vh>DumpFormData</vh></v>
<v t="pap.120703001453.1005"><vh>RespectPrivateStatus</vh></v>
<v t="pap.120703001453.1006"><vh>PrivateDataPrefix</vh></v>
<v t="pap.120703001453.1007"><vh>AlwaysUseRawStringLiterals</vh></v>
<v t="pap.120703001453.1008"><vh>TryToExtractDocStrings</vh></v>
<v t="pap.120703001453.1009"><vh>ReportPartialConversion</vh></v>
<v t="pap.120703001453.1010"><vh>IncludeDebugCode</vh></v>
</v>
<v t="pap.120703001453.1011"><vh>Functions</vh>
<v t="pap.120703001453.1012"><vh>ReturnVariableName</vh></v>
<v t="pap.120703001453.1013"><vh>PreInitializeReturnVariable</vh></v>
</v>
<v t="pap.120703001453.1014"><vh>Select</vh>
<v t="pap.120703001453.1015"><vh>EvaluateVariable</vh></v>
<v t="pap.120703001453.1016"><vh>SelectVariablePrefix</vh></v>
<v t="pap.120703001453.1017"><vh>UseNumericIndex</vh></v>
</v>
<v t="pap.120703001453.1018"><vh>Labels</vh>
<v t="pap.120703001453.1019"><vh>IgnoreLabels</vh></v>
</v>
<v t="pap.120703001453.1020"><vh>With</vh>
<v t="pap.120703001453.1021"><vh>With EvaluateVariable</vh></v>
<v t="pap.120703001453.1022"><vh>WithVariablePrefix</vh></v>
<v t="pap.120703001453.1023"><vh>With UseNumericIndex</vh></v>
</v>
<v t="pap.120703001453.1024"><vh>Properties</vh>
<v t="pap.120703001453.1025"><vh>LetSetVariablePrefix</vh></v>
<v t="pap.120703001453.1026"><vh>GetVariablePrefix</vh></v>
</v>
<v t="pap.120703001453.1027"><vh>Classes</vh>
<v t="pap.120703001453.1028"><vh>UseNewStyleClasses</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1029"><vh>Simple statements</vh>
<v t="pap.120703001453.1030"><vh>@rst doc/assignment.htm</vh></v>
<v t="pap.120703001453.1031"><vh>@rst doc/set.htm</vh></v>
</v>
<v t="pap.120703001453.1032"><vh>Compound statements</vh>
<v t="pap.120703001453.1033"><vh>@rst doc/select.htm</vh></v>
<v t="pap.120703001453.1034"><vh>@rst doc/if.htm</vh></v>
<v t="pap.120703001453.1035"><vh>@rst doc/with.htm</vh></v>
<v t="pap.120703001453.1036"><vh>@rst doc/doloop.htm</vh></v>
<v t="pap.120703001453.1037"><vh>@rst doc/while.htm</vh></v>
<v t="pap.120703001453.1038"><vh>@rst doc/for.htm</vh></v>
</v>
<v t="pap.120703001453.1039" a="E"><vh>Definitions</vh>
<v t="pap.120703001453.1040"><vh>@rst doc/type.htm</vh></v>
<v t="pap.120703001453.1041"><vh>@rst doc/sub.htm</vh></v>
<v t="pap.120703001453.1042"><vh>@rst doc/function.htm</vh></v>
<v t="pap.120703001453.1043"><vh>@rst doc/dim.htm</vh></v>
<v t="pap.120703001453.1044"><vh>@rst doc/enumerations.htm</vh></v>
</v>
<v t="pap.120703001453.1045"><vh>Modules</vh>
<v t="pap.120703001453.1046"><vh>@rst doc/classmodules.htm</vh></v>
<v t="pap.120703001453.1047"><vh>@rst doc/formmodules.htm</vh></v>
<v t="pap.120703001453.1048"><vh>@rst doc/codemodules.htm</vh></v>
</v>
<v t="pap.120703001453.1049" a="E"><vh>General</vh>
<v t="pap.120703001453.1050"><vh>@rst doc/ifdirective.htm</vh></v>
<v t="pap.120703001453.1051"><vh>@rst doc/vbconstants.htm</vh></v>
<v t="pap.120703001453.996"><vh>@rst doc/optionslist.htm</vh>
<v t="pap.120703001453.997"><vh>General</vh>
<v t="pap.120703001453.998"><vh>IndentCharacter</vh></v>
<v t="pap.120703001453.999"><vh>IndentAmount</vh></v>
<v t="pap.120703001453.1000"><vh>AttentionMarker</vh></v>
<v t="pap.120703001453.1001"><vh>WarnAboutUnrenderedCode</vh></v>
<v t="pap.120703001453.1002"><vh>LoadUserPlugins</vh></v>
<v t="pap.120703001453.1003"><vh>LoggingLevel</vh></v>
<v t="pap.120703001453.1004"><vh>DumpFormData</vh></v>
<v t="pap.120703001453.1005"><vh>RespectPrivateStatus</vh></v>
<v t="pap.120703001453.1006"><vh>PrivateDataPrefix</vh></v>
<v t="pap.120703001453.1007"><vh>AlwaysUseRawStringLiterals</vh></v>
<v t="pap.120703001453.1008"><vh>TryToExtractDocStrings</vh></v>
<v t="pap.120703001453.1009"><vh>ReportPartialConversion</vh></v>
<v t="pap.120703001453.1010"><vh>IncludeDebugCode</vh></v>
</v>
<v t="pap.120703001453.1011"><vh>Functions</vh>
<v t="pap.120703001453.1012"><vh>ReturnVariableName</vh></v>
<v t="pap.120703001453.1013"><vh>PreInitializeReturnVariable</vh></v>
</v>
<v t="pap.120703001453.1014"><vh>Select</vh>
<v t="pap.120703001453.1015"><vh>EvaluateVariable</vh></v>
<v t="pap.120703001453.1016"><vh>SelectVariablePrefix</vh></v>
<v t="pap.120703001453.1017"><vh>UseNumericIndex</vh></v>
</v>
<v t="pap.120703001453.1018"><vh>Labels</vh>
<v t="pap.120703001453.1019"><vh>IgnoreLabels</vh></v>
</v>
<v t="pap.120703001453.1020"><vh>With</vh>
<v t="pap.120703001453.1021"><vh>With EvaluateVariable</vh></v>
<v t="pap.120703001453.1022"><vh>WithVariablePrefix</vh></v>
<v t="pap.120703001453.1023"><vh>With UseNumericIndex</vh></v>
</v>
<v t="pap.120703001453.1024"><vh>Properties</vh>
<v t="pap.120703001453.1025"><vh>LetSetVariablePrefix</vh></v>
<v t="pap.120703001453.1026"><vh>GetVariablePrefix</vh></v>
</v>
<v t="pap.120703001453.1027"><vh>Classes</vh>
<v t="pap.120703001453.1028"><vh>UseNewStyleClasses</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1052"><vh>VBControls</vh>
<v t="pap.120703001453.1053"><vh>@rst doc/vbcontrols/index.html</vh></v>
</v>
</v>
<v t="pap.120703001453.1054"><vh>Issues</vh>
<v t="pap.120703001453.1055"><vh>Form issues</vh></v>
<v t="pap.120703001453.1056"><vh>Code issues</vh></v>
<v t="pap.120703001453.1057"><vh>Class issues</vh></v>
<v t="pap.120703001453.1058"><vh>Module issues</vh></v>
</v>
<v t="pap.120703001453.1059"><vh>Approaches</vh>
<v t="pap.120703001453.1060"><vh>Web Search</vh></v>
<v t="pap.120703001453.1061"><vh>Piecemeal</vh></v>
<v t="pap.120703001453.1062"><vh>Full parsing</vh></v>
<v t="pap.120703001453.1063"><vh>Intermedial language</vh></v>
</v>
<v t="pap.120703001453.1064"><vh>Initial try</vh></v>
<v t="pap.120703001453.1065"><vh>Announcements</vh>
<v t="pap.120703001453.1066"><vh>0.1 Release</vh></v>
<v t="pap.120703001453.1067"><vh>0.2 Release</vh></v>
<v t="pap.120703001453.1068"><vh>Online Version</vh></v>
<v t="PAP.20040131193849"><vh>0.2.1 Release</vh></v>
</v>
<v t="PAP.20040425185045"><vh>OSCON paper</vh>
<v t="PAP.20040425185045.1" a="E"><vh>Thoughts</vh>
<v t="PAP.20040425185045.2"><vh>Hello world</vh></v>
<v t="PAP.20040425185045.3"><vh>Goodbye cruel world</vh></v>
<v t="PAP.20040425185045.4"><vh>Governing principles</vh></v>
<v t="PAP.20040613125923"><vh>Automated testing</vh></v>
</v>
</v>
<v t="pap.120703001453.1069"><vh>@file-asis CREDITS.txt</vh></v>
<v t="pap.120703001453.586"><vh>@file-asis LICENCE.txt</vh></v>
</v>
<v t="pap.120703001453.1070"><vh>Todo</vh>
<v t="pap.120703001453.1071"><vh>Parsing</vh></v>
<v t="pap.120703001453.1072"><vh>Form issues</vh></v>
<v t="pap.120703001453.1073"><vh>Linux issues</vh></v>
<v t="pap.120703001453.1074"><vh>Conversion</vh></v>
<v t="pap.120703001453.1075"><vh>VBScript</vh></v>
<v t="pap.120703001453.1076"><vh>GUI</vh></v>
<v t="pap.120703001453.1077"><vh>Configuration</vh></v>
<v t="pap.120703001453.1078"><vh>ByRef</vh>
<v t="pap.120703001453.925"><vh>Pointer implementation</vh></v>
</v>
<v t="pap.120703001453.1079"><vh>Website</vh></v>
<v t="pap.120703001453.1080"><vh>Done</vh>
<v t="pap.120703001453.1081"><vh>Parsing</vh></v>
<v t="pap.120703001453.1082"><vh>Conversion</vh></v>
<v t="pap.120703001453.1083"><vh>Forms</vh></v>
<v t="pap.120703001453.1084"><vh>Config</vh></v>
<v t="pap.120703001453.1085"><vh>Website</vh></v>
<v t="pap.120703001453.1086"><vh>GUI</vh></v>
<v t="pap.120703001453.1087"><vh>Linux</vh></v>
</v>
<v t="pap.120703001453.1088" a="E"><vh>Detailed list</vh>
<v t="pap.120703001453.1089"><vh>Rerun t1 - identify all failing blocks</vh></v>
<v t="pap.120703001453.1090"><vh>Rerun t2 - identify all failing blocks</vh></v>
<v t="pap.120703001453.1091"><vh>Add module imports</vh></v>
<v t="pap.120703001453.1092"><vh>Read class modules</vh></v>
<v t="pap.120703001453.1093"><vh>Properties Get, Let and Set</vh></v>
<v t="pap.120703001453.1094"><vh>Namespace (self) conversion</vh></v>
<v t="pap.120703001453.1095"><vh>Add enums</vh></v>
<v t="pap.120703001453.1096"><vh>Class init and delete methods</vh></v>
<v t="pap.120703001453.1097"><vh>Nothing to None</vh></v>
<v t="pap.120703001453.1098"><vh>Named arguments</vh></v>
<v t="pap.120703001453.1099"><vh>Refactor parser module</vh></v>
<v t="pap.120703001453.1100"><vh>Global data</vh></v>
<v t="pap.120703001453.1101"><vh>Private methods and data</vh></v>
<v t="pap.120703001453.1102"><vh>Bare function calls</vh></v>
<v t="pap.120703001453.1103"><vh>Add imports for globals and classes</vh></v>
<v t="pap.120703001453.1104"><vh>Use plug-in for method name conversion</vh></v>
<v t="pap.120703001453.1105"><vh>Refactor parser module</vh></v>
<v t="pap.120703001453.1106"><vh>Remove namespace conversion from vb2py</vh></v>
<v t="pap.120703001453.1107"><vh>Option groups </vh></v>
<v t="pap.120703001453.1108"><vh>Fail more gracefully when parser can't cope</vh></v>
<v t="pap.120703001453.1109"><vh>v0.2 prototype</vh></v>
<v t="pap.120703001453.1110"><vh>Linux testing</vh></v>
</v>
<v t="PAP.20040122011257"><vh>wine</vh></v>
</v>
<v t="pap.120703001453.1111"><vh>Bug Fixes</vh>
<v t="pap.120703001453.1112"><vh>805866 Print with no channel number fails during rendering </vh>
<v t="pap.120703001453.374"><vh>VBPrint</vh>
<v t="pap.120703001453.375"><vh>__init__</vh></v>
<v t="pap.120703001453.376"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.493"><vh>writeText</vh></v>
</v>
<v t="pap.120703001453.1113"><vh>809979 On Error GoTo label: </vh>
<v t="pap.120703001453.164"><vh>Blocks and lines</vh></v>
<v t="pap.120703001453.623"><vh>On Error</vh></v>
<v t="pap.120703001453.619"><vh>Multi statement lines</vh></v>
</v>
<v t="pap.120703001453.1114" a="E"><vh>810403 VB Array of String translated to just String() </vh>
<v t="pap.120703001453.725"><vh>Empty dims</vh></v>
<v t="pap.120703001453.174"><vh>Dim</vh></v>
<v t="pap.120703001453.267" a="E"><vh>VBVariable </vh>
<v t="pap.120703001453.268"><vh>&lt;&lt; VBVariable declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.269"><vh>__init__</vh></v>
<v t="pap.120703001453.270"><vh>finalizeObject</vh></v>
<v t="pap.120703001453.271"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.331"><vh>VBVariableDefinition</vh>
<v t="pap.120703001453.332"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.503"><vh>vbObjectInitialize</vh></v>
</v>
<v t="pap.120703001453.1115"><vh>810964 Input with indexed variable fails </vh>
<v t="pap.120703001453.753"><vh>Open/read/close</vh></v>
<v t="pap.120703001453.372"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.1116"><vh>810968 Close #1, #2 ' fails to parse </vh>
<v t="pap.120703001453.620"><vh>Open/Close</vh></v>
<v t="pap.120703001453.755"><vh>Bare/Multiple close</vh></v>
<v t="pap.120703001453.178"><vh>Open/Close</vh></v>
<v t="pap.120703001453.364"><vh>VBClose</vh>
<v t="pap.120703001453.365"><vh>__init__</vh></v>
<v t="pap.120703001453.366"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.1117"><vh>810401 python if statements may be missing a body </vh>
<v t="pap.120703001453.694"><vh>Inline If</vh></v>
<v t="pap.120703001453.251"><vh>containsStatements</vh></v>
</v>
<v t="pap.120703001453.1118"><vh>817747 Boolean type is not implemented </vh>
<v t="pap.120703001453.470"><vh>Boolean</vh></v>
</v>
<v t="pap.120703001453.1119"><vh>833087 Debug.Print with ';' in fails to parse </vh>
<v t="pap.120703001453.603"><vh>Debug</vh></v>
<v t="pap.120703001453.179"><vh>Calls</vh></v>
</v>
<v t="pap.120703001453.1120"><vh>825578 Help link doesn't really take you to anything useful </vh></v>
<v t="pap.120703001453.1121"><vh>825583 There are no online credits </vh></v>
<v t="pap.120703001453.1122"><vh>810969 Open "file1" For Random As #2 Len = num_of_hpixels </vh></v>
<v t="pap.120703001453.1123"><vh>817745 Ordinal not in range (128) </vh></v>
<v t="pap.120703001453.1124"><vh>825573 Installation instructions are incorrect for mxTextTools </vh></v>
<v t="pap.120703001453.1125"><vh>825575 Website has out of date installation/user instructions </vh></v>
<v t="pap.120703001453.1126"><vh>833694 Printer.Print !Var fails to parse </vh></v>
<v t="PAP.20040121234835"><vh>834019 It isn't obvious that you can't convert forms </vh></v>
<v t="PAP.20040121234835.1"><vh>852166 Sub X&lt;spc&gt;(a,b,c) fails to parse </vh>
<v t="PAP.20040131185143"><vh>Subroutine with space</vh></v>
<v t="pap.120703001453.190"><vh>Subs and functions</vh></v>
</v>
<v t="PAP.20040121234835.2"><vh>852170 Case Is &gt; 10 does not parse </vh>
<v t="PAP.20040122000733"><vh>Using Is</vh></v>
<v t="pap.120703001453.654"><vh>Select</vh></v>
<v t="pap.120703001453.187"><vh>Select case</vh></v>
<v t="pap.120703001453.405"><vh>Select</vh>
<v t="pap.120703001453.406" a="E"><vh>VBSelect</vh>
<v t="pap.120703001453.407"><vh>__init__</vh></v>
<v t="pap.120703001453.408"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.409"><vh>getSelectVariable</vh></v>
</v>
<v t="pap.120703001453.410"><vh>VBCaseBlock</vh>
<v t="pap.120703001453.411"><vh>__init__</vh></v>
</v>
<v t="pap.120703001453.412"><vh>VBCaseItem</vh>
<v t="pap.120703001453.413"><vh>renderAsCode</vh>
<v t="PAP.20040122010006"><vh>&lt;&lt; Handle single expression &gt;&gt;</vh></v>
</v>
</v>
<v t="pap.120703001453.414"><vh>VBCaseElse</vh>
<v t="pap.120703001453.415"><vh>renderAsCode</vh></v>
</v>
</v>
</v>
<v t="PAP.20040121234835.3"><vh>855015 Buttons without captions cause a crash </vh></v>
<v t="PAP.20040121234835.4"><vh>880610 Mod Operator isn't supported </vh>
<v t="pap.120703001453.607"><vh>Expressions</vh></v>
<v t="pap.120703001453.679"><vh>Expressions</vh></v>
<v t="pap.120703001453.301"><vh>VBOperation</vh>
<v t="pap.120703001453.302"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.303"><vh>finalizeObject</vh></v>
</v>
</v>
<v t="PAP.20040121234835.5"><vh>880612 Continuation character inside call </vh>
<v t="PAP.20040131185143"><vh>Subroutine with space</vh></v>
<v t="pap.120703001453.190"><vh>Subs and functions</vh></v>
</v>
<v t="PAP.20040122012758"><vh>881970 bool isn't used for Boolean even where available </vh></v>
<v t="PAP.20040122013208"><vh>881971 Partially converted code should fail when executed </vh>
<v t="pap.120703001453.447"><vh>VBParserFailure</vh></v>
</v>
</v>
<v t="pap.120703001453.1127"><vh>Project views</vh>
<v t="pap.120703001453.1128" a="E"><vh>VB Structures</vh>
<v t="pap.120703001453.1129"><vh>Select</vh>
<v t="pap.120703001453.187"><vh>Select case</vh></v>
<v t="pap.120703001453.405"><vh>Select</vh>
<v t="pap.120703001453.406" a="E"><vh>VBSelect</vh>
<v t="pap.120703001453.407"><vh>__init__</vh></v>
<v t="pap.120703001453.408"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.409"><vh>getSelectVariable</vh></v>
</v>
<v t="pap.120703001453.410"><vh>VBCaseBlock</vh>
<v t="pap.120703001453.411"><vh>__init__</vh></v>
</v>
<v t="pap.120703001453.412"><vh>VBCaseItem</vh>
<v t="pap.120703001453.413"><vh>renderAsCode</vh>
<v t="PAP.20040122010006"><vh>&lt;&lt; Handle single expression &gt;&gt;</vh></v>
</v>
</v>
<v t="pap.120703001453.414"><vh>VBCaseElse</vh>
<v t="pap.120703001453.415"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.654"><vh>Select</vh></v>
<v t="pap.120703001453.695"><vh>Select</vh>
<v t="pap.120703001453.696"><vh>Simple select</vh></v>
<v t="pap.120703001453.697"><vh>Select with numerical range</vh></v>
<v t="pap.120703001453.698"><vh>Select with multiple values</vh></v>
<v t="pap.120703001453.699"><vh>Nested Select with multiple values</vh></v>
<v t="PAP.20040122000733"><vh>Using Is</vh></v>
</v>
</v>
<v t="pap.120703001453.1130"><vh>While/Do etc</vh>
<v t="pap.120703001453.705"><vh>While and friends</vh>
<v t="pap.120703001453.706"><vh>While / Wend</vh></v>
<v t="pap.120703001453.707"><vh>Do While Loop</vh></v>
<v t="pap.120703001453.708"><vh>Do Loop</vh></v>
<v t="pap.120703001453.709"><vh>Do Loop Until</vh></v>
<v t="pap.120703001453.710"><vh>Do Until Loop</vh></v>
</v>
<v t="pap.120703001453.424"><vh>Do</vh>
<v t="pap.120703001453.425"><vh>__init__</vh></v>
<v t="pap.120703001453.426"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.421"><vh>While</vh>
<v t="pap.120703001453.422"><vh>__init__</vh></v>
<v t="pap.120703001453.423"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.186"><vh>Do/While etc</vh></v>
<v t="pap.120703001453.354"><vh>Exit Statement</vh>
<v t="pap.120703001453.355"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.1131"><vh>Functions and subs</vh>
<v t="pap.120703001453.711"><vh>Functions</vh>
<v t="pap.120703001453.712"><vh>Simple fn</vh></v>
<v t="pap.120703001453.713"><vh>Recursion</vh></v>
<v t="pap.120703001453.714"><vh>Fn arguments</vh></v>
<v t="pap.120703001453.715"><vh>Named arguments</vh></v>
<v t="PAP.20040428003630.1"><vh>Missing positional arguments</vh></v>
</v>
<v t="pap.120703001453.190"><vh>Subs and functions</vh></v>
<v t="pap.120703001453.386"><vh>VBSubroutine </vh>
<v t="pap.120703001453.387"><vh>__init__</vh></v>
<v t="pap.120703001453.388"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.389"><vh>renderParameters</vh></v>
<v t="pap.120703001453.390" a="E"><vh>resolveLocalName</vh></v>
<v t="pap.120703001453.391"><vh>renderGlobalStatement</vh></v>
<v t="pap.120703001453.392"><vh>assignParent</vh></v>
</v>
<v t="pap.120703001453.393"><vh>VBFunction</vh>
<v t="pap.120703001453.394"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.354"><vh>Exit Statement</vh>
<v t="pap.120703001453.355"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.1132"><vh>Ifs</vh>
<v t="pap.120703001453.685"><vh>Ifs</vh>
<v t="pap.120703001453.686"><vh>Single If</vh>
<v t="pap.120703001453.687"><vh>If</vh></v>
<v t="pap.120703001453.688"><vh>If with else</vh></v>
<v t="pap.120703001453.689"><vh>If with elseif</vh></v>
</v>
<v t="pap.120703001453.690"><vh>Nested If</vh>
<v t="pap.120703001453.691"><vh>If</vh></v>
<v t="pap.120703001453.692"><vh>If with else</vh></v>
<v t="pap.120703001453.693"><vh>If with elseif</vh></v>
</v>
<v t="pap.120703001453.694"><vh>Inline If</vh></v>
</v>
<v t="pap.120703001453.188"><vh>If</vh></v>
<v t="pap.120703001453.395"><vh>If</vh>
<v t="pap.120703001453.396"><vh>VBIf</vh>
<v t="pap.120703001453.397"><vh>__init__</vh></v>
<v t="pap.120703001453.398"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.399"><vh>VBElseIf</vh>
<v t="pap.120703001453.400"><vh>__init__</vh></v>
<v t="pap.120703001453.401"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.402"><vh>VBInlineIf</vh>
<v t="pap.120703001453.403"><vh>__init__</vh></v>
<v t="pap.120703001453.404"><vh>renderAsCode</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1133"><vh>Dims</vh>
<v t="pap.120703001453.174"><vh>Dim</vh></v>
<v t="pap.120703001453.721"><vh>Dims and arrays</vh>
<v t="pap.120703001453.722"><vh>Simple dims</vh></v>
<v t="pap.120703001453.723"><vh>Redims</vh></v>
<v t="pap.120703001453.724"><vh>Complex</vh></v>
<v t="pap.120703001453.725"><vh>Empty dims</vh></v>
<v t="PAP.20040427002005.4"><vh>Dims in functions</vh></v>
</v>
<v t="pap.120703001453.335"><vh>VBReDim</vh>
<v t="pap.120703001453.336"><vh>__init__</vh></v>
<v t="pap.120703001453.337"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.267"><vh>VBVariable </vh>
<v t="pap.120703001453.268"><vh>&lt;&lt; VBVariable declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.269"><vh>__init__</vh></v>
<v t="pap.120703001453.270"><vh>finalizeObject</vh></v>
<v t="pap.120703001453.271"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.331"><vh>VBVariableDefinition</vh>
<v t="pap.120703001453.332"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.1134"><vh>Fors</vh>
<v t="pap.120703001453.189"><vh>For and for each</vh></v>
<v t="pap.120703001453.700"><vh>Test For</vh>
<v t="pap.120703001453.701"><vh>Basic For</vh></v>
<v t="pap.120703001453.702"><vh>Nested For</vh></v>
<v t="pap.120703001453.703"><vh>For each</vh></v>
<v t="pap.120703001453.704"><vh>Non-integer</vh></v>
</v>
<v t="pap.120703001453.655"><vh>For statements</vh>
<v t="pap.120703001453.656"><vh>For</vh></v>
<v t="pap.120703001453.657"><vh>For each</vh></v>
</v>
<v t="pap.120703001453.416"><vh>VBFor</vh>
<v t="pap.120703001453.417"><vh>__init__</vh></v>
<v t="pap.120703001453.418"><vh>renderAsCode</vh></v>
<v t="pap.20070225000746"><vh>handleDottedName</vh></v>
</v>
<v t="pap.120703001453.419"><vh>VBForEach</vh>
<v t="pap.120703001453.420"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.1135"><vh>Assignment</vh>
<v t="pap.120703001453.338" a="E"><vh>VBAssignment</vh>
<v t="pap.120703001453.339"><vh>__init__</vh></v>
<v t="pap.120703001453.340"><vh>asString</vh></v>
<v t="pap.120703001453.341"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.342"><vh>checkForModuleGlobals</vh></v>
</v>
<v t="pap.120703001453.676"><vh>Variable assignment</vh>
<v t="pap.120703001453.677"><vh>General</vh></v>
<v t="pap.120703001453.678"><vh>General - Let</vh></v>
<v t="pap.120703001453.679"><vh>Expressions</vh></v>
<v t="pap.120703001453.680"><vh>Set</vh></v>
<v t="pap.120703001453.681"><vh>With type markers</vh></v>
<v t="pap.120703001453.682"><vh>Conditionals</vh></v>
<v t="pap.120703001453.683"><vh>LSet</vh></v>
<v t="pap.120703001453.684"><vh>RSet</vh></v>
</v>
<v t="pap.120703001453.170"><vh>Assigment</vh></v>
<v t="pap.120703001453.275"><vh>Objects</vh>
<v t="pap.120703001453.276"><vh>VBObject</vh>
<v t="pap.120703001453.277" a="E"><vh>__init__</vh></v>
<v t="pap.120703001453.278"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.279"><vh>finalizeObject</vh></v>
<v t="pap.120703001453.280"><vh>asString</vh></v>
<v t="PAP.20040429002230.1"><vh>fnPart</vh></v>
<v t="PAP.20040429002230.2"><vh>_renderPartialObject</vh></v>
</v>
<v t="pap.120703001453.281"><vh>VBLHSObject</vh></v>
<v t="pap.120703001453.282"><vh>VBAttribute</vh></v>
<v t="pap.120703001453.283"><vh>VBParameterList</vh>
<v t="pap.120703001453.284"><vh>__init__</vh></v>
<v t="pap.120703001453.285"><vh>renderAsCode</vh></v>
</v>
<v t="PAP.20040428010229" a="E"><vh>VBMissingPositional</vh>
<v t="PAP.20040428010229.1"><vh>__init__</vh></v>
<v t="PAP.20040428010229.2"><vh>renderAsCode</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1136"><vh>User Types</vh>
<v t="pap.120703001453.749"><vh>Types</vh>
<v t="pap.120703001453.750"><vh>Simple Types</vh></v>
<v t="pap.120703001453.751"><vh>Arrays of types</vh></v>
</v>
<v t="pap.120703001453.192"><vh>User Types</vh></v>
<v t="pap.120703001453.383"><vh>VBUserType</vh>
<v t="pap.120703001453.384"><vh>__init__</vh></v>
<v t="pap.120703001453.385"><vh>renderAsCode</vh></v>
</v>
</v>
<v t="pap.120703001453.1137"><vh>Open/Close</vh>
<v t="pap.120703001453.178"><vh>Open/Close</vh></v>
<v t="pap.120703001453.176"><vh>Print / Get</vh></v>
<v t="pap.120703001453.361"><vh>VBOpen</vh>
<v t="pap.120703001453.362"><vh>__init__</vh></v>
<v t="pap.120703001453.363"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.364"><vh>VBClose</vh>
<v t="pap.120703001453.365"><vh>__init__</vh></v>
<v t="pap.120703001453.366"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.370"><vh>VBInput</vh>
<v t="pap.120703001453.371"><vh>__init__</vh></v>
<v t="pap.120703001453.372"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.373"><vh>VBLineInput</vh></v>
<v t="pap.120703001453.374"><vh>VBPrint</vh>
<v t="pap.120703001453.375"><vh>__init__</vh></v>
<v t="pap.120703001453.376"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.377"><vh>VBPrintSeparator</vh>
<v t="pap.120703001453.378"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.487"><vh>VBFiles</vh>
<v t="pap.120703001453.488"><vh>__init__</vh></v>
<v t="pap.120703001453.489"><vh>openFile</vh></v>
<v t="pap.120703001453.490"><vh>closeFile</vh></v>
<v t="pap.120703001453.491"><vh>getInput</vh></v>
<v t="pap.120703001453.492"><vh>getLineInput</vh></v>
<v t="pap.120703001453.493"><vh>writeText</vh></v>
<v t="pap.120703001453.494"><vh>seekFile</vh></v>
<v t="pap.120703001453.495"><vh>getFile</vh></v>
<v t="pap.120703001453.496"><vh>getChars</vh></v>
<v t="pap.120703001453.497"><vh>getOpenChannels</vh></v>
<v t="PAP.20040131184456"><vh>EOF</vh></v>
</v>
<v t="pap.120703001453.752"><vh>Files</vh>
<v t="pap.120703001453.753"><vh>Open/read/close</vh></v>
<v t="pap.120703001453.754"><vh>Open/print/close</vh></v>
<v t="pap.120703001453.755"><vh>Bare/Multiple close</vh></v>
<v t="pap.120703001453.756"><vh>Seek</vh></v>
<v t="pap.120703001453.757"><vh>Dir</vh></v>
<v t="pap.120703001453.758"><vh>FreeFile</vh></v>
<v t="pap.120703001453.759"><vh>ChDir</vh></v>
<v t="pap.120703001453.760"><vh>Kill</vh></v>
<v t="pap.120703001453.761"><vh>MkDir</vh></v>
<v t="pap.120703001453.762"><vh>RmDir</vh></v>
<v t="pap.120703001453.763"><vh>Name</vh></v>
<v t="pap.120703001453.764"><vh>FileCopy</vh></v>
<v t="PAP.20040130001231"><vh>Input</vh></v>
<v t="PAP.20040131184456.2"><vh>EOF</vh></v>
</v>
</v>
<v t="pap.120703001453.1138"><vh>With</vh>
<v t="pap.120703001453.193"><vh>With</vh></v>
<v t="pap.120703001453.427"><vh>VBWith</vh>
<v t="pap.120703001453.428"><vh>__init__</vh></v>
<v t="pap.120703001453.429"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.765"><vh>With</vh>
<v t="pap.120703001453.766"><vh>Basic</vh></v>
<v t="pap.120703001453.767"><vh>Nesting</vh></v>
</v>
<v t="pap.120703001453.666"><vh>With</vh></v>
</v>
<v t="pap.120703001453.1139"><vh>Properties</vh>
<v t="pap.120703001453.191"><vh>Properties</vh></v>
<v t="pap.120703001453.190"><vh>Subs and functions</vh></v>
<v t="pap.120703001453.430"><vh>VBProperty</vh>
<v t="pap.120703001453.431"><vh>__init__</vh></v>
<v t="pap.120703001453.432"><vh>renderPropertyGroup</vh></v>
</v>
</v>
<v t="pap.120703001453.1140"><vh>Modules</vh>
<v t="pap.120703001453.308"><vh>Project and Module classes</vh>
<v t="pap.120703001453.309" a="E"><vh>VBProject</vh>
<v t="pap.120703001453.310"><vh>__init__</vh></v>
<v t="pap.120703001453.311"><vh>resolveLocalName</vh></v>
</v>
<v t="pap.120703001453.312" a="E"><vh>VBModule </vh>
<v t="pap.120703001453.313"><vh>__init__</vh></v>
<v t="pap.120703001453.314"><vh>renderAsCode</vh></v>
<v t="pap.120703001453.315"><vh>importStatements</vh></v>
<v t="pap.120703001453.316"><vh>renderDeclarations</vh></v>
<v t="pap.120703001453.317"><vh>renderBlocks</vh></v>
<v t="pap.120703001453.318"><vh>extractDocStrings</vh></v>
<v t="pap.120703001453.319"><vh>renderDocStrings</vh></v>
<v t="pap.120703001453.320"><vh>renderModuleHeader</vh></v>
<v t="pap.120703001453.321"><vh>resolveLocalName</vh></v>
<v t="pap.120703001453.322"><vh>enforcePrivateName</vh></v>
<v t="PAP.20040427013100"><vh>setCustomModulesAsGlobals</vh></v>
</v>
<v t="pap.120703001453.323"><vh>VBClassModule</vh>
<v t="pap.120703001453.324"><vh>__init__</vh></v>
<v t="pap.120703001453.325"><vh>renderModuleHeader</vh></v>
<v t="pap.120703001453.326"><vh>resolveLocalName</vh></v>
<v t="pap.20041206014616"><vh>assignParent</vh></v>
</v>
<v t="pap.120703001453.327"><vh>VBCodeModule</vh>
<v t="pap.120703001453.328"><vh>enforcePrivateName</vh></v>
</v>
<v t="pap.120703001453.329"><vh>VBFormModule</vh></v>
<v t="pap.20041207004405" a="E"><vh>VBCOMExternalModule</vh>
<v t="pap.20041207012020"><vh>__init__</vh></v>
<v t="pap.20041207011116"><vh>renderDeclarations</vh></v>
</v>
</v>
<v t="pap.120703001453.790"><vh>Class methods and functions</vh>
<v t="pap.120703001453.791"><vh>Simple methods</vh></v>
<v t="pap.120703001453.792"><vh>Simple functions</vh></v>
<v t="PAP.20040428020405"><vh>Missing positional arguments</vh></v>
<v t="pap.120703001453.793"><vh>Private methods</vh></v>
<v t="pap.120703001453.794"><vh>Class initialize and terminate</vh></v>
<v t="pap.120703001453.795"><vh>Class properties</vh></v>
<v t="pap.120703001453.796"><vh>Converting Me</vh></v>
</v>
<v t="pap.120703001453.797"><vh>Code module locals</vh>
<v t="pap.120703001453.798"><vh>Module locals</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1141"><vh>Configuration</vh>
<v t="pap.120703001453.550"><vh>Configuration</vh>
<v t="pap.120703001453.551" a="E" tnodeList="pap.120703001453.551,PAP.20040202230624,pap.20070203192530,PAP.20040202230624.1,PAP.20040202230624.2,PAP.20040202230624.3,PAP.20040202230624.4,PAP.20040202230624.5,PAP.20040202230624.6,PAP.20040202230624.7,PAP.20040427003436"><vh>@file vb2py.ini</vh>
<v t="PAP.20040202230624"><vh>General</vh></v>
<v t="pap.20070203192530"><vh>Style</vh></v>
<v t="PAP.20040202230624.1"><vh>Functions</vh></v>
<v t="PAP.20040202230624.2"><vh>Select</vh></v>
<v t="PAP.20040202230624.3"><vh>Labels</vh></v>
<v t="PAP.20040202230624.4"><vh>With</vh></v>
<v t="PAP.20040202230624.5"><vh>Properties</vh></v>
<v t="PAP.20040202230624.6"><vh>Classes</vh></v>
<v t="PAP.20040202230624.7"><vh>Logger</vh></v>
<v t="PAP.20040427003436"><vh>CustomIncludes</vh></v>
</v>
<v t="pap.120703001453.552"><vh>config.py</vh></v>
</v>
<v t="pap.120703001453.837"><vh>Test Configuration</vh>
<v t="pap.120703001453.838"><vh>&lt;&lt; Setup info &gt;&gt;</vh></v>
<v t="pap.120703001453.839"><vh>Config Object</vh>
<v t="pap.120703001453.840"><vh>testGetConfig</vh></v>
<v t="pap.120703001453.841"><vh>testGetConfigMissing</vh></v>
<v t="pap.120703001453.842"><vh>testSetLocalOveride</vh></v>
<v t="pap.120703001453.843"><vh>testSetLocalOverideDoesntExist</vh></v>
<v t="pap.120703001453.844"><vh>testRemoveLocalOveride</vh></v>
</v>
<v t="pap.120703001453.845" a="E"><vh>Options</vh>
<v t="pap.120703001453.846"><vh>General</vh>
<v t="pap.120703001453.847"><vh>testSpaceOrTab</vh></v>
<v t="pap.120703001453.848"><vh>testIndentAmount</vh></v>
<v t="pap.120703001453.849"><vh>testRespectPrivateStatus</vh></v>
<v t="pap.120703001453.850"><vh>testPrivateDataPrefix</vh></v>
</v>
<v t="pap.120703001453.851"><vh>Functions</vh>
<v t="pap.120703001453.852"><vh>testFunctionVariable</vh></v>
<v t="pap.120703001453.853"><vh>testPreInitVariable</vh></v>
</v>
<v t="pap.120703001453.854" a="E"><vh>Select</vh>
<v t="pap.120703001453.855"><vh>testSelectVariable</vh></v>
<v t="pap.120703001453.856"><vh>testSelectVariableIndex</vh></v>
<v t="pap.120703001453.857"><vh>testEvalVariable</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.996"><vh>@rst doc/optionslist.htm</vh>
<v t="pap.120703001453.997"><vh>General</vh>
<v t="pap.120703001453.998"><vh>IndentCharacter</vh></v>
<v t="pap.120703001453.999"><vh>IndentAmount</vh></v>
<v t="pap.120703001453.1000"><vh>AttentionMarker</vh></v>
<v t="pap.120703001453.1001"><vh>WarnAboutUnrenderedCode</vh></v>
<v t="pap.120703001453.1002"><vh>LoadUserPlugins</vh></v>
<v t="pap.120703001453.1003"><vh>LoggingLevel</vh></v>
<v t="pap.120703001453.1004"><vh>DumpFormData</vh></v>
<v t="pap.120703001453.1005"><vh>RespectPrivateStatus</vh></v>
<v t="pap.120703001453.1006"><vh>PrivateDataPrefix</vh></v>
<v t="pap.120703001453.1007"><vh>AlwaysUseRawStringLiterals</vh></v>
<v t="pap.120703001453.1008"><vh>TryToExtractDocStrings</vh></v>
<v t="pap.120703001453.1009"><vh>ReportPartialConversion</vh></v>
<v t="pap.120703001453.1010"><vh>IncludeDebugCode</vh></v>
</v>
<v t="pap.120703001453.1011"><vh>Functions</vh>
<v t="pap.120703001453.1012"><vh>ReturnVariableName</vh></v>
<v t="pap.120703001453.1013"><vh>PreInitializeReturnVariable</vh></v>
</v>
<v t="pap.120703001453.1014"><vh>Select</vh>
<v t="pap.120703001453.1015"><vh>EvaluateVariable</vh></v>
<v t="pap.120703001453.1016"><vh>SelectVariablePrefix</vh></v>
<v t="pap.120703001453.1017"><vh>UseNumericIndex</vh></v>
</v>
<v t="pap.120703001453.1018"><vh>Labels</vh>
<v t="pap.120703001453.1019"><vh>IgnoreLabels</vh></v>
</v>
<v t="pap.120703001453.1020"><vh>With</vh>
<v t="pap.120703001453.1021"><vh>With EvaluateVariable</vh></v>
<v t="pap.120703001453.1022"><vh>WithVariablePrefix</vh></v>
<v t="pap.120703001453.1023"><vh>With UseNumericIndex</vh></v>
</v>
<v t="pap.120703001453.1024"><vh>Properties</vh>
<v t="pap.120703001453.1025"><vh>LetSetVariablePrefix</vh></v>
<v t="pap.120703001453.1026"><vh>GetVariablePrefix</vh></v>
</v>
<v t="pap.120703001453.1027"><vh>Classes</vh>
<v t="pap.120703001453.1028"><vh>UseNewStyleClasses</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1142"><vh>Classes and Functions</vh>
<v t="pap.120703001453.1143"><vh>Collections</vh>
<v t="pap.120703001453.818"><vh>Test Collection</vh>
<v t="pap.120703001453.819"><vh>testAddNumeric</vh></v>
<v t="pap.120703001453.820"><vh>testAddBeforeNumeric</vh></v>
<v t="pap.120703001453.821"><vh>testAddAfterNumeric</vh></v>
<v t="pap.120703001453.822"><vh>testAddText</vh></v>
<v t="pap.120703001453.823"><vh>testAddTextandNumeric</vh></v>
<v t="pap.120703001453.824"><vh>testItemNumeric</vh></v>
<v t="pap.120703001453.825"><vh>testItemText</vh></v>
<v t="pap.120703001453.826"><vh>testRemoveNumeric</vh></v>
<v t="pap.120703001453.827"><vh>testRemoveText</vh></v>
</v>
<v t="pap.120703001453.450"><vh>Collection class</vh>
<v t="pap.120703001453.451"><vh>Hidden methods</vh>
<v t="pap.120703001453.452"><vh>__init__</vh></v>
<v t="pap.120703001453.453"><vh>__setitem__</vh></v>
<v t="pap.120703001453.454"><vh>__getitem__</vh></v>
<v t="pap.120703001453.455"><vh>__delitem__</vh></v>
<v t="pap.120703001453.456"><vh>__call__</vh></v>
<v t="pap.120703001453.457"><vh>__iter__</vh></v>
<v t="pap.120703001453.458"><vh>_getElement</vh></v>
<v t="pap.120703001453.459"><vh>_order</vh></v>
</v>
<v t="pap.120703001453.460"><vh>Add</vh></v>
<v t="pap.120703001453.461"><vh>Count</vh></v>
<v t="pap.120703001453.462"><vh>Remove</vh></v>
<v t="pap.120703001453.463"><vh>Item</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1144"><vh>Automatic Unit Tests</vh>
<v t="pap.120703001453.1145"><vh>Basic Idea</vh></v>
<v t="pap.120703001453.1146"><vh>Spike solution</vh>
<v t="pap.120703001453.1147"><vh>@file-asis ../vb2pyautotest/autotest.ini</vh></v>
<v t="pap.120703001453.1148"><vh>autotest.py</vh>
<v t="pap.120703001453.1149"><vh>class TestMaker</vh>
<v t="pap.120703001453.1150"><vh>__init__</vh></v>
<v t="pap.120703001453.1151"><vh>parseVB</vh></v>
<v t="pap.120703001453.1152"><vh>createTests</vh></v>
<v t="pap.120703001453.1153"><vh>makeTestForFunction</vh></v>
<v t="pap.120703001453.1154"><vh>extractSignatures</vh></v>
<v t="pap.120703001453.1155"><vh>createTestScript</vh></v>
<v t="pap.120703001453.1156"><vh>writeTestsToFile</vh></v>
<v t="pap.120703001453.1157"><vh>makeTestFile</vh></v>
</v>
<v t="pap.120703001453.1158"><vh>class PythonTestMaker</vh>
<v t="pap.120703001453.1159"><vh>makeTestForFunction</vh></v>
</v>
<v t="pap.120703001453.1160"><vh>class VBTestMaker</vh>
<v t="pap.120703001453.1161"><vh>makeTestForFunction</vh></v>
</v>
</v>
</v>
</v>
<v t="pap.120703001453.1162"><vh>v0.2.1 Task List</vh>
<v t="pap.120703001453.1163"><vh>New Keywords</vh>
<v t="pap.120703001453.1164" a="E"><vh>Done</vh>
<v t="pap.120703001453.1184"><vh>Array</vh>
<v t="pap.120703001453.737"><vh>Array</vh></v>
<v t="pap.120703001453.533"><vh>Array</vh></v>
</v>
<v t="pap.120703001453.1165"><vh>ChDir</vh>
<v t="pap.120703001453.759"><vh>ChDir</vh></v>
</v>
<v t="pap.120703001453.1188"><vh>Choose</vh>
<v t="pap.120703001453.742"><vh>Choose</vh></v>
<v t="pap.120703001453.538"><vh>Choose</vh></v>
</v>
<v t="pap.120703001453.1196"><vh>Environ</vh>
<v t="PAP.20040126230303"><vh>Environ</vh></v>
<v t="PAP.20040126231438"><vh>Environ</vh></v>
</v>
<v t="pap.120703001453.1197"><vh>EOF</vh>
<v t="PAP.20040131184456.2"><vh>EOF</vh></v>
<v t="PAP.20040131184456.1"><vh>EOF</vh></v>
<v t="PAP.20040131184456"><vh>EOF</vh></v>
</v>
<v t="pap.120703001453.1181"><vh>Erase</vh>
<v t="pap.120703001453.778"><vh>Erase</vh>
<v t="pap.120703001453.779"><vh>Simple test</vh></v>
</v>
<v t="pap.120703001453.521"><vh>Erase</vh></v>
<v t="pap.120703001453.476"><vh>VBArray</vh>
<v t="pap.120703001453.477"><vh>__init__</vh></v>
<v t="pap.120703001453.478"><vh>__call__</vh></v>
<v t="pap.120703001453.479"><vh>__setitem__</vh></v>
<v t="pap.120703001453.480"><vh>__getitem__</vh></v>
<v t="pap.120703001453.481"><vh>__ubound__</vh></v>
<v t="pap.120703001453.482"><vh>__lbound__</vh></v>
<v t="pap.120703001453.483"><vh>__contents__</vh></v>
<v t="pap.120703001453.484"><vh>__copyto__</vh></v>
<v t="pap.120703001453.485"><vh>createFromData</vh></v>
<v t="pap.120703001453.486"><vh>erase</vh></v>
</v>
</v>
<v t="pap.120703001453.1172"><vh>FileCopy</vh>
<v t="pap.120703001453.547"><vh>Existing python intrinsics</vh></v>
</v>
<v t="pap.120703001453.1200" a="E"><vh>FileLen</vh>
<v t="PAP.20040123193549"><vh>FileLen</vh></v>
<v t="PAP.20040123194620"><vh>FileLen</vh></v>
</v>
<v t="pap.120703001453.1201"><vh>Filter</vh>
<v t="PAP.20040130003725"><vh>Filter</vh></v>
<v t="PAP.20040130005556"><vh>Filter</vh></v>
</v>
<v t="pap.120703001453.1166"><vh>FreeFile</vh>
<v t="pap.120703001453.525"><vh>FreeFile</vh></v>
<v t="pap.120703001453.497"><vh>getOpenChannels</vh></v>
<v t="pap.120703001453.758"><vh>FreeFile</vh></v>
</v>
<v t="pap.120703001453.1186"><vh>IIf</vh>
<v t="pap.120703001453.740"><vh>IIf</vh></v>
<v t="pap.120703001453.535"><vh>IIf</vh></v>
</v>
<v t="pap.120703001453.1203"><vh>Input</vh>
<v t="PAP.20040130001231"><vh>Input</vh></v>
</v>
<v t="pap.120703001453.1204"><vh>InStrRev</vh>
<v t="PAP.20040124130157"><vh>InStrRev</vh></v>
<v t="PAP.20040125002850.3"><vh>InStrRev</vh></v>
</v>
<v t="pap.120703001453.1185"><vh>IsArray</vh>
<v t="pap.120703001453.739"><vh>IsArray</vh></v>
<v t="pap.120703001453.534"><vh>IsArray</vh></v>
</v>
<v t="pap.120703001453.1189"><vh>Join</vh>
<v t="pap.120703001453.743"><vh>Join</vh></v>
<v t="pap.120703001453.537"><vh>Join</vh></v>
</v>
<v t="pap.120703001453.1167"><vh>Kill</vh>
<v t="pap.120703001453.760"><vh>Kill</vh></v>
</v>
<v t="pap.120703001453.1170"><vh>Let</vh>
<v t="pap.120703001453.170"><vh>Assigment</vh></v>
<v t="pap.120703001453.166"><vh>Keywords</vh></v>
<v t="pap.120703001453.678"><vh>General - Let</vh></v>
</v>
<v t="pap.120703001453.1210"><vh>Lof</vh>
<v t="PAP.20040126223058"><vh>Lof</vh></v>
<v t="PAP.20040126223432"><vh>Lof</vh></v>
</v>
<v t="pap.120703001453.1182"><vh>LSet</vh>
<v t="pap.120703001453.683"><vh>LSet</vh></v>
<v t="pap.120703001453.166"><vh>Keywords</vh></v>
<v t="pap.120703001453.170"><vh>Assigment</vh></v>
<v t="pap.120703001453.165"><vh>Statements</vh></v>
<v t="pap.120703001453.262"><vh>__init__</vh></v>
<v t="pap.120703001453.343"><vh>VBSpecialAssignment</vh>
<v t="pap.120703001453.344"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.345"><vh>VBLSet</vh></v>
<v t="pap.120703001453.522"><vh>LSet</vh></v>
</v>
<v t="pap.120703001453.1191"><vh>LTrim, RTrim, Trim</vh>
<v t="pap.120703001453.728"><vh>String functions</vh></v>
<v t="pap.120703001453.528"><vh>Trim / Ltrim / Rtrim</vh></v>
</v>
<v t="pap.120703001453.1168"><vh>MkDir</vh>
<v t="pap.120703001453.761"><vh>MkDir</vh></v>
</v>
<v t="pap.120703001453.1171"><vh>Name</vh>
<v t="pap.120703001453.379"><vh>VBName</vh>
<v t="pap.120703001453.380"><vh>__init__</vh></v>
<v t="pap.120703001453.381"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.763"><vh>Name</vh></v>
<v t="pap.120703001453.625"><vh>Name statement</vh></v>
</v>
<v t="pap.120703001453.1174"><vh>Randomize</vh>
<v t="pap.120703001453.532"><vh>Rnd/Randomize</vh></v>
<v t="pap.120703001453.770"><vh>Random</vh>
<v t="pap.120703001453.771"><vh>Random tests</vh></v>
</v>
</v>
<v t="pap.120703001453.1212"><vh>Replace</vh>
<v t="PAP.20040130001614"><vh>Replace</vh></v>
<v t="PAP.20040130002515"><vh>Replace</vh></v>
</v>
<v t="pap.120703001453.1175"><vh>Reset</vh>
<v t="pap.120703001453.178"><vh>Open/Close</vh></v>
<v t="pap.120703001453.166"><vh>Keywords</vh></v>
</v>
<v t="pap.120703001453.1213"><vh>RGB</vh>
<v t="PAP.20040126231743"><vh>RGB</vh></v>
<v t="PAP.20040126232735"><vh>RGB</vh></v>
</v>
<v t="pap.120703001453.1169"><vh>RmDir</vh>
<v t="pap.120703001453.762"><vh>RmDir</vh></v>
</v>
<v t="pap.120703001453.1173"><vh>Rnd</vh>
<v t="pap.120703001453.532"><vh>Rnd/Randomize</vh></v>
<v t="pap.120703001453.225"><vh>&lt;&lt; VBNamespace declarations &gt;&gt;</vh></v>
<v t="pap.120703001453.770"><vh>Random</vh>
<v t="pap.120703001453.771"><vh>Random tests</vh></v>
</v>
</v>
<v t="pap.120703001453.1214"><vh>Round</vh>
<v t="PAP.20040129235941"><vh>Round</vh></v>
</v>
<v t="pap.120703001453.1183"><vh>RSet</vh>
<v t="pap.120703001453.684"><vh>RSet</vh></v>
<v t="pap.120703001453.166"><vh>Keywords</vh></v>
<v t="pap.120703001453.170"><vh>Assigment</vh></v>
<v t="pap.120703001453.165"><vh>Statements</vh></v>
<v t="pap.120703001453.262"><vh>__init__</vh></v>
<v t="pap.120703001453.343"><vh>VBSpecialAssignment</vh>
<v t="pap.120703001453.344"><vh>renderAsCode</vh></v>
</v>
<v t="pap.120703001453.346"><vh>VBRSet</vh></v>
<v t="pap.120703001453.523"><vh>RSet</vh></v>
</v>
<v t="pap.120703001453.1176"><vh>Settings</vh>
<v t="pap.120703001453.541"><vh>Settings Support</vh>
<v t="pap.120703001453.542"><vh>_OptionsDB</vh></v>
<v t="pap.120703001453.543"><vh>GetSetting</vh></v>
<v t="pap.120703001453.544"><vh>GetAllSettings</vh></v>
<v t="pap.120703001453.545"><vh>SaveSetting</vh></v>
<v t="pap.120703001453.546"><vh>DeleteSetting</vh></v>
</v>
<v t="pap.120703001453.774"><vh>Settings</vh>
<v t="pap.120703001453.775"><vh>Get and Set</vh></v>
<v t="pap.120703001453.776"><vh>GetAllSettings</vh></v>
<v t="pap.120703001453.777"><vh>DeleteSetting</vh></v>
</v>
<v t="pap.120703001453.1177"><vh>GetSetting</vh></v>
<v t="pap.120703001453.1178"><vh>GetAllSettings</vh></v>
<v t="pap.120703001453.1179"><vh>DeleteSetting</vh></v>
<v t="pap.120703001453.1180"><vh>SaveSetting</vh></v>
</v>
<v t="pap.120703001453.1192"><vh>Spc</vh>
<v t="pap.120703001453.527"><vh>Space / Spc / String</vh></v>
</v>
<v t="pap.120703001453.1193"><vh>Split</vh>
<v t="pap.120703001453.745"><vh>Split</vh></v>
<v t="pap.120703001453.540"><vh>Split</vh></v>
</v>
<v t="pap.120703001453.1187"><vh>StrReverse</vh>
<v t="pap.120703001453.741"><vh>StrReverse</vh></v>
<v t="pap.120703001453.536"><vh>StrReverse</vh></v>
</v>
<v t="pap.120703001453.1190"><vh>Switch</vh>
<v t="pap.120703001453.744"><vh>Switch</vh></v>
<v t="pap.120703001453.539"><vh>Switch</vh></v>
</v>
<v t="pap.120703001453.1216"><vh>Timer</vh>
<v t="PAP.20040126225358"><vh>Timer</vh></v>
<v t="PAP.20040126223803"><vh>Timer</vh></v>
<v t="pap.120703001453.225"><vh>&lt;&lt; VBNamespace declarations &gt;&gt;</vh></v>
</v>
</v>
<v t="pap.120703001453.1194"><vh>New Functions</vh></v>
</v>
</v>
<v t="pap.120703001453.1246"><vh>v0.3 Task list</vh>
<v t="pap.120703001453.1247" a="E"><vh>Controls</vh>
<v t="pap.120703001453.1248"><vh>Subclassing PythonCard classes</vh>
<v t="PAP.20040202234151"><vh>__init__.py</vh></v>
<v t="pap.120703001453.588"><vh>vbbutton.py</vh></v>
<v t="pap.120703001453.589"><vh>vbstatictext.py</vh></v>
<v t="PAP.20040801200221"><vh>vbtimer.py</vh></v>
<v t="pap.120703001453.590"><vh>vbtextfield.py</vh></v>
<v t="pap.120703001453.599"><vh>vbtextarea.py</vh></v>
<v t="pap.120703001453.598"><vh>vbcheckbox.py</vh></v>
<v t="pap.120703001453.1249" a="E"><vh>Image Controls</vh>
<v t="pap.120703001453.1250"><vh>vbbitmapcanvas.py</vh>
<v t="pap.120703001453.1251"><vh>Picture</vh></v>
</v>
<v t="pap.120703001453.101"><vh>Image</vh></v>
<v t="pap.120703001453.531"><vh>LoadPicture</vh></v>
</v>
<v t="pap.120703001453.591" a="E"><vh>vbcombobox.py</vh>
<v t="pap.120703001453.592"><vh>AddItem</vh></v>
<v t="pap.120703001453.593"><vh>getNumber</vh></v>
<v t="pap.120703001453.594"><vh>getSelectionIndex</vh></v>
<v t="pap.120703001453.595"><vh>delete</vh></v>
</v>
<v t="pap.120703001453.596"><vh>vblist.py</vh>
<v t="pap.120703001453.597"><vh>AddItem</vh></v>
</v>
<v t="PAP.20040425193458"><vh>vbimagelist.py</vh>
<v t="PAP.20040425193458.1"><vh>dummy</vh></v>
</v>
<v t="PAP.20040425193947"><vh>vbtreeview.py</vh>
<v t="PAP.20040429014548" a="E"><vh>class VBTreeView</vh>
<v t="PAP.20040429014548.1"><vh>&lt;&lt; class VBTreeView declarations &gt;&gt;</vh></v>
<v t="PAP.20040425193947.1"><vh>__init__</vh></v>
<v t="PAP.20040429014548.2"><vh>SelectedItem</vh></v>
</v>
<v t="PAP.20040427002005" a="E"><vh>class TreeNodeCollection</vh>
<v t="PAP.20040427002005.1"><vh>&lt;&lt; class TreeNodeCollection declarations &gt;&gt;</vh></v>
<v t="PAP.20040427002005.2"><vh>__init__</vh></v>
<v t="PAP.20040429014548.3"><vh>_initTree</vh></v>
<v t="PAP.20040427002005.3"><vh>Clear</vh></v>
<v t="PAP.20040428003630"><vh>Add</vh></v>
<v t="PAP.20040429020941"><vh>__iter__</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1252"><vh>Possible attribute names</vh></v>
<v t="pap.120703001453.35"><vh>&lt;&lt; Add controls to form namespace &gt;&gt;</vh></v>
<v t="pap.120703001453.504"><vh>vbGetEventArgs</vh></v>
<v t="pap.120703001453.76"><vh>controls.py</vh>
<v t="pap.120703001453.77"><vh>&lt;&lt; Events &gt;&gt;</vh>
<v t="pap.120703001453.78"><vh>class ControlEvent</vh>
<v t="pap.120703001453.79"><vh>__init__</vh></v>
<v t="pap.120703001453.80"><vh>updateMethodDefinition</vh></v>
</v>
</v>
<v t="pap.120703001453.81" a="E"><vh>class VBControl</vh>
<v t="pap.120703001453.82"><vh>_getPropertyList</vh></v>
<v t="pap.120703001453.83"><vh>_getControlList</vh></v>
<v t="pap.120703001453.84"><vh>_getControlsOfType</vh></v>
<v t="pap.120703001453.85"><vh>_getContainerControls</vh></v>
<v t="pap.120703001453.86"><vh>_get</vh></v>
<v t="pap.120703001453.87"><vh>_realName</vh></v>
<v t="pap.120703001453.88"><vh>_getControlEntry</vh></v>
<v t="pap.120703001453.89"><vh>_getClassSpecificControlEntries</vh></v>
<v t="pap.120703001453.90"><vh>_mapNameReference</vh></v>
<v t="pap.120703001453.91"><vh>_attributeTranslation</vh></v>
<v t="pap.120703001453.92"><vh>_processChildObjects</vh></v>
<v t="pap.120703001453.93"><vh>_getEvents</vh></v>
<v t="pap.120703001453.94"><vh>_getAttribute</vh></v>
<v t="PAP.20040425194848"><vh>_getPyCardColours</vh></v>
</v>
<v t="pap.120703001453.95" a="E"><vh>Main controls</vh>
<v t="pap.120703001453.96"><vh>Menu</vh></v>
<v t="pap.120703001453.97"><vh>CommandButton</vh></v>
<v t="pap.120703001453.98"><vh>ComboBox</vh></v>
<v t="pap.120703001453.99"><vh>ListBox</vh></v>
<v t="pap.120703001453.100"><vh>Label</vh></v>
<v t="pap.120703001453.101"><vh>Image</vh></v>
<v t="pap.120703001453.102"><vh>CheckBox</vh></v>
<v t="pap.120703001453.103"><vh>TextBox</vh></v>
<v t="pap.120703001453.104"><vh>Form</vh></v>
<v t="pap.120703001453.105"><vh>Font</vh></v>
<v t="PAP.20040801194015"><vh>Timer</vh></v>
<v t="pap.120703001453.106"><vh>Frame</vh></v>
<v t="pap.120703001453.107"><vh>OptionButton</vh></v>
<v t="PAP.20040425191919"><vh>TreeView</vh></v>
<v t="PAP.20040425191919.1"><vh>ImageList</vh></v>
<v t="pap.120703001453.108"><vh>VBUnknownControl</vh></v>
</v>
</v>
<v t="pap.120703001453.1253"><vh>Button</vh>
<v t="pap.120703001453.1254"><vh>Property list</vh></v>
<v t="pap.120703001453.1255"><vh>Event list</vh></v>
</v>
<v t="pap.120703001453.1256"><vh>Textbox</vh></v>
<v t="pap.120703001453.1257"><vh>Label</vh></v>
<v t="pap.120703001453.1258"><vh>Form</vh></v>
<v t="pap.120703001453.1259"><vh>Combo</vh></v>
<v t="pap.120703001453.1260"><vh>Radio</vh></v>
<v t="pap.120703001453.1261"><vh>List</vh></v>
<v t="pap.120703001453.1262"><vh>Tree</vh></v>
<v t="pap.120703001453.1263"><vh>Listview</vh></v>
<v t="pap.120703001453.1264"><vh>Frame</vh></v>
<v t="pap.120703001453.1265"><vh>Progressbar</vh></v>
<v t="pap.120703001453.1266"><vh>Picturebox</vh></v>
<v t="pap.120703001453.1267"><vh>Image</vh></v>
<v t="pap.120703001453.1268"><vh>Scrollbar</vh></v>
<v t="PAP.20040203004545"><vh>ImageList</vh></v>
<v t="PAP.20040203004545.1"><vh>System colours</vh></v>
</v>
<v t="pap.120703001453.1269" a="E"><vh>Objects</vh>
<v t="pap.120703001453.498"><vh>App</vh></v>
<v t="PAP.20040801193506.1"><vh>Screen</vh></v>
</v>
<v t="pap.120703001453.1270"><vh>Logging</vh>
<v t="pap.120703001453.1271"><vh>Refactor logging</vh></v>
<v t="pap.120703001453.1272"><vh>Improve configuration for logging</vh></v>
<v t="pap.120703001453.1273"><vh>Map Debug.Print to log</vh></v>
<v t="pap.120703001453.2"><vh>utils.py</vh>
<v t="pap.120703001453.3"><vh>Path utils</vh></v>
</v>
<v t="pap.120703001453.4"><vh>logger.py</vh></v>
</v>
<v t="pap.120703001453.1274"><vh>GUI</vh>
<v t="pap.120703001453.1275"><vh>Allow it to read single files</vh></v>
</v>
<v t="PAP.20040126221150"><vh>General</vh></v>
<v t="pap.120703001453.1276"><vh>What's new in v0.3</vh>
<v t="pap.120703001453.1277"><vh>Converter</vh></v>
<v t="pap.120703001453.1278"><vh>Bug fixes</vh></v>
<v t="pap.120703001453.1279"><vh>GUI</vh></v>
</v>
<v t="PAP.20040428001534"><vh>Docs to do</vh></v>
</v>
<v t="PAP.20040131193922"><vh>v0.4 Task list</vh>
<v t="pap.120703001453.1219" a="E"><vh>Keywords we wont support in this version</vh>
<v t="pap.120703001453.1220"><vh>Get</vh></v>
<v t="pap.120703001453.1221"><vh>Put</vh></v>
<v t="pap.120703001453.1222"><vh>Width</vh></v>
<v t="pap.120703001453.1223"><vh>AppActivate</vh></v>
<v t="pap.120703001453.1224"><vh>Beep</vh></v>
<v t="pap.120703001453.1225"><vh>Deftype</vh></v>
<v t="pap.120703001453.1226"><vh>Gosub</vh></v>
<v t="pap.120703001453.1227"><vh>Goto</vh></v>
<v t="pap.120703001453.1228"><vh>Implements</vh></v>
<v t="pap.120703001453.1229"><vh>Load</vh></v>
<v t="pap.120703001453.1230"><vh>Lock</vh></v>
<v t="pap.120703001453.1231"><vh>Option Base</vh></v>
<v t="pap.120703001453.1232"><vh>Option Compare</vh></v>
<v t="pap.120703001453.1233"><vh>Option Explicit</vh></v>
<v t="pap.120703001453.1234"><vh>Option Private</vh></v>
<v t="pap.120703001453.1235"><vh>RaiseEvent</vh></v>
<v t="pap.120703001453.1236"><vh>SavePicture</vh></v>
<v t="pap.120703001453.1237"><vh>SendKeys</vh></v>
<v t="pap.120703001453.1238"><vh>Static</vh></v>
<v t="pap.120703001453.1239"><vh>Unload</vh></v>
<v t="pap.120703001453.1240"><vh>Width</vh></v>
<v t="pap.120703001453.1241"><vh>ChDrive</vh></v>
<v t="pap.120703001453.1242"><vh>Tab</vh></v>
<v t="pap.120703001453.1243"><vh>MsgBox</vh></v>
<v t="pap.120703001453.1244"><vh>InputBox</vh></v>
<v t="pap.120703001453.1245"><vh>CVErr</vh></v>
<v t="pap.120703001453.1209"><vh>Loc</vh></v>
<v t="pap.120703001453.1205"><vh>IsDate</vh></v>
<v t="pap.120703001453.1206"><vh>IsEmpty</vh></v>
<v t="pap.120703001453.1207"><vh>IsError</vh></v>
<v t="pap.120703001453.1208"><vh>IsObject</vh></v>
<v t="pap.120703001453.1199"><vh>FileDateTime</vh></v>
<v t="pap.120703001453.1202"><vh>Format</vh></v>
<v t="pap.120703001453.1217"><vh>SetAttr</vh></v>
<v t="pap.120703001453.1218"><vh>GetAttr</vh></v>
<v t="pap.120703001453.1198"><vh>FileAttr</vh></v>
<v t="pap.120703001453.1195"><vh>CallByName</vh></v>
<v t="pap.120703001453.1211"><vh>Partition</vh></v>
<v t="pap.120703001453.1215"><vh>Shell</vh></v>
</v>
</v>
</v>
<v t="pap.120703001453.1280" a="E"><vh>Currently working on</vh>
<v t="PAP.20040426003228"><vh>Tree</vh>
<v t="PAP.20040427013100.1"><vh>customimport.py</vh></v>
<v t="PAP.20040427002644.1" a="E"><vh>comctllib.py</vh>
<v t="PAP.20040428002958"><vh>&lt;&lt; Constants &gt;&gt;</vh></v>
<v t="PAP.20040427002644.2" a="E"><vh>class Node</vh>
<v t="PAP.20040427002644.3"><vh>&lt;&lt; class Node declarations &gt;&gt;</vh></v>
<v t="PAP.20040427002644.4"><vh>__init__</vh></v>
<v t="PAP.20040429020941.1"><vh>Key</vh></v>
<v t="PAP.20040429020941.2"><vh>Expanded</vh></v>
</v>
</v>
<v t="PAP.20040427003836"><vh>testcustomimport.py</vh>
<v t="PAP.20040427003836.1" a="E"><vh>TestCustomImport</vh>
<v t="PAP.20040427003836.2"><vh>setUp</vh></v>
<v t="PAP.20040427003836.3"><vh>testComctlLib</vh></v>
</v>
</v>
<v t="PAP.20040425193947" a="E"><vh>vbtreeview.py</vh>
<v t="PAP.20040429014548" a="E"><vh>class VBTreeView</vh>
<v t="PAP.20040429014548.1"><vh>&lt;&lt; class VBTreeView declarations &gt;&gt;</vh></v>
<v t="PAP.20040425193947.1"><vh>__init__</vh></v>
<v t="PAP.20040429014548.2"><vh>SelectedItem</vh></v>
</v>
<v t="PAP.20040427002005" a="E"><vh>class TreeNodeCollection</vh>
<v t="PAP.20040427002005.1"><vh>&lt;&lt; class TreeNodeCollection declarations &gt;&gt;</vh></v>
<v t="PAP.20040427002005.2"><vh>__init__</vh></v>
<v t="PAP.20040429014548.3"><vh>_initTree</vh></v>
<v t="PAP.20040427002005.3"><vh>Clear</vh></v>
<v t="PAP.20040428003630"><vh>Add</vh></v>
<v t="PAP.20040429020941"><vh>__iter__</vh></v>
</v>
</v>
<v t="PAP.20040425191919"><vh>TreeView</vh></v>
</v>
<v t="pap.120703001453.1281"><vh>Where I stopped</vh></v>
<v t="pap.120703001453.1282"><vh>Thoughts etc</vh></v>
<v t="pap.120703001453.1283"><vh>Test report for this version</vh></v>
<v t="pap.20041206020842"><vh>Challenge</vh></v>
<v t="pap.20041206233451"><vh>Spammers</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="PAP.20040121234835"></t>
<t tx="PAP.20040121234835.1"></t>
<t tx="PAP.20040121234835.2"></t>
<t tx="PAP.20040121234835.3"></t>
<t tx="PAP.20040121234835.4"></t>
<t tx="PAP.20040121234835.5"></t>
<t tx="PAP.20040122000733">&lt;&lt; Select tests &gt;&gt;=


test_string = """
		a = %d
		Select Case a
		Case 1, 5, 10
			b = 10
		Case 2, 20 To 30, 15
			b = 20
		Case 3
			b = 30
		Case Is &gt; 2000
			b = 35
		Case -2000, -1000, Is &lt; -5000
		    b = 36
		Case Else
			b = 40
		End Select
"""

for aval, result in ((1, 10), (5, 10), (10, 10),
                     (2, 20), (20, 20), (25, 20), (30, 20), (15, 20),
                     (3, 30),
					 (2001, 35), (2002, 35), (10000, 35),
					 (-2000, 36), (-1000, 36), (-6000, 36),
                     (1000, 40), (-20, 40), (2000, 40), (-4000, 40)):
	tests.append((test_string % aval,
		 		 {"a" : aval, "b" : result}))</t>
<t tx="PAP.20040122010006">@doc
We have a single expression. Normally this is translated as an == because we are comparing the select variable to another value or an expression. However, there is a special case where the first part of the expression is "Is". In this case the expression is a compare, eg "Is &gt; 10". It turns out to be quite tricky to special case this in the grammar without a lot of duplication so we try to catch it here.

Fortunately the VB grammar doesn't allow things like "(Is &gt; 10)" so we can use a simple check!
@c

expression_text = self.expressions[0].renderAsCode()
# Now check for "Is"
if expression_text.startswith("Is "):
    # This has "Is" - replace it and use the rest of the expression
    return "%s %s" % (
                       self.getSelectVariable(),
                       expression_text[3:])
else:	
    # Standard case
    return "%s == %s" % (
                       self.getSelectVariable(),
                       expression_text)
</t>
<t tx="PAP.20040122011257">Should look at this as an option for windows calls on Linux</t>
<t tx="PAP.20040122012758"></t>
<t tx="PAP.20040122013208">When a file is partially converted but stops due to a 
conversion error then a comment is left in the code. 
However, if the user doesn't notice this and runs the 
code then it may succeed (may not be a syntax error) 
and consequently it may not be obvious that the 
program is now incorrect.

By default the conversion failure should insert a,

raise ConversionError()

at the relevant point to draw attention to the problem. 
This can be turned off in the configuration file in cases 
where this behaviour is not appropriate. </t>
<t tx="PAP.20040123192735">This is a file just
used for reading
and not for anything else!
 ...</t>
<t tx="PAP.20040123193549">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
a = FileLen("c:\\development\\python24\\lib\\site-packages\\vb2py\\test\\vbtestfile.txt")
""", { "a" : 164}),
])

</t>
<t tx="PAP.20040123194620">&lt;&lt; VBFunctions &gt;&gt;=

def FileLen(filename):
	"""Return the length of a given file"""
	return os.stat(str(filename))[6]</t>
<t tx="PAP.20040124130157">&lt;&lt; VBFunctions &gt;&gt;=

def InStrRev(text, subtext, start=None, compare=None):
	"""Return the location of one string in another starting from the end"""
	assert compare is None, "Compare modes not allowed for InStrRev"
	if start is None:
		start = len(text)
	if subtext == "":
		return len(text)
	elif start &gt; len(text):
		return 0
	else:
		return text[:start].rfind(subtext)+1
	
	
</t>
<t tx="PAP.20040124130157.1">@root sandbox\usescript.py

"""A test of using the Windows scripting host to compare the VB and converted Python code"""

import win32com.client
import re

# Get the host
vbhost = win32com.client.Dispatch("ScriptControl")
vbhost.language = "vbscript"

import vb2py.vbparser

code = """
' VB2PY-Test: y = [1,2,10,-20,50,0, "blah"]

Function Squared(x)
Squared = x^2
End Function

a = Squared(y)

"""

code1 = """
a=1
b=2
c=a+b

"""

&lt;&lt; Error Classes &gt;&gt;
&lt;&lt; Functions &gt;&gt;

testCode(code, verbose=1)			
print "Finished"	</t>
<t tx="PAP.20040124130157.2">&lt;&lt; Functions &gt;&gt;=

def runTestCode(code, host):
	"""Run some code in VB"""
	host.addcode(code)</t>
<t tx="PAP.20040124130157.3">&lt;&lt; Functions &gt;&gt;=

def findVars(code):
	"""Find all the testing variables in a sample of code"""
	finder = re.compile("^(\w+)\s*=.*$", re.MULTILINE)
	return finder.findall(code)
</t>
<t tx="PAP.20040124130157.4">&lt;&lt; Functions &gt;&gt;=

def findDirectives(code):
	"""Find testing directives"""
	finder = re.compile("^'\s*VB2PY-Test\s*:\s*(\w+)\s*=\s*(.*)$", re.MULTILINE)
	return finder.findall(code)
</t>
<t tx="PAP.20040125001102">@c

class ScriptTestError(Exception): """Base class for all script testing errors"""
class ValueNotEqual(ScriptTestError): """The VB and Python result variables didn't match"""
class VBFailed(ScriptTestError): """The VB exec of the code failed but the Python version didn't"""
class PythonFailed(ScriptTestError): """The Python exec of the code failed but the VB version didn't"""</t>
<t tx="PAP.20040125001102.1">&lt;&lt; Functions &gt;&gt;=

def testCode(code, verbose=0):
	"""Test some code using the script host"""

	test = findDirectives(code)
	if not test:
		test = [("_dummy", "[1]")]
		
	for var, value_code in test:		
		#
		values = eval(value_code)
		for value in values:
			#
			if var &lt;&gt; "_dummy":
				line = "%s = %s" % (var, repr(value).replace("'", '"'))
				if verbose:
					print "Doing '%s'" % line
				#
				vbhost.addcode(line)
				
			# Run VB	
			try:
				runTestCode(code, vbhost)
			except Exception, vberr:
				vbcode_failed = 1
			else:
				vbcode_failed = 0
			
			# Run Python
			python = vb2py.vbparser.convertVBtoPython(code)
			vars = findVars(python)
			namespace = {var : value}
			try:
				exec python in namespace
			except Exception, pythonerr:
				pythoncode_failed = 1
			else:
				pythoncode_failed = 0
				
			# Check for failures
			if vbcode_failed and not pythoncode_failed:
				raise VBFailed("VB failed on '%s' but Python didn't (%s)" % (line, vberr))
			elif pythoncode_failed and not vbcode_failed:
				raise PythonFailed("Python failed on '%s' but VB didn't (%s)" % (line, pythonerr))
			elif pythoncode_failed and vbcode_failed:
				if verbose:
					print "Both failed VB\n%s\nPython\n%s" % (vberr, pythonerr)
			else:				
				if verbose:
					print "\tVB\tPython"
				for name in vars:
					if verbose:
						print "%s\t%s\t%s" % (name, vbhost.eval(name), namespace[name])	
					else:
						if vbhost.eval(name) &lt;&gt; namespace[name]:
							raise ValueNotEqual("%s: VB(%s), Python(%s)" % (name, vbhost.eval(name), namespace[name]))
					
	if verbose:
		# Compare
		print "VB Code\n%s\n\n" % code
		print "Python Code\n%s\n\n" % python
	</t>
<t tx="PAP.20040125002850">&lt;&lt; Test functions &gt;&gt;=

def getTestMethod(vb, result):
	"""Create a test method"""
	def testMethod(self):
		local_dict = {"convertVBtoPython" : convertVBtoPython,
					  "vbfunctions" : vbfunctions}
		&lt;&lt; Parse VB &gt;&gt;
		&lt;&lt; Execute the Python code &gt;&gt;
		&lt;&lt; Work out what is expected &gt;&gt;
		&lt;&lt; Check for discrepancies &gt;&gt;
		#
		self.assert_(reason == "", "Failed: %s\n%s\n\n%s" % (reason, vb, python))
		
	return testMethod</t>
<t tx="PAP.20040125002850.1">&lt;&lt; Test functions &gt;&gt;=

def getScriptTestMethod(vb):
	"""Create a test method using the script testing method"""
	if scripttest is None:
		raise ImportError("Could not import script test - must be run on Windows with win32com support")
	def testMethod(self):
		scripttest.testCode(vb)
	return testMethod</t>
<t tx="PAP.20040125002850.2">@root test\testintrinsic3.py

from unittest import *
from testframework import *

&lt;&lt; Intrinsic tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addScriptTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="PAP.20040125002850.3">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.append("""
' VB2PY-Test: s2 = ["", "abc", "def", "g", "a", "fff", "abcdefg"]

s1 = "abcdefg"
a = InStrRev(s1, s2)
""")

tests.append("""
' VB2PY-Test: s2 = ["", "abc", "def", "g", "a", "fff"]

s1 = ""
a = InStrRev(s1, s2)
""")

tests.append("""
' VB2PY-Test: s2 = ["", "abc", "def", "g", "a", "fff", "ab"]

s1 = "ab"
a = InStrRev(s1, s2)
""")

tests.append("""
' VB2PY-Test: s2 = ["", "abcd", "def", "g", "a", "fff", "abcdefg"]

s1 = "abcdabcd"
a = InStrRev(s1, s2)
""")</t>
<t tx="PAP.20040125002850.4">@root test\scripttest.py

"""Test some code using the windows scripting host"""

try:
	import win32com.client
except ImportError:
	raise ImportError("Script test requires access to the Windows Scripting host")
	
import re

# Get the host
vbhost = win32com.client.Dispatch("ScriptControl")
vbhost.language = "vbscript"

import vb2py.vbparser

code = """
' VB2PY-Test: y = [1,2,10,-20,50,0, "blah"]

Function Squared(x)
Squared = x^2
End Function

a = Squared(y)

"""

code1 = """
a=1
b=2
c=a+b

"""

&lt;&lt; Error Classes &gt;&gt;
&lt;&lt; Functions &gt;&gt;

if __name__ == "__main__":
	testCode(code, verbose=1)			
	print "Finished"	</t>
<t tx="PAP.20040125002850.5">@c

class ScriptTestError(Exception): """Base class for all script testing errors"""
class ValueNotEqual(ScriptTestError): """The VB and Python result variables didn't match"""
class VBFailed(ScriptTestError): """The VB exec of the code failed but the Python version didn't"""
class PythonFailed(ScriptTestError): """The Python exec of the code failed but the VB version didn't"""</t>
<t tx="PAP.20040125002850.6">&lt;&lt; Functions &gt;&gt;=

def runTestCode(code, host):
	"""Run some code in VB"""
	host.addcode(code)</t>
<t tx="PAP.20040125002850.7">&lt;&lt; Functions &gt;&gt;=

def findVars(code):
	"""Find all the testing variables in a sample of code"""
	finder = re.compile("^(\w+)\s*=.*$", re.MULTILINE)
	return finder.findall(code)
</t>
<t tx="PAP.20040125002850.8">&lt;&lt; Functions &gt;&gt;=

def findDirectives(code):
	"""Find testing directives"""
	finder = re.compile("^'\s*VB2PY-Test\s*:\s*(\w+)\s*=\s*(.*)$", re.MULTILINE)
	return finder.findall(code)
</t>
<t tx="PAP.20040125002850.9">&lt;&lt; Functions &gt;&gt;=

def testCode(code, verbose=0):
	"""Test some code using the script host"""

	output = []
	test = findDirectives(code)
	if not test:
		test = [("_dummy", "[1]")]
		
	for var, value_code in test:		
		#
		values = eval(value_code)
		for value in values:
			#
			if var &lt;&gt; "_dummy":
				line = "%s = %s" % (var, repr(value).replace("'", '"'))
				if verbose:
					sendOutput("Doing '%s'" % line, output, verbose)
				#
				vbhost.addcode(line)
			else:
				line = ""
				
			# Run VB	
			try:
				runTestCode(code, vbhost)
			except Exception, vberr:
				vbcode_failed = 1
			else:
				vbcode_failed = 0
			
			# Run Python
			python = vb2py.vbparser.convertVBtoPython(code)
			vars = findVars(python)
			namespace = {var : value}
			try:
				exec python in namespace
			except Exception, pythonerr:
				pythoncode_failed = 1
			else:
				pythoncode_failed = 0
				
			# Check for failures
			if vbcode_failed and not pythoncode_failed:
				raise VBFailed("VB failed on '%s' but Python didn't (%s)\n%s" % (line, vberr, python))
			elif pythoncode_failed and not vbcode_failed:
				raise PythonFailed("Python failed on '%s' but VB didn't (%s)\n%s" % (line, pythonerr, python))
			elif pythoncode_failed and vbcode_failed:
				if verbose:
					sendOutput("Both failed\n\nVB\n%s\n\nPython\n%s\n%s" % (vberr, pythonerr, python), output, verbose)
			else:				
				if verbose:
					sendOutput("\tVB\tPython", output, verbose)
				for name in vars:
					if not name.endswith("_"):
						if verbose:
							sendOutput("%s\t%s\t%s" % (name, repr(vbhost.eval(name)), repr(namespace[name])), output, verbose)
						else:
							if vbhost.eval(name) &lt;&gt; namespace[name]:
								raise ValueNotEqual("%s: VB(%s), Python(%s)\n%s" % (
										name, repr(vbhost.eval(name)), repr(namespace[name]), python))
						
	if verbose==1:
		# Compare
		print "VB Code\n%s\n\n" % code
		print "Python Code\n%s\n\n" % python
	
	return output</t>
<t tx="PAP.20040126003633">&lt;&lt; Functions &gt;&gt;=

def sendOutput(text, lines, verbose):
	"""Send some output"""
	if verbose == 1:
		print text
	lines.append(text)
</t>
<t tx="PAP.20040126221150">Make intrinsic functions not case sensitive (eg a=instr("skks", "sksk"))
Do test for Random functions</t>
<t tx="PAP.20040126223058">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
Open "c:\\development\\python24\\lib\\site-packages\\vb2py\\test\\vbtestfile.txt" For Input As #3
a = Lof(3)
""", { "a" : 164}),
])

</t>
<t tx="PAP.20040126223432">&lt;&lt; VBFunctions &gt;&gt;=

def Lof(channel):
	"""Return the length of an open"""
	return FileLen(VBFiles.getFile(channel).name)</t>
<t tx="PAP.20040126223803">&lt;&lt; VBFunctions &gt;&gt;=

def Timer():
	"""Returns a Single representing the number of seconds elapsed since midnight"""
	ltime = time.localtime()
	h, m, s = ltime[3:6]
	return h*3600.0 + m*60.0 + s </t>
<t tx="PAP.20040126225358">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.append("""

a = int(Timer/60.0)

""")
</t>
<t tx="PAP.20040126230303">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
_a = Environ("OS")
b = Environ(1000)

For _i = 1 To 100
   If Left$(Environ(_i), 3) = "OS=" Then c = Environ(_i)
Next _i

d = Environ("kskskskss")

""", { "a" : "Windows_NT",
       "b" : "",
	   "c" : "OS=Windows_NT",
	   "d" : "",
	   }),
])

</t>
<t tx="PAP.20040126231438">&lt;&lt; VBFunctions &gt;&gt;=


def Environ(envstring):
	"""Return the String associated with an operating system environment variable
	
	envstring Optional. String expression containing the name of an environment variable. 
	number Optional. Numeric expression corresponding to the numeric order of the 
	environment string in the environment-string table. The number argument can be any 
	numeric expression, but is rounded to a whole number before it is evaluated. 


	Remarks
	
	If envstring can't be found in the environment-string table, a zero-length string ("") 
	is returned. Otherwise, Environ returns the text assigned to the specified envstring; 
	that is, the text following the equal sign (=) in the environment-string table for that environment variable.
	
	"""
	try:
		envint = int(envstring)	
	except ValueError:
		return os.environ.get(envstring, "")
	# Is an integer - need to get the envint'th value
	try:
		return "%s=%s" % (os.environ.keys()[envint], os.environ.values()[envint])
	except IndexError:
		return ""

</t>
<t tx="PAP.20040126231743">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.append("""

a = RGB(0,0,0)
b = RGB(255,255,255)
c = RGB(255,0,0)
d = RGB(0,255,0)
e = RGB(0,0,255)
f = RGB(10,20,30)
g = RGB(1000,1000,1000)

""")

tests.append("""

a = RGB(-10,-10,-10)

""")

</t>
<t tx="PAP.20040126232735">&lt;&lt; VBFunctions &gt;&gt;=

def RGB(r, g, b):
	"""Return a Long whole number representing an RGB color value
	
	The value for any argument to RGB that exceeds 255 is assumed to be 255.
	If any argument is less than zero then this results in a ValueError.
	
	"""
	rm = min(255, Int(r))
	gm = min(255, Int(g))
	bm = min(255, Int(b))
	#
	if rm &lt; 0 or gm &lt; 0 or bm &lt; 0:
		raise ValueError("RGB values must be &gt;= 0, were (%s, %s, %s)" % (r, g, b))
	#
	return ((bm*256)+gm)*256+rm
</t>
<t tx="PAP.20040129235941">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.append("""
' VB2PY-Test: r = [0, 1, 2, 3, 4, 5, 10]

a = Round(0, r)
b = Round(1, r)
c = Round(1234, r)
d = Round(1.234, r)
e = Round(1.2346, r)
f = Round(1234.5678, r)
g = Round(123.456e5, r)
h = Round(-0, r)
i = Round(-1, r)
j = Round(-1234, r)
k = Round(-1.234, r)
l = Round(-1.2345, r)
m = Round(-1234.5678, r)
n = Round(-123.456e5, r)
h = Round(.000123, r)
i = Round(.0012345, r)
j = Round(.1234, r)
k = Round(-.01234, r)
l = Round(1.2345e-5, r)
m = Round(1234.5678e-10, r)
n = Round(123.456e-15, r)

""")
</t>
<t tx="PAP.20040130001231">&lt;&lt; File tests &gt;&gt;=

# Input as a function to get a certain number of characters
tests.append((r"""
Open "%s" For Input As #3
a = Input(3, #3)
b = Input(4, #3)
Close #3

""" % vb2py.utils.relativePath("test\\testread.txt"),
{
'a' : 'Can',
'b' : ' you',
}))</t>
<t tx="PAP.20040130001614">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.append("""

a = Replace("hello", "ll", "xx")
b = Replace("hello", "", "xx")
c = Replace("hello", "hello", "xx")
d = Replace("", "ll", "xx")

e = Replace("hellohello", "ll", "xx")
f = Replace("hellohello", "", "xx")
g = Replace("hellohello", "hello", "xx")
h = Replace("", "ll", "xx")

i = Replace("hellohello", "ll", "xx", 4)
j = Replace("hellohello", "", "xx", 4)
k = Replace("hellohello", "hello", "xx", 4)
l = Replace("", "ll", "xx", 4)

i = Replace("hellohello", "ll", "xx", 1, 1)
j = Replace("hellohello", "", "xx", 1, 1)
k = Replace("hellohello", "hello", "xx", 1, 1)
l = Replace("", "ll", "xx", 1, 1)

""")
</t>
<t tx="PAP.20040130002515">&lt;&lt; VBFunctions &gt;&gt;=

def Replace(expression, find, replace, start=1, count=-1):
	"""Returns a string in which a specified substring has been replaced with another substring a specified number of times
	
	The return value of the Replace function is a string, with substitutions made, 
	that begins at the position specified by start and and concludes at the end of 
	the expression string. It is not a copy of the original string from start to finish.
	
	"""
	if find:
		return expression[:start-1] + expression[start-1:].replace(find, replace, count)
	else:
		return expression</t>
<t tx="PAP.20040130003725">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.append("""

a_ = Array("one", "two", "three", "four", "five", "six")

b = Filter(a_, "o")(0)
c = Filter(a_, "t")(0)
d = Filter(a_, "t")(1)
e = Filter(a_, "f")(0)
f = Filter(a_, "f")(1)

g = Filter(a_, "")(0)
h = Filter(a_, "one")(0)
i = Filter(a_, "notthereatall")(0)

""")

tests.append("""

a_ = Array("one", "two", "three", "four", "five", "six")

b = Filter(a_, "o", True)(0)
c = Filter(a_, "t", True)(0)
d = Filter(a_, "t", True)(1)
e = Filter(a_, "f", True)(0)
f = Filter(a_, "f", True)(1)

g = Filter(a_, "", True)(0)
h = Filter(a_, "one", True)(0)
i = Filter(a_, "notthereatall", True)(0)

""")

tests.append("""

a_ = Array("one", "two", "three", "four", "five", "six")

b = Filter(a_, "o", False)(0)
c = Filter(a_, "t", False)(0)
d = Filter(a_, "t", False)(1)
e = Filter(a_, "f", False)(0)
f = Filter(a_, "f", False)(1)


h = Filter(a_, "one", False)(0)
i = Filter(a_, "notthereatall", False)(0)

""")
</t>
<t tx="PAP.20040130005556">&lt;&lt; VBFunctions &gt;&gt;=

def Filter(sourcesarray, match, include=1):
	"""Returns a zero-based array containing subset of a string array based on a specified filter criteria"""
	if include:
		return Array(*[item for item in sourcesarray if item.find(match) &gt; -1])
	else:
		return Array(*[item for item in sourcesarray if item.find(match) == -1])</t>
<t tx="PAP.20040131003417">This node contains utilities to help in generating stub VB classes to call Python classes implemented in COM. The idea here is to be able to early bind the objects on the VB side to allow intellisense to work.</t>
<t tx="PAP.20040131003417.1">@root sandbox\makevbclass.py

"""Make a "shim" VB class to call a Python COM class

The sole purpose of the shim is to allow VB's intellisense to work. The real way to
do this is to generate a type library file - but that appears to be a bit tricky and
requires access to the MIDL compiler.

This approach is cheap and easy (cheasy?)

"""

&lt;&lt; Declarations &gt;&gt;
&lt;&lt; Error classes &gt;&gt;
&lt;&lt; Functions &gt;&gt;

if __name__ == "__main__":
	&lt;&lt; In situ-testing &gt;&gt;</t>
<t tx="PAP.20040131003417.2">@c

import inspect
import sys</t>
<t tx="PAP.20040131003417.3">@c

class MakeVBError(Exception): """Base class for all errors in this module"""</t>
<t tx="PAP.20040131003417.4">&lt;&lt; Functions &gt;&gt;=

def makeVBClass(cls, init=None):
	"""Returns the text of a VB class file wrapping the specified class
	
	If provided, then the init parameter is used as the initializer for the class
	so that you can link to the real Python object
	
	"""
	vb = [] # Build up as list and then .join it later
	#
	# Get the method names to deal with
	method_names = dir(cls)
	method_names.sort()
	#
	# Add initializer
	if init:
		vb.extend([
			"Private myObj as Object",
			"",
			"Sub Class_Initialize()",
			init,
			"End Sub",
			""
			])
	#
	# Build VB
	for name in method_names:
		if not name.startswith("_"):
			vb.extend(makeVBMethod(cls, name))
	#
	return "\n".join(vb)</t>
<t tx="PAP.20040131003417.5">&lt;&lt; Functions &gt;&gt;=
 
def makeVBClassFile(cls, filename, init=None): 
	"""Make a VB Class file froma class"""
	text = makeVBClass(cls, init)
	f = file(filename, "w")
	f.write(text)
	f.close()
		</t>
<t tx="PAP.20040131003417.6">&lt;&lt; Functions &gt;&gt;=
 
def makeVBMethod(cls, method_name): 
	"""Make some VB to support the specified method"""
	vb = []
	method = getattr(cls, method_name)
	try:
		args, vararg, varkw, defaults = inspect.getargspec(method)
	except TypeError:
		return [] # Not a method
	#
	# Get docstring, if any
	if method.__doc__:
		doc = "\n".join(["   ' %s" % line for line in method.__doc__.split("\n")])
	else:
		doc = "   ' %s method" % method_name
	#
	# Get the argument list (remember to skip argument 0, which is self)
	if not defaults:
		arg_list = args[1:]
	else:
		arg_list = args[1:-len(defaults)]
		for arg, value in zip(args[-len(defaults):], defaults):
			if value is None:
				arg_list.append("Optional %s=%s" % (arg, "Nothing"))
			else:
				arg_list.append("Optional %s=%s" % (arg, repr(value)))				
	#
	vb.extend([
			"",
			"Public Function %s(%s)" % (method_name, ", ".join(arg_list)),
			doc,
			"   %s = myObj.%s(%s)" % (method_name, method_name, ", ".join(args[1:])),
			"End Function",
			])
	#
	return vb
		</t>
<t tx="PAP.20040131003417.7">&lt;&lt; In situ-testing &gt;&gt;=

if len(sys.argv) &lt;&gt; 3:
	print "Usage: makevbclass &lt;class&gt;, filename\n"
else:
	class_name, filename = sys.argv[1:]
	imports = class_name.split(".")
	if len(imports) &gt; 1:
		exec "from %s import %s" % (".".join(imports[:-1]), imports[-1])
	cls = eval(imports[-1])
	#
	print "Using %s" % cls
	makeVBClassFile(cls, filename)
	</t>
<t tx="PAP.20040131184456">&lt;&lt; VBFiles methods &gt;&gt;=
 
def EOF(self, channelid): 
	"""Determine if the named channel is at the end of the file"""
	f = self.getFile(channelid)
	return f.tell() == vbfunctions.FileLen(f.name)</t>
<t tx="PAP.20040131184456.1">&lt;&lt; VBFunctions &gt;&gt;=
 
def EOF(channel): 
	"""Determine if we reached the end of file for the particular channel"""
	return VBFiles.EOF(channel)
	
		
</t>
<t tx="PAP.20040131184456.2">&lt;&lt; File tests &gt;&gt;=

# Input as a function to get a certain number of characters
tests.append((r"""
Open "%s" For Input As #3
While Not EOF(#3)
	Input #3, a
End While
Close #3

""" % vb2py.utils.relativePath("test\\testread.txt"),
{
'a' : 'hello',
}))</t>
<t tx="PAP.20040131185143">&lt;&lt; Parsing tests &gt;&gt;=

# 852166 Sub X&lt;spc&gt;(a,b,c) fails to parse 
tests.append("""
Sub MySub (ByVal a, ByRef y)
a=10
n=20
c="hello"
End Sub
""")

# 880612 Continuation character inside call  
tests.append("""
Sub MySub _
(ByVal a, ByRef y)
a=10
n=20
c="hello"
End Sub
""")

</t>
<t tx="PAP.20040131193849">Version 0.2.1 of vb2py has been released.

What is vb2py?
==============

vb2py is a toolkit to aid in the conversion of Visual Basic projects to Python. The aim of the conversion is to match, as close as possible, the original VB applications both in terms of code behaviour and form layout. Version 0.2.1 comprises a basic layout converter (converting to PythonCard) with a comprehensive code translation. The project roadmap (http://vb2py.sourceforge.net/roadmap.htm) shows the project's development timeline.

Converting VB to Python turns your VB projects into cross platform developments and allows full access to all Python's extensive library of modules. 


What's new in v0.2.1
====================

v0.2.1 is a bug fix and minor enhancement version. Quite a large number of Visual Basic functions and keywords were not supported in v0.2 and this is addressed to some extent by this release. The following additional functions were added for this release:

Array, ChDir, Choose, Environ, EOF, Erase, FileCopy, FileLen, Filter, FreeFile, IIf, Input, InStrRev, IsArray, Join, Kill, Let, Lof, LSet, LTrim, RTrim, Trim, MkDir, Name, Randomize, Replace, Reset, RGB, RmDir, Rnd, Round, RSet, GetAllSettings, GetSetting, SaveSetting, DeleteSetting, Spc, Split, StrReverse, Switch, Timer.

The coverage is still not 100% but if you whave an urgent need for a function it can easily be bumped up the queue!


Limitations of v0.2.1
=====================

- Form layout translation is still at the v0.1 level. (target v0.3)
- Form event mapping is still primitive (target v0.3)
- Error handling, ByRef argument passing, Iterable classes are not currently supported (target v0.4)


Getting the Software
====================

* The main website: http://vb2py.sourceforge.net
* Download this version: http://vb2py.sourceforge.net/downloads.htm
* Documentation: http://vb2py.sourceforge.net/documentation.htm
* Online trial: http://vb2py.sourceforge.net/demo.htm


Requirements
============

* Python 2.2 or greater
* PythonCard (0.7 or greater), wxWindows
* simpleparse (2.0.1a3 or greater), mxTextTools
* Visual Basic is *not* required (although it would help if you had some VB code ...)


Licence
=======

vb2py is released under the BSD licence.


Release History
===============

0.1    (July 9, 2003) - The first release from the project - a basic form layout translator
0.1.1  (August 1, 2003) - A bugfix release for 0.1
0.2    (September 8, 2003) - The first release with the full VB Parser
0.2.1  (February 1, 2004) - This release


Contributors Welcome
====================

This project would not be possible without the help and support of many people. Anyone who wants to get involved is more than welcome to participate in coding, testing, giving advice, etc. Some particular areas of interest right now are,

- testing on large VB projects
- testing on Mac
- testing out with VBScript, VBA

In the meantime I would like to thank all those who supported and contributed towards the v0.2.1 release. 

----

Paul Paterson

vb2py :: A Visual Basic to Python Conversion Toolkit
http://vb2py.sourceforge.net

</t>
<t tx="PAP.20040131193922"></t>
<t tx="PAP.20040202230624">
[General]
# Space or Tab
IndentCharacter = Space	
# Number of spaces/tabs					
IndentAmount = 4							 
# Marker to use when code needs user attention
AttentionMarker = VB2PY				
# Yes or No
WarnAboutUnrenderedCode = Yes	
# Yes or No, whether to use user plugins or not. If No, system plugins will still work
LoadUserPlugins = No
# Default logging level, 0 is nothing
LoggingLevel = 1
# Yes or No, whether to dump form data to screen - Yes seems to crash the GUI!
DumpFormData = No
# Yes or No, whether the full VB parser is used to convert code
UseFullParser = Yes
# Yes or No, whether to respect Private status of variables
RespectPrivateStatus = Yes
# Prefix to use to tag data as private (Python normally uses __ but VB convention is m_)
PrivateDataPrefix = __
# Yes or No, whether to use raw strings for all literals - very safe but not necessarily good looking!
AlwaysUseRawStringLiterals = No
# Yes or No, whether to try to automatically extract docstrings from the code
TryToExtractDocStrings = Yes
# Yes or No, whether to return a partially converted file when an error is found
ReportPartialConversion = Yes
# Exception, Warning, Comment - what to insert into code when parsing fails
InsertIntoFailedCode = Comment
# Yes or No, whether to include debug code in the converted application
IncludeDebugCode = Yes
# Which controls to use VB style PythonCard control classes for
UseVBPythonCardControls = Button, StaticText, TextField, TextArea, ComboBox, ListBox, CheckBox, BitmapCanvas, TreeView, ImageList, Timer
# None</t>
<t tx="PAP.20040202230624.1">
[Functions]
# Name of variable used in Functions
ReturnVariableName = _ret             
# Yes or No, leave at Yes unless good reasons!
PreInitializeReturnVariable = Yes   </t>
<t tx="PAP.20040202230624.2">
[Select]
# Once or EachTime, how many times to evaluate the case variable  
EvaluateVariable = Once
# Name of select variable (only used if EvaluateVariable is Once)
SelectVariablePrefix = _select
# Yes or No, use numeric index on select variable (needed if you every have nested Selects and EvaluateVariable = Once)
UseNumericIndex = Yes
</t>
<t tx="PAP.20040202230624.3">
[Labels]
# Yes or No, ignore labels completely
IgnoreLabels = Yes
</t>
<t tx="PAP.20040202230624.4">
[With]
# Once or EachTime, how many times to evaluate the with variable  
EvaluateVariable = Once
# Name of with variable (only used if EvaluateVariable is Once)
WithVariablePrefix = _with
# Yes or No, use numeric index on with variable (needed if you every have nested Withs and EvaluateVariable = Once)
UseNumericIndex = Yes
</t>
<t tx="PAP.20040202230624.5">
[Properties]
# Prefix to add to property Let/Set function name
LetSetVariablePrefix = set
# Prefix to add to property Get function name
GetVariablePrefix = get
</t>
<t tx="PAP.20040202230624.6">
[Classes]
# Yes or No, whether to use new style classes for all classes
UseNewStyleClasses = Yes
</t>
<t tx="PAP.20040202230624.7">
[Logging]
# Which loggers are allowed to report
Allowed = VB*, vb2PyApp, PlugInAttributeNames, PythonCardControls
# Which loggers are not allowed to report
NotAllowed = VBParser</t>
<t tx="PAP.20040202234151">@root __init__.py</t>
<t tx="PAP.20040203004545"></t>
<t tx="PAP.20040203004545.1">If colour &amp; 0x80000000 then it is a system colour</t>
<t tx="PAP.20040425185045"></t>
<t tx="PAP.20040425185045.1"></t>
<t tx="PAP.20040425185045.2">a=1

is the hello world of vb2py

now add

dim a as string
a=1

and it gets interesting - how do we cope with this?

setlocal('a', 1) - knows about types and coercion ... horrible to look at

a=1 - ignores coercion, hides bugs

assert issubtype(1, str)
a=1

.. yeah right - but maybe as an option during testing


only sane approach is to automatically develop test scripts</t>
<t tx="PAP.20040425185045.3">Pathalogical examples of error trapping


on error goto x
doit()
do1()
do2()
here:
do3()
exit sub

x:
if a: resume next
if b: resume here
err.raise


</t>
<t tx="PAP.20040425185045.4">0. is feasible to code
1. Works (subject to definition of works!)
2. Readable
3. Maintainable
4. Works like VB
5. Pythonic

These are the tie breakers</t>
<t tx="PAP.20040425191919">&lt;&lt; Controls &gt;&gt;=

class TreeView(VBControl):
	pycard_name = "TreeView"

	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = (evtClick, evtChange) + evtFocusAll + evtDragAll + evtMouseAllLC + evtKeyAll
	
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		d = { 
            "size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel),
        }
        return d            
				
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
				
	
</t>
<t tx="PAP.20040425191919.1">&lt;&lt; Controls &gt;&gt;=

class ImageList(VBControl):
	pycard_name = "ImageList"
	
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return { }
				
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
				
	</t>
<t tx="PAP.20040425193458">@root vbimagelist.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBImageList")

from PythonCard.components import statictext
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBImageList(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
			"ListImages" : "items",
    } 

	_name_to_method_translations = {
			"ListCount" : ("getNumber", None),
			"ListIndex" : ("getSelectionIndex", None),
	}
	
    _indexed_translations = { 
    } 
    
	_method_translations = {			
	}
	
    _proxy_for = statictext.StaticText # Not a PythonCard object at all but this at least works!

	&lt;&lt; VBImageList methods &gt;&gt;   

log.debug("Registering VBImageList as '%s'" % sys.modules[__name__].VBImageList)
Register(VBImageList)

</t>
<t tx="PAP.20040425193458.1">&lt;&lt; VBImageList methods &gt;&gt;=

pass</t>
<t tx="PAP.20040425193947">@root vbtreeview.py

from wx import TreeItemData
from wxPython import wx, stc
import vb2py.custom.comctllib

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBTreeView")

from PythonCard.components import tree
from wxPython import wx
import sys
from PythonCard import event, registry, widget
from vb2py.vbclasses import Collection




&lt;&lt; Classes &gt;&gt;

log.debug("Registering VBTreeView as '%s'" % sys.modules[__name__].VBTreeView)
Register(VBTreeView)
</t>
<t tx="PAP.20040425193947.1">&lt;&lt; class VBTreeView methods &gt;&gt;=

def __init__(self, *args, **kw):
    """Initialize the tree view"""
    super(VBTreeView, self).__init__(*args, **kw)
    self.Nodes = TreeNodeCollection(self)
    
</t>
<t tx="PAP.20040425194848">&lt;&lt; class VBControl methods &gt;&gt;=
 
def _getPyCardColours(cls, vbcolour): 
        """Convert a VB colour to a PythonCard colour
        
        There are a number of issues here. The main one is that VB often
        uses the System colours which are not valid colour references.
        
        """
        log.debug("Converting colour '%s'" % str(vbcolour))
        if isinstance(vbcolour, int):
            if vbcolour &lt; 0:
                log.debug("Looks like a system colour - assume grey")
                return "Grey"
            else:
                log.debug("Looks like a normal colour")
                return vbcolour
        else:
            return vbcolour

_getPyCardColours = classmethod(_getPyCardColours)</t>
<t tx="PAP.20040426003228"></t>
<t tx="PAP.20040427002005">&lt;&lt; Classes &gt;&gt;= 
 
class TreeNodeCollection(Collection): 
    """Represents a collection of nodes in a tree view""" 
     
    &lt;&lt; class TreeNodeCollection declarations &gt;&gt; 
    &lt;&lt; class TreeNodeCollection methods &gt;&gt;</t>
<t tx="PAP.20040427002005.1">@c
pass</t>
<t tx="PAP.20040427002005.2">&lt;&lt; class TreeNodeCollection methods &gt;&gt;= 
 
def __init__(self, parent): 
    """Initialise the TreeNodeCollection instance"""
    super(TreeNodeCollection, self).__init__()
    self._parent = parent
    self._nodes = {}
    self._initTree()
</t>
<t tx="PAP.20040427002005.3">&lt;&lt; class TreeNodeCollection methods &gt;&gt;= 
 
def Clear(self): 
    """Clear all the nodes"""
    self._parent.DeleteAllItems()
    self._initTree()    </t>
<t tx="PAP.20040427002005.4">&lt;&lt; Dim tests &gt;&gt;=

# Sub
tests.append(("""

Sub _f()
Dim aa(1)
aa(1) = 10
End Sub


""", {}
))

# Function
tests.append(("""
Function _f()
Dim aa(1)
aa(1) = 10
_f = aa(1)
End Function

a = _f

""", {"a" : 10, }
))
</t>
<t tx="PAP.20040427002644"></t>
<t tx="PAP.20040427002644.1">@root custom\comctllib.py 

"""Classes to mimic the ComctlLib library from Microsoft"""

 
&lt;&lt; Constants &gt;&gt;
&lt;&lt; Classes &gt;&gt; 
 
if __name__ == "__main__": 
    pass</t>
<t tx="PAP.20040427002644.2">&lt;&lt; Classes &gt;&gt;= 
 
class Node(object): 
    """A node in a tree view""" 
     
    &lt;&lt; class Node declarations &gt;&gt; 
    &lt;&lt; class Node methods &gt;&gt;</t>
<t tx="PAP.20040427002644.3">@c
pass</t>
<t tx="PAP.20040427002644.4">&lt;&lt; class Node methods &gt;&gt;= 
 
def __init__(self, id=None, parent=None): 
    """Initialise the Node instance"""
    self._id = id
    self._parent = parent</t>
<t tx="PAP.20040427003436">
[CustomIncludes]
# This is where you put modules that need to be included - all these
# modules should be placed in the custom folder. 
# eg, ComctlLib=comctllib
</t>
<t tx="PAP.20040427003836">@root test\testcustomimport.py 
 
import unittest 
import vb2py.vbparser

&lt;&lt; Test Classes &gt;&gt; 
 
if __name__ == "__main__": 
        unittest.main()</t>
<t tx="PAP.20040427003836.1">&lt;&lt; Test Classes &gt;&gt;= 
 
class TestCustomImport(unittest.TestCase): 
    """Tests for the CustomImport class""" 
    &lt;&lt; CustomImport Tests &gt;&gt;</t>
<t tx="PAP.20040427003836.2">&lt;&lt; CustomImport Tests &gt;&gt;= 
 
def setUp(self): 
    """Create the test fixture"""
    
</t>
<t tx="PAP.20040427003836.3">&lt;&lt; CustomImport Tests &gt;&gt;= 
 
def testComctlLib(self): 
    """testComctlLib: should be able to import ComctlLib"""
    proj = vb2py.vbparser.VBProject()
    module = vb2py.vbparser.VBCodeModule(modulename="test")
    #
    module.parent = proj        
    #
    vb = """
    ' VB2PY-GlobalAdd: CustomIncludes.ComctlLib = comctllib
    Public Function doit()
        Dim x As Node
        y = Node()
    End Function
    """
    #
    c = vb2py.vbparser.parseVB(vb, container=module)
    #
    py = module.renderAsCode()
    #
    self.assertNotEqual(py.find("x = vb2py.custom.comctllib.Node()"), -1,
                        "Failed on X:\n%s\n\n%s\n" % (vb, py))   
    self.assertNotEqual(py.find("y = vb2py.custom.comctllib.Node()"), -1,
                        "Failed on Y:\n%s\n\n%s\n" % (vb, py))
    
    

</t>
<t tx="PAP.20040427013100">&lt;&lt; VBModule methods &gt;&gt;=
 
def setCustomModulesAsGlobals(self): 
    """Set all the custom import modules as global modules

        If the user has specified custom imports (eg Comctllib) then
        we need to import these as globals in the project. We force
        them into the project (if there is one) global object
        table so that they can be resolved at run time.

        """
    #
    # Get global object table if there is one
    try:
        global_objects = self.getParentProperty("global_objects")
    except NestingError:
        return
    #
    log.info("Processing custom modules now")
    custom_modules = Config.getItemNames("CustomIncludes")
    #
    # Do for all custom modules
    for module_id in custom_modules:
        #
        # Import this module
        module_name = Config["CustomIncludes", module_id]
        log.info("Processing custom module %s (%s)" % (module_id, module_name))
        module = __import__("vb2py.custom.%s" % module_name, globals(), locals(), ["custom"])
        #
        # Get a container to store the values in
        vbmodule = VBCodeModule(modulename="vb2py.custom.%s" % module_name)
        #
        # Now set all items in the module to be global (if they don't seem to be
        # hidden)
        for item_name in dir(module):
            if not item_name.startswith("_"):
                log.info("Registered new custom global '%s'" % item_name)
                global_objects[item_name] = vbmodule
                
</t>
<t tx="PAP.20040427013100.1">@root sandbox\customimport.py

from vb2py.vbparser import *

p = VBProject()

m1 = VBCodeModule()
m1.parent = p

m2 = VBCodeModule()
m2.parent = p

c1 = parseVB("Sub a()\nb = This\nc=Node()\nDim d as Node\nEnd Sub", container=m1)
c2 = parseVB("' VB2PY-GlobalAdd: CustomIncludes.Comctllib = comctllib\nPublic Sub This()\nEnd Sub", container=m2)

print m1.renderAsCode()
print m2.renderAsCode()</t>
<t tx="PAP.20040427015439">@root custom\__init__.py

pass</t>
<t tx="PAP.20040428001534">GlobalAdd
CustomImport
TreeView
ListView
ImageList</t>
<t tx="PAP.20040428002958">@c

tvwChild = 4
tvwFirst = 0
tvwLast = 1
tvwManual = 1 
tvwNext = 2
tvwPictureText = 1
tvwPlusMinusText = 2 
tvwPlusPictureText = 3 
tvwPrevious = 3
tvwRootLines = 1
tvwTextOnly = 0
tvwTreeLines = 0
tvwTreelinesPictureText = 5
tvwTreelinesPlusMinusPictureText = 7
tvwTreelinesPlusMinusText = 6
tvwTreelinesText = 4</t>
<t tx="PAP.20040428003630">&lt;&lt; class TreeNodeCollection methods &gt;&gt;= 
 
def Add(self, Relative=None, Relationship=vb2py.custom.comctllib.tvwChild, 
        Key="", Text="", Image=None, SelectedImage=None): 
    """Add a node to the tree"""
    if Relative is None:
        id = self._nodes["&lt;vbtreeroot&gt;"]
    elif Relationship == vb2py.custom.comctllib.tvwChild:
        id = self._nodes[Relative]
    else:
        raise NotImplementedError("Tree Add not implemented for relationships other than tvwChild")
    #
    self._nodes[Key] = self._parent.AppendItem(id, Text)
    self._parent.SetPyData(self._nodes[Key], Key)   
    self._parent.SetItemHasChildren(id, True)


</t>
<t tx="PAP.20040428003630.1">&lt;&lt; Fn tests &gt;&gt;=

# Function with named arguments
tests.append(("""
Function _sum(Optional x=1, Optional y=2, Optional z=3)
	_sum = x + y + z
End Function
a = _sum(, , 30)
b = _sum(10,,30)
""", {"a" : 33, "b" : 42,}))
</t>
<t tx="PAP.20040428010229">&lt;&lt; Classes &gt;&gt;=

class VBMissingPositional(VBCodeBlock):
	"""A positional argument that is missing from the argument list"""
	
	&lt;&lt; VBMissingPositional methods &gt;&gt;
</t>
<t tx="PAP.20040428010229.1">&lt;&lt; VBMissingPositional methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the object"""
	super(VBMissingPositional, self).__init__(scope)
	
</t>
<t tx="PAP.20040428010229.2">&lt;&lt; VBMissingPositional methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this attribute"""
    #
    # The parameter_index_position attribute will be set
    # by our parent. We also need to look for the function name
    # which depends on our context
    try:
        function_name = self.findParentOfClass(VBObject).fnPart()
    except NestingError:
        try:
            function_name = self.getParentProperty("object").fnPart()
        except NestingError:
            raise UnresolvableName("Could not locate function name when supplying missing argument")
    #
    return "VBGetMissingArgument(%s, %d)" % (
                     function_name,
                     self.parameter_index_position)</t>
<t tx="PAP.20040428015634">&lt;&lt; VBFunctions &gt;&gt;=
 
def VBGetMissingArgument(fn, argument_index): 
    """Return the default value for a particular argument of a function"""
    try:
        args, varargs, varkw, defaults = inspect.getargspec(fn)
    except Exception, err:
        raise VB2PYCodeError("Unable to determine default argument for arg %d of %s: %s" % (
                    argument_index, fn, err))
    #
    # Find correct argument default
    offset = argument_index - len(args)
    #
    # If this is an instancemethod then we must skip the 'self' argument
    if isinstance(fn, new.instancemethod):
        offset += 1
    try:
        return defaults[offset]
    except IndexError:
        raise VB2PYCodeError("Default argument for arg %d of %s doesn't seem to exist" % (
                    argument_index, fn))
        
     
    
</t>
<t tx="PAP.20040428020405">&lt;&lt; ClassMethod tests &gt;&gt;=

#
# Simple public function
tests.append((
        VBClassModule(),
        """
        Public a1, a2, a3, a4
        Public Function add(Optional X=10, Optional Y=20, Optional Z=30)
            add = X + Y + Z
        End Function
        
        Public Sub set()
            a1 = add(1,2,3)
            a2 = add(,2,3)
            a3 = add(,,3)
            a4 = add()
        End Sub
        
        """,
        ("A = MyClass()\n",
         "A.set()\n",
         "assert A.a1 == 6\n",
         "assert A.a2 == 15\n",
         "assert A.a3 == 33\n",
         "assert A.a4 == 60\n",
         )
))         </t>
<t tx="PAP.20040429002230">&lt;&lt; VBNamespace methods &gt;&gt;=
 
def filterListByClass(self, sequence, cls): 
    """Return all elements of sequence that are an instance of the given class"""
    return [item for item in sequence if isinstance(item, cls)]</t>
<t tx="PAP.20040429002230.1">&lt;&lt; VBObject methods &gt;&gt;=
 
def fnPart(self): 
    """Return the function part of this object (ie without any parameters"""
    return self._renderPartialObject(indent=0, modifier=VBAttribute)</t>
<t tx="PAP.20040429002230.2">&lt;&lt; VBObject methods &gt;&gt;=
 
def _renderPartialObject(self, indent=0, modifier=None): 
    """Render this object but only including modifiers of a certain class"""
    #
    # Check for implicit object and if we are one then find the nearest "With"
    if self.implicit_object:
        implicit_name = "%s." % self.getParentProperty("with_object")
    else:
        implicit_name = ""
    #
    # For the LHS objects we need to look for the local name for Function return arguments
    if self.am_on_lhs:
        obj_name = self.getLocalNameFor(self.primary.element.text)
    else:
        obj_name = self.primary.element.text
    #
    resolved_name = self.resolveName(obj_name)
    #
    # Check if this looks like a function
    # TODO: This isn't very rigorous
    if not self.modifiers:
        if self.isAFunction(obj_name):
            resolved_name += "()"
    #
    if modifier is None:
        valid_modifiers = self.modifiers
    else:
        valid_modifiers = self.filterListByClass(self.modifiers, modifier)
    #
    return "%s%s%s" % (implicit_name,
                       resolved_name,
                       "".join([item.renderAsCode() for item in valid_modifiers]))    
</t>
<t tx="PAP.20040429014548">&lt;&lt; Classes &gt;&gt;= 
 
class VBTreeView(VBWidget): 
     
    &lt;&lt; class VBTreeView declarations &gt;&gt; 
    &lt;&lt; class VBTreeView methods &gt;&gt;</t>
<t tx="PAP.20040429014548.1">@c
__metaclass__ = VBWrapped 

_translations = { 
        "ListImages" : "items",
        "Enabled" : "enabled", 
        "Visible" : "visible", 
} 

_name_to_method_translations = {
        "ListCount" : ("getNumber", None),
		"ListIndex" : ("getSelectionIndex", None),
}

_indexed_translations = { 
        "Left" : ("position", 0), 
        "Top" : ("position", 1), 
        "Width" : ("size", 0), 
        "Height" : ("size", 1), 
} 

_method_translations = {			
}

_proxy_for = tree.Tree

 </t>
<t tx="PAP.20040429014548.2">&lt;&lt; class VBTreeView methods &gt;&gt;= 
 
def _getSelectedItem(self): 
    """Getting the selected item"""
    return vb2py.custom.comctllib.Node(self.GetSelection(), self)

def _setSelectedItem(self, item): 
    """Setting the selected item"""
    self.SelectItem(item._id)

SelectedItem = property(fget=_getSelectedItem,
                        fset=_setSelectedItem)</t>
<t tx="PAP.20040429014548.3">&lt;&lt; class TreeNodeCollection methods &gt;&gt;= 
 
def _initTree(self): 
    """Initialize the tree"""
    self._nodes["&lt;vbtreeroot&gt;"] = self._parent.AddRoot("Root", data=TreeItemData("&lt;vbtreeroot&gt;"))    
    self._parent.SetPyData(self._nodes["&lt;vbtreeroot&gt;"], "&lt;vbtreeroot&gt;")        
    </t>
<t tx="PAP.20040429020941">&lt;&lt; class TreeNodeCollection methods &gt;&gt;= 
 
def __iter__(self): 
    """Return an iterator over the nodes"""
    for node in self._nodes.values():
        yield vb2py.custom.comctllib.Node(node, self._parent)</t>
<t tx="PAP.20040429020941.1">&lt;&lt; class Node methods &gt;&gt;= 
 
def _getKey(self): 
    """Get the key"""
    return self._parent.GetPyData(self._id)
    
def _setKey(self, key): 
    """Set the key"""
    self._parent.SetPyData(self._id, key)
    
Key = property(fget=_getKey,
               fset=_setKey)    
    </t>
<t tx="PAP.20040429020941.2">&lt;&lt; class Node methods &gt;&gt;= 
 
def _getExpanded(self): 
    """Get the expanded state"""
    return self._parent.IsExpanded(self._id)
    
def _setExpanded(self, expanded):
    """Set the expanded state"""
    if expanded:
        self._parent.Expand(self._id)
    else:
        self._parent.Collapse(self._id)
            
Expanded = property(fget=_getExpanded,
                    fset=_setExpanded)        </t>
<t tx="PAP.20040430190921">From CLP:

import sys

class Closure:
    def __init__(self):
        self.__dict__ = sys._getframe().f_back.f_locals

def getFunc():
    counter = 0
    c = Closure()
    def count():
        c.counter += 1
        print c.counter
    return count

c = getFunc()
c()
c()
c()

-- Gustavo Niemeyer http://niemeyer.net </t>
<t tx="PAP.20040613125923">Stress this as an important way to go</t>
<t tx="PAP.20040801174621">@root sandbox\remoteservice.py

"""Test of using vb2py as a remote service"""

import urllib
import re

SERVICE = "http://vb2py.sourceforge.net/cgi-bin/remote.py"
EXTRACT = re.compile(r"\&lt;(\S+)\&gt;(.*)\&lt;/\1\&gt;", re.DOTALL)

code = """
Select Case a
  Case 10
    b=1
  Case 10,20
    b=2
  Case 30 To 40
    b=3
  Case Else
    b=4
End Select

"""

result = urllib.urlopen("%s?code=%s" % (SERVICE, urllib.quote(code)))
text = result.read()
parts = EXTRACT.match(text)

if parts:
    print "%s\n%s" % parts.groups()
else:
    print "Unable to decifer result! (%s)" % text
</t>
<t tx="PAP.20040801193506">&lt;&lt; Utility functions &gt;&gt;=

def getAST(vbtext, starttoken="line", returnpartial=None):
	"""Parse some VB to produce an AST"""
	
	if returnpartial is None:
		returnpartial = Config["General", "ReportPartialConversion"] == "Yes"
		
	nodes = buildParseTree(vbtext, starttoken, 0, returnpartial, returnast=1)
	
	return nodes
	




</t>
<t tx="PAP.20040801193506.1">"""Manipulates forms according to their placement on the screen and controls the mouse pointer.

It has the following methods

- ActiveControl
- ActiveForm
- FontCount
- Fonts
- Height
- MouseIcon
- MousePointer
- TwipsPerPixelX
- TwipsPerPixelY
- Width

"""

</t>
<t tx="PAP.20040801194015">&lt;&lt; Controls &gt;&gt;=

class Timer(VBControl):
	"""A timer"""
    
    pycard_name = "Timer"</t>
<t tx="PAP.20040801200221">@root vbtimer.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBTimer")

from PythonCard.components import statictext
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBTimer(VBWidget): 
    __metaclass__ = VBWrapped 
    
	_name_to_method_translations = {
			"Enabled" : ("_getEnabled", "_setEnabled"),
	}

    def _setEnabled(self, value):
        """Setting enabled state"""
        # Call the event handler
        getattr(self.GetGrandParent(), "%s_Timer" % self.name)()
    
    def _getEnabled(self):
        """Getting enabled state"""
        print "Inside getenabled"
        return True
        
    _proxy_for = statictext.StaticText

log.debug("Registering VBTimer as '%s'" % sys.modules[__name__].VBTimer)
Register(VBTimer)</t>
<t tx="PAP.20040811222221">&lt;&lt; VBWrapped methods &gt;&gt;=

def createAttributeSet(attr_name):
	def set(obj, value):
		getattr(obj, obj._name_to_method_translations[attr_name][1])(value)
	return set
		
createAttributeSet = staticmethod(createAttributeSet)</t>
<t tx="PAP.20040824000823">@root plugins/recordset.py

"""Plug-in to convert recordset notation to standard notation

eg, 

RecordSet!FieldName 

Translates to,

RecordSet.Fields("FieldName").Value

This plugin scans code before parsing and replaces the short-form notation
with the full notation, which can be converted automatically.

Contributed by Alexandr Zamaraev
24 Aug 2004

"""


try:
	import vb2py.extensions as extensions
except ImportError:
	import extensions

class RecordSetShort(extensions.SystemPluginREPlugin):
  """Convert RecordSet!FieldName to RecordSet.Fields("FieldName").Value"""

  #name = 'RecordSetShort'
  __enabled = 1
  
  pre_process_patterns = (
    (r'(?P&lt;RS&gt;[\w\d_]+)!(?P&lt;FN&gt;[\w\d_]+)', r'%(RS)s.Fields("%(FN)s").Value'),
  )    

</t>
<t tx="PAP.20040824001655">&lt;&lt; Parsing Tests &gt;&gt;=

# Recordset notation
tests.extend([
"RS!diskID = DriveID",
"RS!diskID = DriveID+10",
'RS!diskID = "DriveID"',
])
</t>
<t tx="PAP.20040824001912">This code generate "Parsing error: 0"

Private Sub AddFile(ByRef RS As DAO.Recordset, ByVal
DriveID As Long, ByRef FI As Scripting.File, Optional
ByVal parentID As Long = 0)
RS.AddNew
RS!diskID = DriveID
RS!parentID = parentID
RS!name = FI.name
RS!size = FI.size
RS!DateOf = FI.DateLastModified
RS!IsFolder = False
RS.Update
End Sub


Date: 2004-08-22 23:25
Sender: shura_zam
Logged In: YES 
user_id=980085

I create simple plugin for parse Dao short sintaxis.</t>
<t tx="pap.120703001453">
</t>
<t tx="pap.120703001453.1">@root __init__.py

pass</t>
<t tx="pap.120703001453.2">@root utils.py

import os
import sys

&lt;&lt; Utilities &gt;&gt;</t>
<t tx="pap.120703001453.3">&lt;&lt; Utilities &gt;&gt;=

def rootPath():
	"""Return the root path"""
	return os.path.join(os.path.abspath(__file__).split("vb2py")[0], "vb2py")


def relativePath(path):
    """Return the path to a file"""
    return os.path.join(rootPath(), path)</t>
<t tx="pap.120703001453.4">@root logger.py

"""Logging infrastructure"""

import logging
import fnmatch
from config import VB2PYConfig
Config = VB2PYConfig()

class VB2PYLogger(logging.StreamHandler):
	"""Logger which can do some interesting filtering"""
    
    allowed = [] # Loggers which can report
    blocked = [] # Loggers which can't report
    
    def filter(self, record):
        """Filter logging events"""
		for allow in self.allowed:
			if fnmatch.fnmatch(record.name, allow) and not record.name in self.blocked:
				return 1
     
	def initConfiguration(self, conf):
		"""Initialize the configuration"""
		self.allowed = self._makeList(conf["Logging", "Allowed"])
		self.blocked = self._makeList(conf["Logging", "NotAllowed"])
				
	def _makeList(self, text):
		"""Make a list from a comma separted list of names"""
		names = text.split(",")
		return [name.strip() for name in names]

main_handler = VB2PYLogger()
main_handler.setFormatter(logging.Formatter(logging.BASIC_FORMAT))
main_handler.initConfiguration(Config)

def getLogger(name, level=None):
    """Create a logger with the usual settings"""
	if level is None:
		level = int(Config["General", "LoggingLevel"])
    log = logging.getLogger(name)
    log.addHandler(main_handler)
    log.setLevel(level)
    return log</t>
<t tx="pap.120703001453.5">@root converter.py

&lt;&lt; Documentation &gt;&gt;
&lt;&lt; Declarations &gt;&gt;
&lt;&lt; Error classes &gt;&gt;

&lt;&lt; VBConverter &gt;&gt;

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.6">@c

"""VB2Py - VB to Python + PythonCard conversion

This application converts VB projects to Python and PythonCard projects.
The form layouts are converted and you can optionally convert the VB
to Python, including translation of the VB events.

The VB conversion is very preliminary!

So is the layout...

"""</t>
<t tx="pap.120703001453.7">@c

import re	    # For text processing
import os     # For file processing
import pprint # For outputting dictionaries
import sys    # For getting Exec prefix
import getopt # For command line arguments
import imp    # For dynamic import of classes

from utils import rootPath
from config import VB2PYConfig
Config = VB2PYConfig()

import logger   # For logging output and debugging 
log = logger.getLogger("vb2Py")

import vbparser

#from controls import *
twips_per_pixel = 15

__app_name__ = "VB2Py"
__version__ = "0.2.2"

# Try to import ctypes module to read type libraries
try:
    import ctypes.com.tools.readtlb as readtlb
except ImportError:
    readtlb = None</t>
<t tx="pap.120703001453.8">@c

class VB2PyError(Exception): """An error occured converting a project"""</t>
<t tx="pap.120703001453.9">&lt;&lt; VBConverter &gt;&gt;=

class VBConverter(object):
	"""Class to convert VB projects to Python Card projects"""
	
	&lt;&lt; class VBConverter methods &gt;&gt;</t>
<t tx="pap.120703001453.10">&lt;&lt; class VBConverter methods &gt;&gt;=

def __init__(self, resource, parser=None):
	"""Initialize with a target resource"""
	self._target_resource = resource
	if parser:
		self.parser = parser
	else:
		self.parser = ProjectParser</t>
<t tx="pap.120703001453.11">&lt;&lt; class VBConverter methods &gt;&gt;=

def doConversion(self, filename, callback=None):
	"""Convert the named VB project to a python project"""
	project_root, project_file = os.path.split(filename)
	self.logText("Parsing '%s'" % filename)
	project = self.parser(filename)
	project.doParse()
	self.logText("Processing project '%s'" % project.name)
	#
    self.resources = []
    #
	# TODO: Refactor here
    self.project_structure = vbparser.VBProject()
	#
	total = len(project.forms) + len(project.modules) + len(project.classes) + 1
	done = 0
	#
    &lt;&lt; Handle references &gt;&gt;
    &lt;&lt; Handle modules &gt;&gt;
    &lt;&lt; Handle forms &gt;&gt;    
    &lt;&lt; Handle classes &gt;&gt; 
	#
	if callback:
		callback("Done!", 100.0)   

</t>
<t tx="pap.120703001453.12">@c

self.forms = []
for form in project.forms:
	done +=1
	if callback:
		callback("Reading form '%s'" % form, 100.0*done/total)
	#
    self.logText("Reading form '%s'" % form)
    frm = FormParser(os.path.join(project_root, form))
    frm.doParse(self.project_structure)
    if frm.form:
        frm.resources = self._target_resource()
        frm.resources.updateFrom(frm.form)
        frm.resources.updateCode(frm)
		frm.resources.code_block = frm.code_block
		frm.resources.log = log
        self.forms.append(frm)
        self.resources.append(frm.resources)
	#
</t>
<t tx="pap.120703001453.13">@c

self.modules = []
for module in project.modules:
    module_name, module_filename = module.split(";")
	done +=1
	if callback:
		callback("Reading module '%s'" % module_name, 100.0*done/total)
	#
    self.logText("Reading module '%s'" % module_name)
    mod = ModuleParser(os.path.join(project_root, module_filename.strip()), module_name)
    mod.doParse(self.project_structure)
    self.modules.append(mod)
    self.resources.append(mod)
    
</t>
<t tx="pap.120703001453.14">@c

self.classes = []
for cls in project.classes:
    cls_name, cls_filename = cls.split(";")
	done +=1
	if callback:
		callback("Reading class '%s'" % cls_name, 100.0*done/total)
	#
    self.logText("Reading class module '%s'" % cls_name)
    class_mod = ClassParser(os.path.join(project_root, cls_filename.strip()), cls_name)
    class_mod.doParse(self.project_structure)
    self.classes.append(class_mod)
    self.resources.append(class_mod)
    
</t>
<t tx="pap.120703001453.15">&lt;&lt; class VBConverter methods &gt;&gt;=

def logText(self, text):
	"""Log text to show progress"""
	log.info("&gt; %s" % text)</t>
<t tx="pap.120703001453.16">&lt;&lt; VBConverter &gt;&gt;=

class BaseParser(object):
	"""A base parser object"""
	
	&lt;&lt; class BaseParser methods &gt;&gt;</t>
<t tx="pap.120703001453.17">&lt;&lt; class BaseParser methods &gt;&gt;=

def __init__(self, filename, name=None):
	"""Initialize the parser"""
    self.references = []
	self.filename = filename
	self.text = self.readFileContent(filename)
	self.name = name or os.path.splitext(os.path.split(filename)[1])[0]
	self.basedir = os.path.split(filename)[0]
</t>
<t tx="pap.120703001453.18">&lt;&lt; class BaseParser methods &gt;&gt;=

def doValidation(self):
	"""Validate the data we parsed out of the file"""
	pass</t>
<t tx="pap.120703001453.19">&lt;&lt; class BaseParser methods &gt;&gt;=

def findMany(self, id):
	"""Find a list of values in the file"""
	return self._getPattern(id).findall(self.text)</t>
<t tx="pap.120703001453.20">&lt;&lt; class BaseParser methods &gt;&gt;=

def findOne(self, id, default=None):
	"""Find a value in the file"""
	match = self._getPattern(id).search(self.text)
	if match:
		return match.groups(1)[0]
	else:
		return default</t>
<t tx="pap.120703001453.21">&lt;&lt; class BaseParser methods &gt;&gt;=

def splitSectionByMarker(self, marker):
	"""Split a block of text about a marker"""
	pattern = re.compile('^%s ' % marker, re.MULTILINE+re.UNICODE)
	match = pattern.search(self.text)
	if match:
		return (self.text[:match.start(0)], self.text[match.start(0):])
	else:
		return None</t>
<t tx="pap.120703001453.22">&lt;&lt; class BaseParser methods &gt;&gt;=

def _getPattern(self, id):
	"""Create a search pattern"""
	return re.compile('^%s\s*=\s*"*(.*?)"*$' % id, re.MULTILINE+re.UNICODE)</t>
<t tx="pap.120703001453.23">&lt;&lt; class BaseParser methods &gt;&gt;=

def parseCode(self, project):
	"""Parse the form code"""
    container = self.getContainer()
    #container.parent = project
    container.assignParent(project)
    try:
        self.code_structure = vbparser.parseVB(self.code_block, container=container)		
    except vbparser.VBParserError, err:
        log.error("Unable to parse '%s'(%s): %s" % (self.name, self.filename, err))
        self.code_structure = vbparser.VBMessage(
					messagetype="ParsingError",
					message="Failed to parse (%s)" % err)
									   </t>
<t tx="pap.120703001453.24">&lt;&lt; class BaseParser methods &gt;&gt;=

def getContainer(self):
    """Return the container to use for code conversion"""
    return vbparser.VBModule()</t>
<t tx="pap.120703001453.25">&lt;&lt; class BaseParser methods &gt;&gt;=

def writeToFile(self, basedir, write_code=0):
    """Write this out to a file"""
    raise VB2PyError("Unable to write '%s' to a file" % self)</t>
<t tx="pap.120703001453.26">&lt;&lt; VBConverter &gt;&gt;=

class ProjectParser(BaseParser):
	"""A VB project parser object"""
	
	&lt;&lt; class ProjectParser methods &gt;&gt;</t>
<t tx="pap.120703001453.27">&lt;&lt; class ProjectParser methods &gt;&gt;=

def doParse(self):
	"""Parse the text"""
	self.forms = self.findMany("Form")
	self.startup = self.findOne("Startup")
	self.name = self.findOne("Name")
	self.modules = self.findMany("Module")
	self.classes = self.findMany("Class")
    self.references = self.findMany("Reference")
	#
	# Do sanity check
	self.doValidation()</t>
<t tx="pap.120703001453.28">&lt;&lt; class ProjectParser methods &gt;&gt;=

def doValidation(self):
	"""Validate that the project was reasonable"""
	#if not self.forms:
	#	raise VB2PyError("No forms in the project! Nothing to convert")
</t>
<t tx="pap.120703001453.29">&lt;&lt; VBConverter &gt;&gt;=

class FileParser(ProjectParser):
	"""A parser for VB files which are not part of a project"""
	
	&lt;&lt; class FileParser methods &gt;&gt;</t>
<t tx="pap.120703001453.30">&lt;&lt; class FileParser methods &gt;&gt;=

def doParse(self):
	"""Parse the text"""
	#
	log.info("Using single file parser")
	#
	self.forms = []
	self.modules = []
	self.classes = []
	self.startup = None
	#
	extn = os.path.splitext(self.filename)[1].lower()
	#
	if extn == ".frm":
		self.name = self.findOne("Attribute VB_Name")
		self.forms = [self.filename]
		self.startup = self.findOne("Startup")
	elif extn == ".bas":
		self.name = self.findOne("Attribute VB_Name")
		self.modules = ["%s; %s" % (self.name, self.filename)]
	elif extn == ".cls":
		self.name = self.findOne("Attribute VB_Name")
		self.classes = ["%s; %s" % (self.name, self.filename)]
	else:
		raise VB2PyError("Unknown file extension: '%s'" % extn)
	#
	# Do sanity check
	self.doValidation()

</t>
<t tx="pap.120703001453.31">&lt;&lt; class FileParser methods &gt;&gt;=

def doValidation(self):
	"""Validate that the project was reasonable"""
	
</t>
<t tx="pap.120703001453.32">&lt;&lt; VBConverter &gt;&gt;=

class FormParser(BaseParser):
	"""A VB form parser object"""
	
	&lt;&lt; class FormParser methods &gt;&gt;</t>
<t tx="pap.120703001453.33">&lt;&lt; class FormParser methods &gt;&gt;=

def doParse(self, project):
	"""Parse the text"""
	&lt;&lt; Split off code section &gt;&gt;
	self.parseForm()
	if self.form:
		self.parseCode(project)
		&lt;&lt; Add controls to form namespace &gt;&gt;

</t>
<t tx="pap.120703001453.34">@doc
We try to find the code section - this is delimeted by a series of "Attribute" definitions. This is pretty hokey and there should be a better way to do this, but this method seems to work so far
@c

data = self.splitSectionByMarker("Attribute")
if data:
	self.form_data, self.code_block = data
else:
	self.form_data = self.code_block = None
	</t>
<t tx="pap.120703001453.35">All the controls that this form owns are in the local namespace so we need to add them to the VBFormModule so that they will be converted to the proper (self.) style
@c


		 
distinct_names = {}
for control in self.form._getControlsOfType():
	#
	# Add name to namespace
	name = control._realName()
	distinct_names[name] = 1
	#
	# Look for events for this control
	for event in control._getEvents():	
		event_name, new_name = event.vbname, event.pyname
		#
		# Look for local definitions of methods which match the VB events for this object
		for item in self.code_structure.locals:
			if event_name % name == item.identifier:
				# Add a name substitution to translate references to this name to the PythonCard version
				self.code_structure.name_substitution[event_name % name] = "self." + new_name % name
				# Change the definition
				event.updateMethodDefinition(item, name)
				
	
self.code_structure.local_names.extend(distinct_names.keys())
	
# Probably need to get self.form._getControlList()
# then strip front of name (vbobj_txtName) and add to
# code_structure.local_names</t>
<t tx="pap.120703001453.36">@doc
To parse the form we take advantage of the fact that the data is almost a readable python structure anyway. It looks like
VERSION 5.00
Begin VB.Form frmMain 
   Caption         =   "Form1"
   StartUpPosition =   3  'Windows Default
   Begin VB.CommandButton btnSecond 
      Caption         =   "Second Form"
      Height          =   375
   End
End

Begin = class
name = super

&lt;&lt; class FormParser methods &gt;&gt;=

def parseForm(self):
	"""Parse the form definition"""
	self.form_data = self.form_data.replace("\r\n", "\n") # For *nix
	&lt;&lt; Get name of form class &gt;&gt;
	&lt;&lt; Begin class conversion &gt;&gt;
	&lt;&lt; Convert properties &gt;&gt;
	&lt;&lt; Menu shortcuts &gt;&gt;
	&lt;&lt; Remove meaningless bits &gt;&gt;
	&lt;&lt; Remove references to frx file &gt;&gt;
	&lt;&lt; Hex numbers &gt;&gt;
	&lt;&lt; Convert object references &gt;&gt;
	if Config["General", "DumpFormData"] == "Yes":
        log.debug(self.form_data)
	self.namespace = {"resource" : resource, "Object" : NameSpace()}
	try:
		exec self.form_data.replace("\r", "") in self.namespace
	except Exception, err:
		log.error("Failed during conversion of '%s'" % self.name)
		self.form = None
	else:
		self.form = self.namespace["vbobj_%s" % self.name]
		self.form.name = self.name
		self.groupOptionButtons(self.form)
</t>
<t tx="pap.120703001453.37">@doc
Need to get the name of the form class - this is not always the same as the filename
@c
pattern = re.compile(r"^Begin\s+VB\.Form\s+(\w+)", re.MULTILINE+re.UNICODE)
name_match = pattern.findall(self.form_data)

if name_match:
	self.name = name_match[0]
</t>
<t tx="pap.120703001453.38">@c

pattern = re.compile(r'^(\s*)Begin\s+(\w+)\.(.+?)\s+(.+?)\s*?$', re.MULTILINE+re.UNICODE)

def sub_begin(match):
	if match.groups()[1] in ("VB", "ComctlLib"):
		return '%sclass vbobj_%s(resource.%s):' % (
				match.groups()[0],
				match.groups()[3],
				resource.possible_controls.get(match.groups()[2], "VBUnknownControl"))
	else:
		log.warn('Unknown control %s.%s' % (match.groups()[1], match.groups()[2]))
		return '%sclass vbobj_%s(resource.VBUnknownControl):' % (
				match.groups()[0], match.groups()[3])
		
self.form_data = pattern.sub(sub_begin, self.form_data)</t>
<t tx="pap.120703001453.39">@c

pattern = re.compile(r'^(\s*)BeginProperty\s+(\w+)(\(.*?\))?\s(.*?)$', re.MULTILINE+re.UNICODE)

def sub_beginproperty(match):
	return '%sclass vbobj_%s(resource.%s): # %s %s' % (
			match.groups()[0],
			match.groups()[1],
			resource.possible_controls.get(match.groups()[1], "VBUnknownControl"),
			match.groups()[2],
			match.groups()[3],
)
		
self.form_data = pattern.sub(sub_beginproperty, self.form_data)</t>
<t tx="pap.120703001453.40">@c

pattern = re.compile(r'^(\s*)Object\s*=\s*"(\S+)"\s*;\s*(.*?)$', re.MULTILINE+re.UNICODE)

def sub_beginobject(match):
	return '%s# %s, %s' % (
			match.groups()[0],
			match.groups()[1],
			match.groups()[2],
)
		
self.form_data = pattern.sub(sub_beginobject, self.form_data)</t>
<t tx="pap.120703001453.41">@c

pattern = re.compile(r'^(\s*)Shortcut\s*=\s*(\S+)\s*$', re.MULTILINE+re.UNICODE)

def sub_shortcut(match):
	return '%sshortcut = "%s"' % (
			match.groups()[0],
			match.groups()[1])
		
self.form_data = pattern.sub(sub_shortcut, self.form_data)</t>
<t tx="pap.120703001453.42">@c

#
# End
pattern = re.compile("^\s*End$", re.MULTILINE+re.UNICODE)
self.form_data = pattern.sub("", self.form_data)

#
# End Property
pattern = re.compile("^\s*EndProperty$", re.MULTILINE+re.UNICODE)
self.form_data = pattern.sub("", self.form_data)

#
# Version
pattern = re.compile("^VERSION\s+.*?$", re.MULTILINE+re.UNICODE)
self.form_data = pattern.sub("", self.form_data)

#
# Comments
self.form_data = self.form_data.replace("'", "#")</t>
<t tx="pap.120703001453.43">@c

def sub_frx(match):
	s = '"%s.frx@%s"' % (os.path.join(self.basedir, match.groups()[0]), match.groups()[1])
	return s.replace("\\", "/")
	
pattern = re.compile('\$?"(.*)\.frx":(\S+)', re.MULTILINE+re.UNICODE)
self.form_data = pattern.sub(sub_frx, self.form_data)
</t>
<t tx="pap.120703001453.44">@c

#
# Convert hex numbers - which are colours 
# We will have problems with system colours (&amp;H80 ... ) so we 
# ultimately need a lookup table here

pattern = re.compile("\&amp;H([A-F0-9]{8})\&amp;", re.MULTILINE+re.UNICODE)

def sub_hex(match):
    txt = match.groups()[0]
    return "(%d, %d, %d)" % (int(txt[2:4], 16),
                             int(txt[4:6], 16),
                             int(txt[6:8], 16))
							 
self.form_data = pattern.sub(sub_hex, self.form_data)
</t>
<t tx="pap.120703001453.45">Option buttons in VB are just properties of their container. The equivalent in PythonCard are option groups which are all in one place. We have to go into the VB form and pull all the options together so we start at the form level and then descend down each sub-container to make sure that we grab them all as a group.

&lt;&lt; class FormParser methods &gt;&gt;=

def groupOptionButtons(self, cls):
	"""Pull all the option buttons together for this class"""
	#
	# Get all options
	options = cls._getControlsOfType("RadioGroup")
	if not options:
		return
	#
	# Get start properties
	grp = options[0]
	#
	# Make a list of the captions and of the currently selected one
	captions = []
	selected = None
	for option in options:
		caption = option._get('Caption', 'Option')
		captions.append(caption)
		if option._get('Value', 0) == -1:
			selected = caption
			#
			# TODO: map names of options to pycard names
		#
		# Delete the group
		if option is not grp and hasattr(cls, option.__name__):
			delattr(cls, option.__name__)
	#
	# Now add a new option group
	grp.items = captions
	grp.selected = selected
	#
	# Make sure we also look in other containers on this form
	for container in cls._getContainerControls():
		self.groupOptionButtons(container)
			
</t>
<t tx="pap.120703001453.46">&lt;&lt; class FormParser methods &gt;&gt;=

def getContainer(self):
    """Return the container to use for code conversion"""
    return vbparser.VBFormModule(modulename=self.name)</t>
<t tx="pap.120703001453.47">&lt;&lt; VBConverter &gt;&gt;=

class ModuleParser(BaseParser):
	"""A VB module parser object"""
	
	&lt;&lt; class ModuleParser methods &gt;&gt;</t>
<t tx="pap.120703001453.48">&lt;&lt; class ModuleParser methods &gt;&gt;=

def doParse(self, project):
	"""Parse the text"""
    self.code_block = self.text
	self.parseCode(project)

</t>
<t tx="pap.120703001453.49">&lt;&lt; class ModuleParser methods &gt;&gt;=

def getContainer(self):
    """Return the container to use for code conversion"""
    return vbparser.VBCodeModule(modulename=self.name)</t>
<t tx="pap.120703001453.50">&lt;&lt; class ModuleParser methods &gt;&gt;=

def writeToFile(self, basedir, write_code=0):
    """Write this out to a file"""
	fname = os.path.join(basedir, self.name) + ".py"
    fle = open(fname, "w")
	log.info("Writing: %s" % fname)
    try:
        fle.write(vbparser.renderCodeStructure(self.code_structure))
    finally:
        fle.close()    
</t>
<t tx="pap.120703001453.51">&lt;&lt; VBConverter &gt;&gt;=

class ClassParser(ModuleParser):
	"""A VB class module parser object"""
	
	&lt;&lt; class ClassParser methods &gt;&gt;</t>
<t tx="pap.120703001453.52">&lt;&lt; class ClassParser methods &gt;&gt;=

def getContainer(self):
    """Return the container to use for code conversion"""
    return vbparser.VBClassModule(modulename=self.name, classname=self.name)</t>
<t tx="pap.120703001453.53">&lt;&lt; VBConverter &gt;&gt;=

class BaseResource(object):
	"""A VB form resource object"""
	
	target_name = "Python"
	name = "baseResource"
    form_class_name = "FormClass"
    form_super_classes = []
    allow_new_style_class = 1
        
	&lt;&lt; class BaseResource methods &gt;&gt;
</t>
<t tx="pap.120703001453.54">&lt;&lt; class BaseResource methods &gt;&gt;=

def __init__(self, basesourcefile=None):
	"""Initialize the resource"""
	if basesourcefile is None:
		self.basesourcefile = os.path.join(
					rootPath(), "targets", self.target_name, "basesource")
	else:
		self.basesourcefile = basesourcefile
	#
	# Apply default resource
	self._rsc = {}
	self._code = ""
	#
	log.debug("BaseResource init")


</t>
<t tx="pap.120703001453.55">&lt;&lt; class BaseResource methods &gt;&gt;=

def updateFrom(self, form):
	"""Update our resource from the form object"""
	&lt;&lt; Main properties &gt;&gt;
	&lt;&lt; Components &gt;&gt;
	&lt;&lt; Menus &gt;&gt;
</t>
<t tx="pap.120703001453.56">@c

#
# The main properties of the form
d = self._rsc['application']['backgrounds'][0]
self.name = form.name
d['name'] = form.name
d['title'] = form.Caption

#
# Add menu height to form height if it is needed
if form._getControlsOfType("Menu"):
	height_modifier = form.HeightModifier + form.MenuHeight
else:
	height_modifier = form.HeightModifier
	
d['size'] = (form.ClientWidth/twips_per_pixel, form.ClientHeight/twips_per_pixel+height_modifier)
d['position'] = (form.ClientLeft/twips_per_pixel, form.ClientTop/twips_per_pixel)
</t>
<t tx="pap.120703001453.57">@c

#
# The components (controls) on the form
c = self._rsc['application']['backgrounds'][0]['components']

for cmp in form._getControlList():
	obj = form._get(cmp)
	entry = obj._getControlEntry()
	if entry:
		c += entry</t>
<t tx="pap.120703001453.58">@c

#
# The menus
m = []
self._rsc['application']['backgrounds'][0]['menubar']['menus'] = m

self.addMenus(form, m)</t>
<t tx="pap.120703001453.59">&lt;&lt; class BaseResource methods &gt;&gt;=

def updateCode(self, form):
	"""Update our code blocks"""
    #
    # Make sure the code structure has the right context
    form.code_structure.classname = self.form_class_name
    form.code_structure.superclasses = self.form_super_classes
    form.code_structure.allow_new_style_class = self.allow_new_style_class
    #
    # Convert it to Python code
    self.code_structure = form.code_structure


</t>
<t tx="pap.120703001453.60">&lt;&lt; class BaseResource methods &gt;&gt;=


def addMenus(self, obj, to_menu):
	"""Add menus"""
	for mnu in obj._getControlsOfType("Menu"):
		d = mnu._pyCardMenuEntry()
		d["items"] = []
		to_menu.append(d)
		self.addMenus(mnu, d['items'])
		if not d['items']:
			del(d['items'])
			d['type'] = 'MenuItem'
</t>
<t tx="pap.120703001453.61">&lt;&lt; class BaseResource methods &gt;&gt;=

def writeToFile(self, basedir, write_code=0):
	"""Write ourselves out to a directory"""
</t>
<t tx="pap.120703001453.62">&lt;&lt; VBConverter &gt;&gt;=

class NameSpace:
	"""Namespace to store values"""
</t>
<t tx="pap.120703001453.63">&lt;&lt; VBConverter &gt;&gt;=

def main():
	"""Main application"""
	&lt;&lt; Parse options &gt;&gt;	
	&lt;&lt; Validate arguments &gt;&gt;
	TargetResource = importTarget(target)
	conv = VBConverter(TargetResource, parser)
	conv.doConversion(project_file)
	renderTo(conv, destination_dir, do_code)</t>
<t tx="pap.120703001453.64">@c

try:
	opts, args = getopt.getopt(sys.argv[1:], "dfchvst:", ["help", "code", "version", "supports"])
except getopt.GetoptError, err:
	# print help information and exit:
	usage(error=err)
	sys.exit(2)

do_code = 0
target = "PythonCard"
parser = ProjectParser

for o, a in opts:
	if o in ("-h", "--help"):
		usage()
		sys.exit()
	if o in ("-s", "--supports"):
		supports()
		sys.exit()
	if o in ("-c", "--code"):
		do_code = 1
	if o in ("-v" , "--version"):
		print "%s v%s" % (__app_name__, __version__)
		sys.exit(2)
	if o in ("-t", ):
		target = a
	if o in ("-f", ):
		parser = FileParser
    if o in ("-d", ):
        Config.setLocalOveride("General", "DumpFormData", "Yes")
		
if len(args) &lt;&gt; 2:
	usage("Converter needs two arguments (a file and a path)")
	sys.exit(2)

project_file, destination_dir = args



</t>
<t tx="pap.120703001453.65">@c

if not os.path.isfile(project_file):
	print "First parameter must be a valid VB file"
	sys.exit(2)
elif not os.path.isdir(destination_dir):
	print "Second argument must be a valid directory"
	sys.exit(2)
	
</t>
<t tx="pap.120703001453.66">@doc
We need to import classes which are appropriate for the given target using the imp module

&lt;&lt; VBConverter &gt;&gt;=

def importTarget(target):
	"""Import the target resource"""
	global event_translator, resource
	
	from targets.pythoncard	import resource
	TargetResource = resource.Resource
	
	try:
		event_translator = resource.event_translator
	except AttributeError:
		event_translator = {}
		
	return TargetResource
</t>
<t tx="pap.120703001453.67">&lt;&lt; VBConverter &gt;&gt;=

def renderTo(conv, destination_dir, do_code=1):
	"""Render the converted code to a localtion"""	
	for item in conv.resources:
		item.writeToFile(destination_dir, do_code)</t>
<t tx="pap.120703001453.68">&lt;&lt; VBConverter &gt;&gt;=

def usage(error=None):
	"""Print usage statement"""
	if error:
		print "\n\nInvalid option! (%s)" % error
	print "\nconverter -chvs project.vpb destination\n\n" \
		  "   project.vbp = VB project file\n" \
		  "   desination  = Destination directory for files\n\n" \
		  "   -tTarget = Target platform" \
		  "   -c = Convert VB code also\n" \
		  "   -v = Print version and exit\n" \
		  "   -h = Print this message\n" \
		  "   -f = Just process the given file\n" \
          "   -d = Dump out the form definition classes\n"
		  
</t>
<t tx="pap.120703001453.69">&lt;&lt; VBConverter &gt;&gt;=

def supports():
	"""Show a list of controls supported by this converter"""
	print "This command line option is not currently available"
	return
	print "\nSupported controls\n"
	for control in possible_controls:
		ctrl = possible_controls[control]
		if ctrl &lt;&gt; VBUnknownControl:
			print "   - %s (as %s)" % (control, ctrl.pycard_name)
	print 
		  </t>
<t tx="pap.120703001453.70"></t>
<t tx="pap.120703001453.71">@root targets\__init__.py

pass</t>
<t tx="pap.120703001453.72"></t>
<t tx="pap.120703001453.73">@root targets\pythoncard\__init__.py

from PythonCard import registry
PythonCardRegistry = registry.Registry.getInstance()

def Register(control):
    """Register a control for PythonCard"""
    #
    #import pdb; pdb.set_trace()
    PythonCardRegistry.register(control)</t>
<t tx="pap.120703001453.74">@root targets\pythoncard\basesource.txt

{'application':{'type':'Application',
          'name':'Template',
    'backgrounds': [
    {'type':'Background',
          'name':'bgTemplate',
          'title':'Auto converted application',
          'position':(445, 73),
          'size':(345, 255),
          'style':['resizeable'],

        'menubar': {'type':'MenuBar',
         'menus': [
             {'type':'Menu',
             'name':'menuFile',
             'label':'&amp;File',
             'items': [
                  {'type':'MenuItem',
                   'name':'menuFileExit',
                   'label':'E&amp;xit',
                  },
              ]
             },
         ]
     },
         'components': [
] # end components
} # end background
] # end backgrounds
} }
</t>
<t tx="pap.120703001453.75">@root targets\pythoncard\basesource.py

"""The main form for the application"""

from PythonCard import model

# Allow importing of our custom controls
import PythonCard.resource
PythonCard.resource.APP_COMPONENTS_PACKAGE = "vb2py.targets.pythoncard.vbcontrols"

class Background(model.Background):
	
    def __getattr__(self, name):
        """If a name was not found then look for it in components"""
        return getattr(self.components, name)


	def __init__(self, *args, **kw):
		"""Initialize the form"""
		model.Background.__init__(self, *args, **kw)
		# Call the VB Form_Load
        # TODO: This is brittle - depends on how the private indicator is set
		if hasattr(self, "_Background__Form_Load"):
			self._Background__Form_Load()
		elif hasattr(self, "Form_Load"):
			self.Form_Load()
		
			
# CODE_GOES_HERE

			
if __name__ == '__main__':
    app = model.Application(Background)
    app.MainLoop()

</t>
<t tx="pap.120703001453.76">@root targets\pythoncard\controls.py

import vb2py.vbparser
from vb2py.config import VB2PYConfig
Config = VB2PYConfig()

from vb2py import logger   # For logging output and debugging 
log = logger.getLogger("PythonCardControls")

twips_per_pixel = 15

&lt;&lt; Events &gt;&gt;
&lt;&lt; SupportedControls &gt;&gt;
</t>
<t tx="pap.120703001453.77">@doc
These are some common groupings of events that lots of controls have

TODO:
	OLE ones
	ZOrder
	ShowWhatsThis

An event definition comprises:
	The VB Name, The PCard Name, the VB Params, The PCard Params	
@c

&lt;&lt; EventSupport &gt;&gt;

#
evtClick = ControlEvent("%s_Click", "on_%s_mouseClick")
evtDblClick = ControlEvent("%s_DblClick", "on_%s_mouseDoubleClick")
evtClickAll = (evtClick, evtDblClick)

evtRefresh = ControlEvent("%s_Refresh", "on_%s_Refresh_NOTSUPPORTED") # TODO: what is the Pythoncard equivalent

evtChange = ControlEvent("%s_Change", "on_%s_textUpdate")

#
# Focus
evtGotFocus = ControlEvent("%s_GotFocus", "on_%s_gainFocus")
evtLostFocus = ControlEvent("%s_LostFocus", "on_%s_loseFocus")
evtSetFocus = ControlEvent("%s_SetFocus", "on_%s_setFocus_NOTSUPPORTED")  # TODO: what is the Pythoncard equivalent
evtFocusAll = (evtGotFocus, evtLostFocus, evtSetFocus)

#
# Mouse moving
evtMouseMove = ControlEvent("%s_MouseMove", "on_%s_mouseMove", 
							("Button", "Shift", "X", "Y"),
							("ButtonDown()", "ShiftDown()", "x", "y"))
evtMouseDown = ControlEvent("%s_MouseDown", "on_%s_mouseDown",
							("Button", "Shift", "X", "Y"),
							("ButtonDown()", "ShiftDown()", "x", "y"))
evtMouseUp = ControlEvent("%s_MouseUp", "on_%s_mouseUp",
							("Button", "Shift", "X", "Y"),
							("ButtonDown()", "ShiftDown()", "x", "y"))
evtMouseAll = (evtMouseMove, evtMouseDown, evtMouseUp)

#
# Pathologically some events have lower case X and Y in the VB version!
evtMouseMoveLC = ControlEvent("%s_MouseMove", "on_%s_mouseMove", 
							("Button", "Shift", "x", "y"),
							("ButtonDown()", "ShiftDown()", "x", "y"))
evtMouseDownLC = ControlEvent("%s_MouseDown", "on_%s_mouseDown",
							("Button", "Shift", "x", "y"),
							("ButtonDown()", "ShiftDown()", "x", "y"))
evtMouseUpLC = ControlEvent("%s_MouseUp", "on_%s_mouseUp",
							("Button", "Shift", "x", "y"),
							("ButtonDown()", "ShiftDown()", "x", "y"))
evtMouseAllLC = (evtMouseMoveLC, evtMouseDownLC, evtMouseUpLC)


#
# Keys
evtKeyUp = ControlEvent("%s_KeyUp", "on_%s_keyUp_NOTSUPPORTED") # TODO: what is the Pythoncard equivalent
evtKeyDown = ControlEvent("%s_KeyDown", "on_%s_keyDown_NOTSUPPORTED") # TODO: what is the Pythoncard equivalent
evtKeyPress = ControlEvent("%s_KeyPress", "on_%s_keyPress_NOTSUPPORTED") # TODO: what is the Pythoncard equivalent
evtKeyAll = (evtKeyUp, evtKeyDown, evtKeyPress)

#
# Dragging
evtDrag = ControlEvent("%s_Drag", "on_%s_Drag_NOTSUPPORTED") # TODO: what is the Pythoncard equivalent
evtDragDrop = ControlEvent("%s_DragDrop", "on_%s_DragDrop_NOTSUPPORTED") # TODO: what is the Pythoncard equivalent
evtDragOver = ControlEvent("%s_DragOver", "on_%s_DragOver_NOTSUPPORTED") # TODO: what is the Pythoncard equivalent
evtDragAll = (evtDrag, evtDragDrop, evtDragOver)</t>
<t tx="pap.120703001453.78">&lt;&lt; EventSupport &gt;&gt;=

class ControlEvent:
	"""Represents a control event mapping from VB to PythonCard
	
	A control event (eg MouseClick) is defined in VB with a certain name
	and list of parameters. PythonCard has an analogus event with a
	different name and all the parameters are bound up in an event
	object.
	
	This class helps in the mapping of one to the other.
	
	"""
	
	&lt;&lt; ControlEvent methods &gt;&gt;
</t>
<t tx="pap.120703001453.79">&lt;&lt; ControlEvent methods &gt;&gt;=

def __init__(self, vbname, pyname, vbargs=None, pyargs=None):
	"""Initialize the control event"""
	self.vbname = vbname
	self.pyname = pyname
	self.vbargs = vbargs or []
	self.pyargs = pyargs or []</t>
<t tx="pap.120703001453.80">&lt;&lt; ControlEvent methods &gt;&gt;=

def updateMethodDefinition(self, method, name):
	"""Update the definition of a method based on this translation"""
	method.identifier = self.pyname % name
	# Overwrite the parameter definition
	method.parameters = [vb2py.vbparser.VBRenderDirect("*args")]
	method.scope = "Public"
	#
	# Map arguments
	if self.vbargs:
		mapping = "%s = vbGetEventArgs([%s], args)" % (
					", ".join(self.vbargs),
					", ".join(['"%s"' % arg for arg in self.pyargs]))
		method.block.blocks.insert(0, vb2py.vbparser.VBRenderDirect(mapping, indent=1, crlf=1))
</t>
<t tx="pap.120703001453.81">&lt;&lt; SupportedControls &gt;&gt;=

class VBControl:
	"""Base class for all VB controls"""
	
	pycard_name = "VBControl"
	is_container = 0 # 1 for container classes like frames
	
	_attribute_translations = { 
				"Visible" : "visible",
				"BackColor" : "backgroundColor",
				"ForeColor" : "foregroundColor",
				"ToolTipText" : "toolTip",
				}

	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = ()
	
    # Some standard attributes which can be absent
    Caption = "UnknownCaption"
    
	&lt;&lt; class VBControl methods &gt;&gt;</t>
<t tx="pap.120703001453.82">&lt;&lt; class VBControl methods &gt;&gt;=

def _getPropertyList(cls):
	"""Return a list of the properties of this control"""
	items = []
	for item in dir(cls):
		if not (item.startswith("_") or item.startswith("vbobj_")):
			items.append(item)
	return items
		
_getPropertyList = classmethod(_getPropertyList)		</t>
<t tx="pap.120703001453.83">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlList(cls):
	"""Return a list of the controls contained in this control"""
	items = []
	for item in dir(cls):
		if not item.startswith("_") and item.startswith("vbobj_"):
			items.append(item)
	return items
		
_getControlList = classmethod(_getControlList)		</t>
<t tx="pap.120703001453.84">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlsOfType(cls, type_name=None):
	"""Return a control with a given type"""
	lst = []
	for item in dir(cls):
		if not item.startswith("_") and item.startswith("vbobj_"):
			obj = cls._get(item)
			if obj.pycard_name == type_name or type_name is None:
				lst.append(obj)
			if obj.is_container:
				lst.extend(obj._getControlsOfType(type_name))
	return lst
		
_getControlsOfType = classmethod(_getControlsOfType)		</t>
<t tx="pap.120703001453.85">&lt;&lt; class VBControl methods &gt;&gt;=

def _getContainerControls(cls):
	"""Return all container controls"""
	lst = []
	for item in dir(cls):
		if not item.startswith("_"):
			obj = cls._get(item)
			try:
				is_container = obj.is_container
			except AttributeError:
				pass
			else:
				if is_container:
					lst.append(obj)
	return lst
		
_getContainerControls = classmethod(_getContainerControls)</t>
<t tx="pap.120703001453.86">&lt;&lt; class VBControl methods &gt;&gt;=

def _get(cls, name, default=None):
	"""Get one of our items"""
	try:
		return getattr(cls, name)
	except AttributeError:
		if default is not None:
			return default
		else:
			raise
	
_get = classmethod(_get)</t>
<t tx="pap.120703001453.87">&lt;&lt; class VBControl methods &gt;&gt;=

def _realName(cls):
	"""Return our real name"""
	return cls.__name__[6:]
	
_realName = classmethod(_realName)</t>
<t tx="pap.120703001453.88">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlEntry(cls):
	"""Return the pycard representation of this object"""
	#
	# Get dictionary entries for this object
	d = {}
	ret = [d]
	d['name'] = cls._realName()
	try:
		d['position'] = (cls.Left/twips_per_pixel, cls.Top/twips_per_pixel)
	except AttributeError:
		pass
	#
    # Convert VB attributes to PythonCard attributes
	for attr, pycard_attr in cls._attribute_translations.iteritems():
		if hasattr(cls, attr):
            value = getattr(cls, attr)
            # Check for colours - these are bad news!
            if attr.endswith("Color"):
                value = cls._getPyCardColours(value)
			d[pycard_attr] = value
			
	d.update(cls._getClassSpecificControlEntries())
	# Set the type - we do this here because occasionally the type will change after _getClassSpecificControlEntries
	if Config["General", "UseVBPythonCardControls"].find(cls.pycard_name) &gt; -1:
		d['type'] = "VB%s" % cls.pycard_name
	else:
		d['type'] = cls.pycard_name
	#
	# Watch out for container objects - we have to recur down them
	if cls.is_container:
		cls._processChildObjects()
		for cmp in cls._getControlList():
			obj = cls._get(cmp)
			entry = obj._getControlEntry()
			if entry:
				ret += entry
	return ret
	
_getControlEntry = classmethod(_getControlEntry)</t>
<t tx="pap.120703001453.89">&lt;&lt; class VBControl methods &gt;&gt;=

def _getClassSpecificControlEntries(cls):
	"""Return additional items for this entry
	
	This method is normally overriden in the subclass
	
	"""
	return {}
		
_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)

</t>
<t tx="pap.120703001453.90">&lt;&lt; class VBControl methods &gt;&gt;=

def _mapNameReference(cls, match):
	"""Map a reference to this object in code to something meaningful
	
	We have two issues, scope and attributes. The scope we need to map to self.components
	That was easy. But we also need to map attributes. We can't do that in the base class
	but a subclass can hopefully help us out via the _attributeTranslationClass
	
	"""
	if match.groups()[0] is not None:
		return "self.components.%s.%s" % (cls._realName(), 
										  cls._attributeTranslation(match.groups()[0]))
	else:
		return "self.components.%s" % (cls._realName(),)
		

_mapNameReference = classmethod(_mapNameReference)</t>
<t tx="pap.120703001453.91">&lt;&lt; class VBControl methods &gt;&gt;=

def _attributeTranslation(cls, name):
	"""Convert a VB attribute to a Python one"""
	try:
		return cls._attribute_translations[name]
	except KeyError:
		return VBControl._attribute_translations.get(name, name)
	
_attributeTranslation = classmethod(_attributeTranslation)	</t>
<t tx="pap.120703001453.92">&lt;&lt; class VBControl methods &gt;&gt;=

def _processChildObjects(cls):
	"""Before we deal with our child object we get a chance to do some processing
	
	Sub-classed can use this to do special things, like frames adjusting the
	properties of our children
	
	"""
	for container in cls._getContainerControls():
		container._processChildObject()
	
_processChildObjects = classmethod(_processChildObjects)</t>
<t tx="pap.120703001453.93">&lt;&lt; class VBControl methods &gt;&gt;=

def _getEvents(cls):
	"""Return a list of the events that this control has
	
	This is a list of tuples of the form
	  (VBEventName, PythonCardEventName)
	  
	  
	"""
	return cls._events
	
_getEvents = classmethod(_getEvents)
</t>
<t tx="pap.120703001453.94">&lt;&lt; class VBControl methods &gt;&gt;=

def _getAttribute(cls, name, default=None):
	"""Return a property of this class with a default if it isn't there
	
	VB doesn't store attributes unless they differ from the base class value
	and so you have to be careful when getting attributes because they may
	not be there.
	  
	"""
	try:
		return getattr(cls, name)
	except AttributeError:
		return default
	
_getAttribute = classmethod(_getAttribute)</t>
<t tx="pap.120703001453.95">&lt;&lt; SupportedControls &gt;&gt;=

&lt;&lt; Controls &gt;&gt;
	
possible_controls = { 
	"VBControl" : "VBControl",
	"Form" : "Form",
	"CommandButton" : "CommandButton",
	"OptionButton" : "OptionButton",
	"TextBox" : "TextBox",
	"Label" : "Label",
	"Menu" : "Menu",
	"ComboBox" : "ComboBox",
	"ListBox" : "ListBox",
	"CheckBox" : "CheckBox",
	"Frame" : "Frame",
	"Font" : "Font",
	"Image" : "Image",
    "ImageList" : "ImageList",
    "TreeView" : "TreeView",
    "Timer" : "Timer",
	
	"VBUnknownControl" : "VBUnknownControl",
	"FileListBox" : "VBUnknownControl",
	"OLE" : "VBUnknownControl",
	"Shape" : "VBUnknownControl",
}
</t>
<t tx="pap.120703001453.96">&lt;&lt; Controls &gt;&gt;=

class Menu(VBControl):
	"""Menu"""
	pycard_name = "Menu"
	
	def _getControlEntry(cls):
		"""Return the pycard representation of this object"""
		return {}
		
	_getControlEntry = classmethod(_getControlEntry)

	def _pyCardMenuEntry(cls):		
		"""Return the entry for this menu"""
		return {
					"type" : "Menu",
					"name" : cls._realName(),
					"label" : cls.Caption,
			 }
				
	_pyCardMenuEntry = classmethod(_pyCardMenuEntry)
</t>
<t tx="pap.120703001453.97">&lt;&lt; Controls &gt;&gt;=

class CommandButton(VBControl):
	pycard_name = "Button"
						

	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = evtClickAll + evtFocusAll + evtDragAll + evtMouseAll + evtKeyAll


	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "label" : cls.Caption,
				  "size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel),
}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
	
		</t>
<t tx="pap.120703001453.98">&lt;&lt; Controls &gt;&gt;=

class ComboBox(VBControl):
	pycard_name = "ComboBox"

	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = (evtChange,) + evtClickAll + evtFocusAll + evtDragAll + evtMouseAll + evtKeyAll
	
	def _getEntriesFromFRX(cls, data):
		"""Get list entries from FRX file"""
		file, offset = data.split("@")
		raw = open(file, "r").read()
		ptr = int(offset, 16)
		num = ord(raw[ptr])
		ptr = ptr + 4
		lst = []
		for i in range(num):
			length = ord(raw[ptr])
			lst.append(raw[ptr+2:ptr+2+length])
			ptr += 2+length
		return lst
			
	_getEntriesFromFRX = classmethod(_getEntriesFromFRX)			
		
		
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		d = {"size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel)}
		if hasattr(cls, "List"):
			d["items"] =  cls._getEntriesFromFRX(cls.List)
		else:
			d["items"] = []
		return d
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)

		
</t>
<t tx="pap.120703001453.99">&lt;&lt; Controls &gt;&gt;=

class ListBox(ComboBox):
	pycard_name = "List"
	

	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = evtClickAll + evtFocusAll + evtDragAll + evtMouseAll + evtKeyAll</t>
<t tx="pap.120703001453.100">&lt;&lt; Controls &gt;&gt;=

class Label(VBControl):
	pycard_name = "StaticText"
	
	# Default properties
	Caption = "Label"
	
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "text" : cls.Caption,
				}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
</t>
<t tx="pap.120703001453.101">&lt;&lt; Controls &gt;&gt;=

class Image(VBControl):
	pycard_name = "BitmapCanvas"
	
	Stretch = 0
	
	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = evtClickAll + evtFocusAll + evtDragAll + evtMouseAll + evtKeyAll
		
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		d = {"size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel),
		     "Stretch" : cls.Stretch}
		return d
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)

</t>
<t tx="pap.120703001453.102">&lt;&lt; Controls &gt;&gt;=

class CheckBox(VBControl):
	pycard_name = "CheckBox"

	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = evtClickAll + evtFocusAll + evtDragAll + evtMouseAll + evtKeyAll
	

	_attribute_translations = { 
					"Value" : "checked",
					}
	_attribute_translations.update(VBControl._attribute_translations)
					
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "label" : cls.Caption,
				  "checked" : cls._get("Value", 0),
				}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
</t>
<t tx="pap.120703001453.103">&lt;&lt; Controls &gt;&gt;=

class TextBox(VBControl):
	pycard_name = "TextField"
	
	# Default properties
	Text = ""
	
	#
	# Lookup table showing the VB event name and the Pythoncard event name
	_events = (evtClick, evtChange) + evtFocusAll + evtDragAll + evtMouseAll + evtKeyAll

	_attribute_translations = { 
					"Text" : "text",
					}
	_attribute_translations.update(VBControl._attribute_translations)
					
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		# Check for multiline - if so then we need a TextArea instead
		if cls._getAttribute("MultiLine", 0):
			log.info("Changed TextField to TextArea for '%s'" % cls._realName())
			cls.pycard_name = "TextArea"
		# Check if our text is stored in the FRX file
		if cls.Text.lower().find(".frx@") &gt; -1:
            log.info("Looking for text data in the FRX file")
			cls.Text = cls._getEntriesFromFRX(cls.Text)
		return {  "text" : cls.Text,
				  "size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel),
}
				
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
				
					
	def _getEntriesFromFRX(cls, data):
		"""Get text entries from FRX file"""
		file, offset = data.split("@")
		raw = open(file, "r").read()
		ptr = max(int(offset, 16)-1, 0)
		num = ord(raw[ptr])
		return raw[ptr+1:ptr+1+num-1]
			
	_getEntriesFromFRX = classmethod(_getEntriesFromFRX)			
		
</t>
<t tx="pap.120703001453.104">&lt;&lt; Controls &gt;&gt;=

class Form(VBControl):
	"""Form"""
	
	HeightModifier = 20 # Used to account for form borders
	MenuHeight = 20 # Allows for menu
	Caption = "Form"</t>
<t tx="pap.120703001453.105">&lt;&lt; Controls &gt;&gt;=

class Font(VBControl):
	"""A Font"""</t>
<t tx="pap.120703001453.106">&lt;&lt; Controls &gt;&gt;=

class Frame(VBControl):
	"""Frame"""
	pycard_name = "StaticBox"
	is_container = 1

	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel),
				}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
	
	
	def _processChildObjects(cls):
		"""Adjust the left and top properties of our children"""
		for item in cls._getControlList():
			obj = cls._get(item)
			log.debug("Offsetting %s, %s" % (obj, cls))
			if hasattr(obj, "Left"):
				obj.Left += cls.Left
			if hasattr(obj, "Top"):
				obj.Top += cls.Top
		#for container in cls._getContainerControls():
		#	container._processChildObjects()
				
	_processChildObjects = classmethod(_processChildObjects)</t>
<t tx="pap.120703001453.107">&lt;&lt; Controls &gt;&gt;=

class OptionButton(VBControl):
	pycard_name = "RadioGroup"
	
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "items" : getattr(cls, "items", ""),
				  "selected" : getattr(cls, "selected", ""),
				}
				
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
				
	</t>
<t tx="pap.120703001453.108">&lt;&lt; Controls &gt;&gt;=

class VBUnknownControl(Label):
	"""A control representing an unknown control
	
	We fake it out as a label
	
	"""
	
	Caption = "Unknown control"
</t>
<t tx="pap.120703001453.109">@root targets\pythoncard\resource.py

import re	    # For text processing
import os     # For file processing
import pprint # For outputting dictionaries
import sys    # For getting Exec prefix
import getopt # For command line arguments

# TODO: refactor out this ugliness

from vb2py.converter import BaseResource
from vb2py import vbparser
from controls import *


twips_per_pixel = 15

&lt;&lt; Event translation &gt;&gt;
&lt;&lt; Resources &gt;&gt;</t>
<t tx="pap.120703001453.110">@doc
This is the mapping between VB events and PythonCard events.
@c

event_translator = {
		"Click" : "mouseClick",
}</t>
<t tx="pap.120703001453.111">&lt;&lt; Resources &gt;&gt;=

class Resource(BaseResource):
	"""Represents a Python Card resource object"""
	
	&lt;&lt; PyCardResource declarations &gt;&gt;
	&lt;&lt; class PyCardResource methods &gt;&gt;</t>
<t tx="pap.120703001453.112">@c

target_name = "pythoncard"
name = "basePyCardResource"

form_class_name = "MAINFORM"
form_super_classes = ["Background"]
allow_new_style_class = 0</t>
<t tx="pap.120703001453.113">&lt;&lt; class PyCardResource methods &gt;&gt;=

def __init__(self, *args, **kw):
	"""Initialize the PythonCard resource"""
	BaseResource.__init__(self, *args, **kw)
	self._rsc = eval(open("%s.txt" % self.basesourcefile, "r").read().replace("\r\n", "\n"))
	self._code = open("%s.py" % self.basesourcefile, "r").read()
	</t>
<t tx="pap.120703001453.114">&lt;&lt; class PyCardResource methods &gt;&gt;=

def writeToFile(self, basedir, write_code=0):
	"""Write ourselves out to a directory"""
	&lt;&lt; Resource file &gt;&gt;
	&lt;&lt; Code file &gt;&gt;
	</t>
<t tx="pap.120703001453.115">@c


fle = open(os.path.join(basedir, self.name) + ".rsrc.py", "w")
log.info("Writing '%s'" % os.path.join(basedir, self.name) + ".rsrc.py")
pprint.pprint(self._rsc, fle)
fle.close()

</t>
<t tx="pap.120703001453.116">@c

fle = open(os.path.join(basedir, self.name) + ".py", "w")
log.info("Writing '%s'" % os.path.join(basedir, self.name) + ".py")

if write_code:
	added_code = vbparser.renderCodeStructure(self.code_structure)
else:
	added_code = ""

self._code = self._code.replace("# CODE_GOES_HERE", added_code)
								
fle.write(self._code)


fle.close()

</t>
<t tx="pap.120703001453.117">@root targets\pythoncard\controlclasses.py

"""Classes to support mapping of VB Control Properties to PythonCard

The classes fall into two types,
- a MetaClass VBWrapped to create wrapped classes
- a ProxyClass to sit between the PythonCard class and the Mimicked VB one

Although it may appear to be simpler to just subclass the PythonCard classes there
are two things that work against it. The main thing is that the PythonCard classes
must be old style classes. This means that you cannot use properties, which are
required to map things like .Top, .Width to .position[0] etc.

Since you can't use properties you have to use a __getattr__ hook. Unfortunately this
turns out to be really slow (probably because of an interaction between this hook
and a hook in a lower class which is doing a similar thing.

The solution is to use a proxy class (VBWidget) which hands off most references to 
the PythonCard class. The VBWidget is a new style class and can therefore use properties.

The metaclass (VBWrapped) is used to automatically generate properties for names which
are similar ('Text' -&gt; 'text') and names which require mapping ('Left' -&gt; 'position[1]').
A metaclass solution may not be absolutely necessary but it seems to speed things up
by doing the class manipulation once (at import) rather than for each control as it is
created.

Typical usage is as follows

class VBTextField(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
        } 

    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
        } 
    
    _proxy_for = textfield.TextField


"""

import new 
from vb2py.vbclasses import VBArray
import vb2py.logger
log = vb2py.logger.getLogger("VBWidget")

&lt;&lt; classes &gt;&gt;</t>
<t tx="pap.120703001453.118">&lt;&lt; classes &gt;&gt;=

class VBWidget(object): 

	_translations = {}
	_name_to_method_translations = {}
	_indexed_translations = {}
	_method_translations = {}
	
    def __init__(self, *args, **kw):
        self.__dict__["_proxy"] = self.__class__._proxy_for(*args, **kw)

    def __getattr__(self, name): 
        return getattr(self._proxy, name) 

    def __setattr__(self, name, value): 
        if name in self._setters: 
            self._setters[name](self, value) 
        else: 
            try:
				setattr(self._proxy, name, value) 
			except AttributeError:
				log.debug("Setting local attribute '%s' for obj %s" % (name, self.__class__.__name__))
				self.__dict__[name] = value
        
    def __getitem__(self, name): 
        return self._proxy[name] 

    def __setitem__(self, name, value): 
        self._proxy[name] = value

</t>
<t tx="pap.120703001453.119">&lt;&lt; classes &gt;&gt;=

class VBWrapped(type): 
    """A meta class to wrap PythonCard classes so VB converted code can use them""" 

	&lt;&lt; VBWrapped methods &gt;&gt;</t>
<t tx="pap.120703001453.120">&lt;&lt; VBWrapped methods &gt;&gt;=

def __new__(cls, name, bases, dict): 
    obj = type.__new__(cls, name, bases, dict) 
    obj._setters = {} 
    # Ordinary properties 
    for prop_name in obj._translations: 
        get, set = cls.createProperties(prop_name) 
        setattr(obj, prop_name, property(get, set)) 
        obj._setters[prop_name] = set 
    # Indexed properties 
    for prop_name in obj._indexed_translations: 
        get, set = cls.createIndexedProperties(prop_name) 
        setattr(obj, prop_name, property(get, set)) 
        obj._setters[prop_name] = set 
    # Method names 
    for method_name in obj._method_translations: 
        setattr(obj, method_name, cls.createMethodLookup(method_name)) 
    # Attributes which are properties in PythonCard
    for attr_name in obj._name_to_method_translations: 
        set = cls.createAttributeSet(attr_name)
        setattr(obj, attr_name, property(fget=cls.createAttributeLookup(attr_name),
                                         fset=set))
        obj._setters[attr_name] = set 


	# Set the _spec for the item
    obj._spec = obj._proxy_for._spec
    obj._spec._name = obj.__name__
    # Create the object 
    return obj</t>
<t tx="pap.120703001453.121">&lt;&lt; VBWrapped methods &gt;&gt;=

def createProperties(prop_name): 
	def set(obj, v): 
		setattr(obj, obj._translations[prop_name], v) 
	def get(obj): 
		item = getattr(obj, obj._translations[prop_name]) 
		# Wrap up list types into something we can handle
		if type(item) == type([]):
			return VBArray.createFromData(item)
		else:
			return item
	return get, set        

createProperties = staticmethod(createProperties)</t>
<t tx="pap.120703001453.122">&lt;&lt; VBWrapped methods &gt;&gt;=

def createIndexedProperties(prop_name): 
    def set(obj, v): 
        attr_name, index = obj._indexed_translations[prop_name] 
        lst = list(getattr(obj, attr_name)) 
        lst[index] = v 
        setattr(obj, attr_name, lst) 
    def get(obj): 
        attr_name, index = obj._indexed_translations[prop_name] 
        return getattr(obj, attr_name)[index] 
    return get, set        

createIndexedProperties = staticmethod(createIndexedProperties)</t>
<t tx="pap.120703001453.123">&lt;&lt; VBWrapped methods &gt;&gt;=

def createMethodLookup(method_name):
	def callMethod(obj, *args, **kw):
		return getattr(obj, obj._method_translations[method_name])(*args, **kw)
	return callMethod
		
createMethodLookup = staticmethod(createMethodLookup)</t>
<t tx="pap.120703001453.124">&lt;&lt; VBWrapped methods &gt;&gt;=

def createAttributeLookup(attr_name):
	def get(obj):
		return getattr(obj, obj._name_to_method_translations[attr_name][0])()
	return get
		
createAttributeLookup = staticmethod(createAttributeLookup)</t>
<t tx="pap.120703001453.125"></t>
<t tx="pap.120703001453.126">@root targets\tkinter\__init__.py

pass</t>
<t tx="pap.120703001453.127">@root targets\tkinter\resource.py

import vb2py
import os
from targets.tkinter.controls import *

&lt;&lt; Event translation &gt;&gt;

class Resource(vb2py.BaseResource):
	"""Represents a Tkinter resource object"""
	
	target_name = "Tkinter"
	
	&lt;&lt; class Resource methods &gt;&gt;</t>
<t tx="pap.120703001453.128">@doc
This is the mapping between VB events and Tkinter events.
@c

event_translator = {
		"Click" : "mouseClick",
}</t>
<t tx="pap.120703001453.129">&lt;&lt; class Resource methods &gt;&gt;=

def __init__(self, *args, **kw):
	"""Initialize the PythonCard resource"""
	print "Resource init"
	vb2py.BaseResource.__init__(self, *args, **kw)
	print "After supre"
	self._rsc = eval(open("%s.txt" % self.basesourcefile, "r").read())
	self._rsc["controls"] = []
	self._code = open("%s.py" % self.basesourcefile, "r").read()
	</t>
<t tx="pap.120703001453.130">&lt;&lt; class Resource methods &gt;&gt;=

def writeToFile(self, basedir, write_code=0):
	"""Write ourselves out to a directory"""

	fle = open(os.path.join(basedir, self.name) + ".py", "w")
	
	lines = []
	for control in self._rsc['application']['backgrounds'][0]['components']:
		control

	if write_code:
		#
		# Assemble our code

		for block in self.subs + self.fns:
			lines.append('    def %s(self, %s):\n        """Sub"""' % (block.name, block.args))
			for code_line in block.code.splitlines():
				lines.append("        %s" % code_line)
			lines.append("")
		
		added_code = "\n".join(lines)
	else:
		added_code = ""
		
	fle.write(self._code.replace("# CODE_GOES_HERE", added_code))
	fle.close()
		</t>
<t tx="pap.120703001453.131">@root targets\tkinter\controls.py

twips_per_pixel = 15


&lt;&lt; SupportedControls &gt;&gt;</t>
<t tx="pap.120703001453.132">&lt;&lt; SupportedControls &gt;&gt;=

class VBControl:
	"""Base class for all VB controls"""
	
	pycard_name = "VBControl"
	is_container = 0 # 1 for container classes like frames
	
	_attribute_translations = { 
				"Visible" : "visible",
				"BackColor" : "backgroundColor",
				"ForeColor" : "foregroundColor",
				"ToolTipText" : "toolTip",
				}
	
	&lt;&lt; class VBControl methods &gt;&gt;
	

</t>
<t tx="pap.120703001453.133">&lt;&lt; class VBControl methods &gt;&gt;=

def _getPropertyList(cls):
	"""Return a list of the properties of this control"""
	items = []
	for item in dir(cls):
		if not (item.startswith("_") or item.startswith("vbobj_")):
			items.append(item)
	return items
		
_getPropertyList = classmethod(_getPropertyList)		</t>
<t tx="pap.120703001453.134">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlList(cls):
	"""Return a list of the controls contained in this control"""
	items = []
	for item in dir(cls):
		if not item.startswith("_") and item.startswith("vbobj_"):
			items.append(item)
	return items
		
_getControlList = classmethod(_getControlList)		</t>
<t tx="pap.120703001453.135">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlsOfType(cls, type_name):
	"""Return a control with a given type"""
	lst = []
	for item in dir(cls):
		if not item.startswith("_") and item.startswith("vbobj_"):
			obj = cls._get(item)
			if obj.pycard_name == type_name:
				lst.append(obj)
	return lst
		
_getControlsOfType = classmethod(_getControlsOfType)		</t>
<t tx="pap.120703001453.136">&lt;&lt; class VBControl methods &gt;&gt;=

def _getContainerControls(cls):
	"""Return all container controls"""
	lst = []
	for item in dir(cls):
		if not item.startswith("_"):
			obj = cls._get(item)
			try:
				is_container = obj.is_container
			except AttributeError:
				pass
			else:
				if is_container:
					lst.append(obj)
	return lst
		
_getContainerControls = classmethod(_getContainerControls)</t>
<t tx="pap.120703001453.137">&lt;&lt; class VBControl methods &gt;&gt;=

def _get(cls, name, default=None):
	"""Get one of our items"""
	try:
		return getattr(cls, name)
	except AttributeError:
		if default is not None:
			return default
		else:
			raise
	
_get = classmethod(_get)</t>
<t tx="pap.120703001453.138">&lt;&lt; class VBControl methods &gt;&gt;=

def _realName(cls):
	"""Return our real name"""
	return cls.__name__[6:]
	
_realName = classmethod(_realName)</t>
<t tx="pap.120703001453.139">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlEntry(cls):
	"""Return the pycard representation of this object"""
	#
	# Get dictionary entries for this object
	d = {}
	ret = [d]
	d['name'] = cls._realName()
	d['position'] = (cls.Left/twips_per_pixel, cls.Top/twips_per_pixel)
	d['type'] = cls.pycard_name
	#
	for attr, pycard_attr in cls._attribute_translations.iteritems():
		if hasattr(cls, attr):
			d[pycard_attr] = getattr(cls, attr)
			
	d.update(cls._getClassSpecificControlEntries())
	#
	# Watch out for container objects - we have to recur down them
	if cls.is_container:
		cls._processChildObjects()
		for cmp in cls._getControlList():
			obj = cls._get(cmp)
			entry = obj._getControlEntry()
			if entry:
				ret += entry
	return ret
	
_getControlEntry = classmethod(_getControlEntry)</t>
<t tx="pap.120703001453.140">&lt;&lt; class VBControl methods &gt;&gt;=

def _getClassSpecificControlEntries(cls):
	"""Return additional items for this entry
	
	This method is normally overriden in the subclass
	
	"""
	return {}
		
_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)

</t>
<t tx="pap.120703001453.141">&lt;&lt; class VBControl methods &gt;&gt;=

def _mapNameReference(cls, match):
	"""Map a reference to this object in code to something meaningful
	
	We have two issues, scope and attributes. The scope we need to map to self.components
	That was easy. But we also need to map attributes. We can't do that in the base class
	but a subclass can hopefully help us out via the _attributeTranslationClass
	
	"""
	if match.groups()[0] is not None:
		return "self.components.%s.%s" % (cls._realName(), 
										  cls._attributeTranslation(match.groups()[0]))
	else:
		return "self.components.%s" % (cls._realName(),)
		

_mapNameReference = classmethod(_mapNameReference)</t>
<t tx="pap.120703001453.142">&lt;&lt; class VBControl methods &gt;&gt;=

def _attributeTranslation(cls, name):
	"""Convert a VB attribute to a Python one"""
	try:
		return cls._attribute_translations[name]
	except KeyError:
		return VBControl._attribute_translations.get(name, name)
	
_attributeTranslation = classmethod(_attributeTranslation)	</t>
<t tx="pap.120703001453.143">&lt;&lt; class VBControl methods &gt;&gt;=

def _processChildObjects(cls):
	"""Before we deal with our child object we get a chance to do some processing
	
	Sub-classed can use this to do special things, like frames adjusting the
	properties of our children
	
	"""
	for container in cls._getContainerControls():
		container._processChildObject()
	
_processChildObjects = classmethod(_processChildObjects)</t>
<t tx="pap.120703001453.144">&lt;&lt; SupportedControls &gt;&gt;=

&lt;&lt; Controls &gt;&gt;
	
possible_controls = { 
	"VBControl" : "VBControl",
	"Form" : "Form",
	"CommandButton" : "CommandButton",
	"OptionButton" : "OptionButton",
	"TextBox" : "TextBox",
	"Label" : "Label",
	"Menu" : "Menu",
	"ComboBox" : "ComboBox",
	"ListBox" : "ListBox",
	"CheckBox" : "CheckBox",
	"Frame" : "Frame",
	
	"VBUnknownControl" : "VBUnknownControl",
	"FileListBox" : "VBUnknownControl",
	"Timer" : "VBUnknownControl",
	"OLE" : "VBUnknownControl",
	"Shape" : "VBUnknownControl",
}
</t>
<t tx="pap.120703001453.145">&lt;&lt; Controls &gt;&gt;=

class Menu(VBControl):
	"""Menu"""
	pycard_name = "Menu"
	
	def _getControlEntry(cls):
		"""Return the pycard representation of this object"""
		return {}
		
	_getControlEntry = classmethod(_getControlEntry)

	def _pyCardMenuEntry(cls):		
		"""Return the entry for this menu"""
		return {
					"type" : "Menu",
					"name" : cls._realName(),
					"label" : cls.Caption,
			 }
				
	_pyCardMenuEntry = classmethod(_pyCardMenuEntry)
</t>
<t tx="pap.120703001453.146">&lt;&lt; Controls &gt;&gt;=

class CommandButton(VBControl):
	pycard_name = "Button"
						
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "label" : cls.Caption,
				}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
	
		</t>
<t tx="pap.120703001453.147">&lt;&lt; Controls &gt;&gt;=

class ComboBox(VBControl):
	pycard_name = "ComboBox"
	
	def _getEntriesFromFRX(self, data):
		"""Get list entries from FRX file"""
		file, offset = data.split("@")
		raw = open(file, "r").read()
		ptr = int(offset, 16)
		num = ord(raw[ptr])
		ptr = ptr + 4
		lst = []
		for i in range(num):
			length = ord(raw[ptr])
			lst.append(raw[ptr+2:ptr+2+length])
			ptr += 2+length
		return lst
			
	_getEntriesFromFRX = classmethod(_getEntriesFromFRX)			
		
		
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		d = {"size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel)}
		if hasattr(cls, "List"):
			d["items"] =  cls._getEntriesFromFRX(cls.List)
		else:
			d["items"] = []
		return d
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)

		</t>
<t tx="pap.120703001453.148">&lt;&lt; Controls &gt;&gt;=

class ListBox(ComboBox):
	pycard_name = "List"
	

		</t>
<t tx="pap.120703001453.149">&lt;&lt; Controls &gt;&gt;=

class Label(VBControl):
	pycard_name = "StaticText"

	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "text" : cls.Caption,
				}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
</t>
<t tx="pap.120703001453.150">&lt;&lt; Controls &gt;&gt;=

class CheckBox(VBControl):
	pycard_name = "CheckBox"

	_attribute_translations = { 
					"Value" : "checked",
					}
	_attribute_translations.update(VBControl._attribute_translations)
					
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "label" : cls.Caption,
				  "checked" : cls._get("Value", 0),
				}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
</t>
<t tx="pap.120703001453.151">&lt;&lt; Controls &gt;&gt;=

class TextBox(VBControl):
	pycard_name = "TextField"
	
	_attribute_translations = { 
					"Text" : "text",
					}
	_attribute_translations.update(VBControl._attribute_translations)
					
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "text" : cls.Text,
				}
				
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
				
					</t>
<t tx="pap.120703001453.152">&lt;&lt; Controls &gt;&gt;=

class Form(VBControl):
	"""Form"""
	
	HeightModifier = 20 # Used to account for form borders	
	MenuHeight = 30 # Allows for menu
	Caption = "Form"
</t>
<t tx="pap.120703001453.153">&lt;&lt; Controls &gt;&gt;=

class Frame(VBControl):
	"""Frame"""
	pycard_name = "StaticBox"
	is_container = 1

	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "size" : (cls.Width/twips_per_pixel, cls.Height/twips_per_pixel),
				}
			
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
	
	
	def _processChildObjects(cls):
		"""Adjust the left and top properties of our children"""
		for item in cls._getControlList():
			obj = cls._get(item)
			print "Offsetting ", obj, cls
			if hasattr(obj, "Left"):
				obj.Left += cls.Left
			if hasattr(obj, "Top"):
				obj.Top += cls.Top
		#for container in cls._getContainerControls():
		#	container._processChildObjects()
				
	_processChildObjects = classmethod(_processChildObjects)</t>
<t tx="pap.120703001453.154">&lt;&lt; Controls &gt;&gt;=

class OptionButton(VBControl):
	pycard_name = "RadioGroup"
	
	def _getClassSpecificControlEntries(cls):
		"""Return additional items for this entry"""
		return {  "items" : cls.items,
				  "selected" : cls.selected,
				}
				
	_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)
				
	</t>
<t tx="pap.120703001453.155">&lt;&lt; Controls &gt;&gt;=

class VBUnknownControl(Label):
	"""A control representing an unknown control
	
	We fake it out as a label
	
	"""
	
	Caption = "Unknown control"</t>
<t tx="pap.120703001453.156">@root targets\tkinter\basesource.py

&lt;&lt; basesource declarations &gt;&gt;
&lt;&lt; basesource methods &gt;&gt;

if __name__ == '__main__':
    root = Tk()
	app = App(root)
	root.mainloop()
</t>
<t tx="pap.120703001453.157">@code

from Tkinter import *

#
# VB constants
True = 1
False = 0

</t>
<t tx="pap.120703001453.158">&lt;&lt; basesource methods &gt;&gt;=

class App(Frame):
	&lt;&lt; class App declarations &gt;&gt;

	# CODE_GOES_HERE</t>
<t tx="pap.120703001453.159">@code

"""The main form for the application"""


    
</t>
<t tx="pap.120703001453.160"></t>
<t tx="pap.120703001453.161">
@others</t>
<t tx="pap.120703001453.162"></t>
<t tx="pap.120703001453.163">identifier ::= 
        (safe_letter/("_", safe_letter)), (safe_letter / digit / "_")*, type_marker?
        
type_marker ::=
        "$" / "%" / "#" / "&amp;"  
  
NEWLINE ::=
        "\n"

&lt;wsp&gt; ::=
            (" "/"\t")
 
# Also includes the hack for a unicode marker
&lt;safe_letter&gt; ::= 
             letter / '~~'
             
&lt;letter&gt; ::= 
             lowercase / uppercase
  
lowercase ::= 
             [a-z]
  
uppercase ::= 
             [A-Z]
  
&lt;digit&gt; ::= 
             [0-9]

stringliteral ::=  
             '"', stringitem*, '"'
  
&lt;stringitem&gt; ::= 
             stringchar / escapeseq / '""'
  
stringchar ::= -('"' / NEWLINE)+

dateliteral ::=
			"#", integer, "/", integer, ("/", integer)?, "#"
  
escapeseq ::= 
             "\\", stringchar

longinteger ::= 
             integer, ("l" / "L")
  
integer ::= 
             "-"?, decimalinteger, ("%" / "&amp;")?
    
decimalinteger ::= 
             digit+
  
octinteger ::= 
             "0", octdigit+
  
hexinteger ::= 
             "&amp;H", hexdigit+, "&amp;"?
  
&lt;nonzerodigit&gt; ::= 
             [1-9]
  
&lt;octdigit&gt; ::= 
             [0-7]
  
&lt;hexdigit&gt; ::= 
             digit / [a-f] / [A-F]

floatnumber ::= 
             ("-"?, (exponentfloat / pointfloat)) / (integer, "#") 
  
&lt;pointfloat&gt; ::= 
             (intpart?, fraction) / (intpart, ".")
  
&lt;exponentfloat&gt; ::= 
             (pointfloat / intpart), 
              exponent
  
&lt;intpart&gt; ::= 
             digit+
  
&lt;fraction&gt; ::= 
             ".", digit+
  
&lt;exponent&gt; ::= 
             ("e" / "E"), ("+" / "-")?, digit+

atom ::= 
             object / literal
 
literal ::= 
             dateliteral / stringliteral / floatnumber / integer / longinteger / hexinteger
             
name ::= 
             identifier

colon ::=
			 wsp*, ":", wsp*
			 
hash ::=
			 "#"
</t>
<t tx="pap.120703001453.164">block ::= 
             block_content+

block_content ::=
             ?-block_terminator, line


# The inline_if_statement appears here and also as a statement because sometimes the
# implicit_call_statement in the inline_if consumes the line_end - presumably there is a way
# to prevent this and simplify what is going on here!
             
line ::= 
             (?-label_definition, line_body) / (label_definition, line_body?)
			 
line_body ::=
			 (implicit_call_statement / ((compound_statement / single_statement), (line_end / (colon, line_end?))) / inline_if_statement)


line_end ::=
             comment_statement?, NEWLINE


compound_line ::=
             block

file ::= 
             block+


block_terminator ::=
             (end_terminator / c"Else" / c"ElseIf" / c"Case" / c"Next"), (wsp+ / line_end)

end_terminator ::=
			 (c"End", wsp+, (c"If" / c"Function" / c"Subroutine")) / "END"
</t>
<t tx="pap.120703001453.165">statement ::=
               multi_statement_line / single_statement

single_statement ::=  
             ( 
               comment_statement /
               external_declaration /
               open_statement /
               on_statement /
               print_statement /
               get_statement /
               input_statement /
               line_input_statement /
               put_statement /
               call_statement /
               inline_if_statement /
               const_statement /
               dim_statement /
			   inline_for_statement /
               redim_statement /
               exit_statement /
               set_statement /
               assignment_statement /
               lset_statement /
               rset_statement /
               label_statement / 
               goto_statement /
               resume_statement /
               name_statement /
               non_vb_statement /
			   option_statement /
			   event_definition /
               close_statement /
			   end_statement /
			   seek_statement 
             )

compound_statement ::= 
             for_statement /
             for_each_statement /
             select_statement / 
             while_statement /
             do_statement /
             if_statement /
             sub_definition /
             fn_definition /
             with_statement /
             user_type_definition /
             enumeration_definition /
             property_definition /
             non_vb_block
             

multi_statement_line ::=
             ((single_statement, colon) / label_statement), (wsp+, (compound_statement / statement))?
</t>
<t tx="pap.120703001453.166">keyword ::= 
            normal_keyword / block_terminator


# NB: 'BEGIN' is case sensitive because it is not a VB keyword

normal_keyword ::=
            (
                c"Function" / c"Sub" / c"Do" / c"While" / c"Wend" / c"Loop" / c"For" / c"Next" / c"Exit" /
                c"If"  / c"Select" / c"Type" / c"Set" / c"ReDim" / c"Dim" / c"Print" / c"Open" / c"With" /
                c"Enum" / c"Property" / c"Input" / c"Close" / c"Then" / c"Else" / c"Resume" / c"To" /
                c"Public" / c"Private" / c"Static" / c"Attribute" / c"Const" / c"Option" / c"End" / 
				"Event" / c"Seek" / "BEGIN" / c"Rem" / c"Let" / c"Reset" / c"LSet" / c"RSet"
            ), (wsp / line_end)
            
</t>
<t tx="pap.120703001453.167">
expression ::= 
             (pre_named_argument?, passing_semantics?, pre_operator?, sign?, par_expression, 
             (operation, par_expression)*) / line_expression

par_expression ::= 
             point / (l_bracket, expression, r_bracket) / base_expression

base_expression ::= 
			  simple_expr, (operation, simple_expr)?
             
simple_expr ::= 
              pre_operator?, wsp*, (sign, wsp*)*, (call / atom / channelid), wsp*

l_bracket ::= 
             wsp*, "(", wsp*

r_bracket ::=
             wsp*, ")", wsp*

operation ::=
             "+" / "-" / "*" / "/" / "^" / "&amp;&amp;" / "&amp;" / "||" / "\\" / c"Not" / c"Mod" / compare

compare ::= 
             c"Or" / c"And" / c"Xor" / "=" / "&lt;=" / "&gt;=" / "&lt;&gt;" / "&lt;" / "&gt;" / c"Is" / c"Like"
             
sign ::=
            "-" / "+"                   
            
pre_named_argument ::=
            wsp*, named_argument, ":=", wsp*    
            
named_argument ::=
            identifier
			

pre_operator ::=
			pre_not / pre_typeof
			
pre_not ::=
            wsp*, c"Not", wsp+
			
pre_typeof ::=
            wsp*, c"TypeOf", wsp+			

channelid ::=
			"#", atom</t>
<t tx="pap.120703001453.168">line_expression ::=
        point, wsp*, "-", wsp*, point
        
point ::=       
        (l_bracket, expression, wsp*, ",", wsp*, expression, r_bracket)</t>
<t tx="pap.120703001453.169"></t>
<t tx="pap.120703001453.170">               
assignment_statement ::=
             (c"Let", wsp+)?, assignment_body
			 
assignment_body ::=
			 object, wsp*, "=", wsp*, expression			 

             
set_statement ::=
             c"Set", wsp+, object, wsp*, "=", new_keyword?, expression
             
new_keyword ::=
              wsp?, c"New", wsp+

object ::=
             ?-keyword, implicit_object?, (primary, ((".", attribute) / parameter_list)*) 
			 
bare_object ::=
			 ?-keyword, implicit_object?, primary, (".", attribute)*
			    
implicit_object ::=
             "."         

primary ::= 
             identifier

attribute ::=
             "["?, identifier, "]"?


lset_statement ::=
			c"LSet", wsp+, assignment_body
			
rset_statement ::=
			c"RSet", wsp+, assignment_body</t>
<t tx="pap.120703001453.171">comment_statement ::=
             wsp*, comment_start, (vb2py_directive  / comment_body)

comment_body ::=
             (stringitem / '"')*
			 
comment_start ::=
			 "'"	/ c"Rem"		 
             
             

</t>
<t tx="pap.120703001453.172">external_declaration ::=
        (scope, wsp+)?, c"Declare", wsp+, (c"Sub" / c"Function"), wsp+, identifier, wsp+, c"Lib", wsp+, 
        stringliteral, wsp+, (c"Alias", wsp+, stringliteral, wsp+)?, formal_param_list, type_definition?
        
        
        
</t>
<t tx="pap.120703001453.173">label_definition ::=
        label_statement, (wsp+ / line_end)

label_statement ::=
        (label, ":") / decimalinteger

label ::=
        (identifier / decimalinteger)
                
goto_statement ::=
        c"GoTo", wsp+, label</t>
<t tx="pap.120703001453.174">dim_statement ::=
  unscoped_dim / scoped_dim

unscoped_dim ::=
  c"Dim", wsp+, basic_dim

scoped_dim ::=
  scope, wsp+, (c"Dim", wsp+)?, basic_dim
   
basic_dim ::=
  object_definition, (",", wsp*, object_definition)*

object_definition ::=
  with_events?, bare_object, (unsized_definition / size_definition)?, type_definition?
  
  
const_statement ::=
             (scope, wsp+)?, c"Const", wsp+, const_definition, (",", wsp*, const_definition)*
             
const_definition ::=
             identifier, type_definition?, wsp*, "=", wsp*, expression             

            
type_definition ::=
             (wsp+, c"As", wsp+, new_keyword?, type, array_indicator?, string_size_definition?, wsp*)

unsized_definition ::=
			"(", wsp*, ")"
			
size_definition ::=
             "(", (size_range / size)?, (",", wsp*, (size_range / size))*, ")"

size ::=
             expression
             
size_range ::=
             size, wsp*, c"To", wsp*, size            

type ::=
             primary, (".", attribute)*

scope ::=
             c"Global" / c"Private" / c"Public" / c"Static" / c"Friend"

value ::= 
             literal

redim_statement ::=
             c"ReDim", wsp+, preserve_keyword?, basic_dim
             
preserve_keyword ::=
             c"Preserve", wsp+
             
array_indicator ::=
              wsp*, "()"
			  
string_size_definition ::=
			  wsp*, "*", wsp*, string_size_indicator	
			  
string_size_indicator ::=
			  atom
			  
with_events ::=
			  wsp*, c"WithEvents", wsp+
</t>
<t tx="pap.120703001453.175">on_statement ::=
        (on_error_goto / on_error_resume / on_goto)
    
on_error_goto ::=
        on_error, c"GoTo", wsp+, label
        
on_error_resume ::=
        on_error, c"Resume", wsp+, c"Next"        
        
on_goto ::=
        on_variable, c"GoTo", wsp+, bare_list        

on_error ::= 
        label_definition?, c"On", wsp+, local?, c"Error", wsp+
        
on_variable ::= 
        label_definition?, c"On", wsp+, expression
		
local ::=
		c"Local", wsp+		
</t>
<t tx="pap.120703001453.176">print_statement ::= 
        label_statement?, c"Print", (wsp+, channel_id, wsp*, ",", wsp*)?, print_list?
        
channel_id ::=
        "#", expression     
        
hold_cr ::=
        ";"
        
get_statement ::=
        label_statement?, c"Get", wsp+, channel_id, wsp*, bare_list

input_statement ::=
        label_statement?, c"Input", wsp+, channel_id, wsp*, bare_list
        
line_input_statement ::=
        label_statement?, c"Line", wsp+, input_statement
        
put_statement ::=
        label_statement?, c"Put", wsp+, channel_id, wsp*, bare_list, hold_cr?

print_list ::=
        wsp*, print_separator*, (expression, wsp*, print_separator*, wsp*)*
        
print_separator ::=
        "," / ";"</t>
<t tx="pap.120703001453.177">seek_statement ::=
			label_statement?, c"Seek", wsp+, channel_id, wsp*, ",", wsp*, expression
</t>
<t tx="pap.120703001453.178">open_statement ::=
        label_definition?, c"Open", wsp+, filename, c"For", wsp+, open_mode+, c"As", wsp+, "#"?, channel
        
filename ::=
        expression
        
channel ::=
        expression
        
open_mode ::=
        ?-c"As", identifier, wsp+
        
close_statement ::=
        label_definition?, (c"Close" / c"Reset"), (wsp+, channel_number, (",", wsp*, channel_number)*)?

channel_number ::=
		(channel_id   / expression)</t>
<t tx="pap.120703001453.179">
call_statement ::=
            label_definition?, (c"Call", wsp+, object, list?) 
  
implicit_call_statement ::=
            label_definition?, ?-keyword, (simple_expr, bare_list, (line_end / colon))

inline_implicit_call ::=
            label_definition?, ?-keyword, (simple_expr, bare_list)

list ::= 
             "(", bare_list, ")"

bare_list ::=
#             (wsp*, bare_list_item?, (list_separator, wsp*, bare_list_item?)*)?
              (wsp*, positional_item*, bare_list_item?)

call ::=
             ?-keyword, object, parameter_list?

positional_item ::=
             (bare_list_item / missing_positional), list_separator
             
missing_positional ::=
             wsp*             
             
bare_list_item ::=
			 addressof?, expression

addressof ::=
			 c"AddressOf", wsp+
						 
list_separator ::=
        "," / ";"			 </t>
<t tx="pap.120703001453.180">resume_statement ::=
        label_definition?, c"Resume", (wsp+, resume_location)?
        
resume_location ::=
        c"Next" / label
</t>
<t tx="pap.120703001453.181">             
exit_statement ::=
             c"Exit", wsp+, (c"Sub" / c"Function" / c"For" / c"Do" / c"Loop" / c"Property")

</t>
<t tx="pap.120703001453.182">name_statement ::=
        label_definition?, c"Name", wsp+, expression, c"As", expression</t>
<t tx="pap.120703001453.183">end_statement ::=
        c"End"</t>
<t tx="pap.120703001453.184">event_definition ::=
			label_statement?, (scope, wsp+)?, c"Event", wsp+, object, formal_param_list?</t>
<t tx="pap.120703001453.185"></t>
<t tx="pap.120703001453.186">while_statement ::=
                c"While", wsp+, expression, line_end, block, label_definition?, (c"End While" / c"Wend")

do_statement ::=
                c"Do", (while_clause / until_clause)?, line_end, block, 
                label_definition?, c"Loop", (post_until_clause / post_while_clause)?

while_clause ::=
                (wsp+, c"While", wsp+, expression)
                
until_clause ::=
                (wsp+, c"Until", wsp+, expression)
                
post_until_clause ::=
                until_clause                
                
post_while_clause ::=
                while_clause</t>
<t tx="pap.120703001453.187">select_statement ::=
                c"Select", wsp+, c"Case", wsp+, expression, line_end,
				case_comment_block?,
                case_item_block*,
                case_else_block?,
                label_definition?, c"End Select"

case_item_block ::=
                label_definition?, c"Case", wsp+, case_list, case_body

case_else_block ::=
                label_definition?, c"Case", wsp+, c"Else", case_body

case_body ::=
				(colon, line_end, block?) / ((line_end / colon), block?) 

case_list ::=
                 ?-c"Else", (case_expression, (",", case_expression)*)?

case_expression ::=
                  expression, (to_keyword, expression)?
                 
to_keyword ::= 
                  c"To"
				  
case_comment_block ::=
				  block</t>
<t tx="pap.120703001453.188">inline_if_statement ::= 
             label_definition?, hash?, c"If", condition, hash?, c"Then", wsp+, inline_if_block,
             (wsp*, hash?, c"Else", wsp+, inline_else_block)?

if_statement ::= 
             hash?, c"If", condition, hash?, c"Then", line_end, if_block?, 
             else_if_statement*,
             else_statement?,
             label_definition?, hash?, c"End If"

if_block ::= 
             block

else_if_statement ::=
             (label_definition?, hash?, c"ElseIf", condition, hash?, c"Then", line_end, else_if_block?)

else_statement ::=
             (label_definition?, hash?, c"Else", wsp*, line_end, else_block?)

else_block ::= block
else_if_block ::= block
condition ::= expression

inline_if_block ::=
			  ?-comment_statement, inline_block

inline_else_block ::=
			  inline_block
			  
inline_block ::=
              (statement / inline_implicit_call)
			  
			  
</t>
<t tx="pap.120703001453.189">for_statement ::=
                c"For", wsp+, object, wsp*, "=", wsp*, 
                expression, c"To", wsp+, expression, for_stepping?, line_end,
                block?,
                label_definition?, c"Next", (wsp+, object)?

for_stepping ::=
                c"Step", expression

for_each_statement ::=
                c"For", wsp+, c"Each", wsp+, object, wsp*, c"In", wsp+, 
                expression, line_end,
                block?,
                label_definition?, c"Next", (wsp+, object)?
				
inline_for_statement ::=				
                c"For", wsp+, object, wsp*, "=", wsp*,
				expression, c"To", wsp+, expression, for_stepping?, 
				colon, body, c"Next", (wsp+, object)?	
				
body ::=
			    (implicit_call_statement / (single_statement, colon))*</t>
<t tx="pap.120703001453.190">sub_definition ::=
             label_definition?, (scope, wsp*)?, (static, wsp*)?, c"Sub", wsp+, identifier, wsp*,
             formal_param_list, line_end, block?, label_definition?, c"End Sub"

formal_param_list ::=
             "(", wsp*, formal_param?, (wsp*, ",", wsp*, formal_param)*, ")"

formal_param ::=
             optional?, passing_semantics?, (object / identifier), array_indicator?, type_definition?, default_value?

optional ::=
             c"Optional", wsp+
             
passing_semantics ::=
             (c"ByVal" / c"ByRef"), wsp+           
             
parameter_list ::=
             list
             
fn_definition ::=
             label_definition?, (scope, wsp*)?, c"Function", wsp+, identifier, wsp*,
             formal_param_list, type_definition?, line_end, block?, label_definition?, c"End Function"
             
default_value ::=
            wsp*, "=", expression            


static ::=
			"Static"

</t>
<t tx="pap.120703001453.191">property_definition ::=
             label_definition?, (scope, wsp*)?, c"Property", wsp+, property_decorator_type, wsp+, identifier, 
             formal_param_list, type_definition?, line_end, block?, label_definition?, c"End Property"

property_decorator_type ::=
             c"Get" / c"Set" / c"Let"</t>
<t tx="pap.120703001453.192">user_type_definition ::=
             (scope, wsp+)?, c"Type", wsp+, identifier, line_end, ((object_definition / comment_statement), line_end)*, label_definition?, c"End Type"
</t>
<t tx="pap.120703001453.193">with_statement ::=
    label_definition?, c"With", wsp+, expression, line_end, block?, label_definition?, c"End With"</t>
<t tx="pap.120703001453.194">enumeration_definition ::=
        (scope, wsp+)?, c"Enum", wsp, identifier, line_end, (enumeration_item, line_end)*, c"End Enum"
        
enumeration_item ::=
        ?-c"End", identifier, (wsp*, "=", wsp*, expression)?</t>
<t tx="pap.120703001453.195">non_vb_statement ::=
        class_header_statement / attribute_statement
    
non_vb_block ::=
        class_header_block</t>
<t tx="pap.120703001453.196">class_header_statement ::=
        c"VERSION", wsp+, floatnumber, wsp+, c"CLASS"
        
class_header_block ::=
        "BEGIN", line_end, block, "END"</t>
<t tx="pap.120703001453.197">vb2py_directive ::=
            wsp*, c"VB2PY-", directive_type, wsp*, ":", wsp*, directive_body
            
directive_type ::=
            identifier
            
directive_body ::=
            config_section, ".", config_name, wsp*, ("=", wsp*, expression)?
            
config_section ::= identifier
config_name ::= identifier</t>
<t tx="pap.120703001453.198">attribute_statement ::=
        c"Attribute", wsp+, object, wsp*, "=", wsp*, expression, (wsp*, ",", wsp*, expression)*</t>
<t tx="pap.120703001453.199">option_statement ::=
		c"Option", wsp+, atom, (wsp*, atom)*, comment_statement?
</t>
<t tx="pap.120703001453.200">@root vbparser.py

"""Main parsing and conversion routines for translating VB to Python code"""

&lt;&lt; Imports &gt;&gt;
&lt;&lt; Error Classes &gt;&gt;
&lt;&lt; Definitions &gt;&gt;

&lt;&lt; Utility functions &gt;&gt;

# The following imports must go at the end to avoid import errors 
# caused by poor structuring of the package. This needs to be refactored!

# Plug-ins
import extensions
plugins = extensions.loadAllPlugins()

from parserclasses import *

if __name__ == "__main__":	
	from testparse import txt
	m = parseVB(txt)
	
</t>
<t tx="pap.120703001453.201">@c

#
# Configuration options
import config
Config = config.VB2PYConfig()

from pprint import pprint as pp
from simpleparse.common import chartypes
import sys
import os
import re
import utils

declaration = open(utils.relativePath("vbgrammar.txt"), "r").read()

from simpleparse.parser import Parser

import logger
log = logger.getLogger("VBParser")

</t>
<t tx="pap.120703001453.202">@c

class VBParserError(Exception): 
	"""An error occured during parsing"""

class UnhandledStructureError(VBParserError): 
	"""A structure was parsed but could not be handled by class"""
class InvalidOption(VBParserError): 
	"""An invalid config option was detected"""
class NestingError(VBParserError): 
	"""An error occured while handling a nested structure"""
class UnresolvableName(VBParserError):
	"""We were asked to resolve a name but couldn't because we don't know it"""
	
class SystemPluginFailure(VBParserError): 
	"""A system level plugin failed"""

class DirectiveError(VBParserError): 
	"""An unknown directive was found"""
</t>
<t tx="pap.120703001453.203">@c

pass
</t>
<t tx="pap.120703001453.204"></t>
<t tx="pap.120703001453.205">&lt;&lt; Utility functions &gt;&gt;=

def convertToElements(details, txt):
	"""Convert a parse tree to elements"""
	ret = []
	if details:
		for item in details:
			ret.append(VBElement(item, txt))
	return ret</t>
<t tx="pap.120703001453.206">&lt;&lt; Utility functions &gt;&gt;=

def buildParseTree(vbtext, starttoken="line", verbose=0, returnpartial=0, returnast=0):
	"""Parse some VB"""

    &lt;&lt; Build Parser &gt;&gt;

	txt = applyPlugins("preProcessVBText", vbtext)

    txt = makeSafeFromUnicode(txt)
    
	nodes = []
	while 1:
		success, tree, next = parser.parse(txt) 
		if not success:
			if txt.strip():
				&lt;&lt; Handle failure &gt;&gt;
			break
		if verbose:
			print success, next
			pp(tree)
			print "."
		if not returnast:
            nodes.extend(convertToElements(tree, txt))
        else:
            nodes.append(tree)
		txt = txt[next:]
		
	return nodes	</t>
<t tx="pap.120703001453.208">@c

msg = "Parsing error: %d, '%s'" % (next, txt.split("\n")[0])
if returnpartial:
	log.error(msg)
	nodes.append(VBFailedElement('parser_failure', msg))
	break
else:
	raise VBParserError(msg)

</t>
<t tx="pap.120703001453.209">&lt;&lt; Utility functions &gt;&gt;=

def parseVB(vbtext, container=None, starttoken="line", verbose=0, returnpartial=None):
	"""Parse some VB"""
	
	if returnpartial is None:
		returnpartial = Config["General", "ReportPartialConversion"] == "Yes"
		
	nodes = buildParseTree(vbtext, starttoken, verbose, returnpartial)
	
	if container is None:
		m = VBModule()
	else:
		m = container
	
	for idx, node in zip(xrange(sys.maxint), nodes):
		if verbose:
			print idx,
		try:
			m.processElement(node)
		except UnhandledStructureError:
			log.warn("Unhandled: %s\n%s" % (node.structure_name, node.text))
			
	return m
	




</t>
<t tx="pap.120703001453.210">&lt;&lt; Utility functions &gt;&gt;=

def renderCodeStructure(structure):
	"""Render a code structure as Python
	
	We have this as a separate function so that we can apply the plugins
	
	"""
	return applyPlugins("postProcessPythonText", structure.renderAsCode())	
</t>
<t tx="pap.120703001453.211">&lt;&lt; Utility functions &gt;&gt;=

def convertVBtoPython(vbtext, *args, **kw):
	"""Convert some VB text to Python"""
	m = parseVB(vbtext, *args, **kw)
	return applyPlugins("postProcessPythonText", m.renderAsCode())</t>
<t tx="pap.120703001453.212">&lt;&lt; Utility functions &gt;&gt;=

def applyPlugins(methodname, txt):
    """Apply the method of all active plugins to this text"""
    use_user_plugins = Config["General", "LoadUserPlugins"] == "Yes"
    for plugin in plugins:
        if plugin.isEnabled() and plugin.system_plugin or use_user_plugins:
            try:
                txt = getattr(plugin, methodname)(txt)	
            except Exception, err:
                if plugin.system_plugin:
                    raise SystemPluginFailure(
                        "System plugin '%s' had an exception (%s) while doing %s. Unable to continue" % (
                            plugin.name, err, methodname))
                else:                        
                    log.warn("Plugin '%s' had an exception (%s) while doing %s and will be disabled" % (
                            plugin.name, err, methodname))
                    plugin.disable()
    return txt
</t>
<t tx="pap.120703001453.213">&lt;&lt; Utility functions &gt;&gt;=

def parseVBFile(filename, text=None, parent=None, **kw):
	"""Parse some VB from a file"""
    if not text:
        &lt;&lt; Get text &gt;&gt;
    &lt;&lt; Choose appropriate container &gt;&gt;
    new_container=container()
    if parent:
        new_container.parent = parent
    code_structure = parseVB(text, container=new_container, **kw)
    return code_structure
</t>
<t tx="pap.120703001453.214">@c

f = open(filename, "r")
try:
    text = f.read()
finally:
    f.close()</t>
<t tx="pap.120703001453.215">@c

# Type of container to use for each extension type
container_lookup = {
        ".bas" : VBCodeModule,
        ".cls" : VBClassModule,
        ".frm" : VBFormModule,
}

extension = os.path.splitext(filename)[1]
try:
    container = container_lookup[extension.lower()]
except KeyError:
    log.warn("File extension '%s' not recognized, using default container", extension)
    container = VBCodeModule
    
</t>
<t tx="pap.120703001453.216">@root parserclasses.py

"""A set of classes used during the parsing of VB code"""

&lt;&lt; Definitions &gt;&gt;
&lt;&lt; Classes &gt;&gt;

from vbparser import *

# Blocks which do not contain valid statements
# If a block contains only these then it needs a pass
# statement to be a valid Python suite
NonCodeBlocks = (VBComment, VBUnrendered, VB2PYDirective) </t>
<t tx="pap.120703001453.217">@c

StopSearch = -9999 # Used to terminate searches for parent properties

</t>
<t tx="pap.120703001453.218"></t>
<t tx="pap.120703001453.219">&lt;&lt; Classes &gt;&gt;=

class VBElement(object):
	"""An element of VB code"""
	
	&lt;&lt; VBElement methods &gt;&gt;</t>
<t tx="pap.120703001453.220">&lt;&lt; VBElement methods &gt;&gt;=

def __init__(self, details, text):
	"""Initialize from the details"""
    #import pdb; pdb.set_trace()
	self.name = details[0]
	self.text = makeUnicodeFromSafe(text[details[1]:details[2]])
	self.elements = convertToElements(details[3], text)</t>
<t tx="pap.120703001453.221">&lt;&lt; VBElement methods &gt;&gt;=

def printTree(self, offset=0):
	"""Print out this tree"""
	print "%s%s : '%s'" % (" "*offset, self.name, self.text.split("\n")[:20])
	for subelement in self.elements:
		subelement.printTree(offset+1)
		</t>
<t tx="pap.120703001453.222">&lt;&lt; Classes &gt;&gt;=

class VBFailedElement(object):
	"""An failed element of VB code"""
	
	&lt;&lt; VBFailedElement methods &gt;&gt;</t>
<t tx="pap.120703001453.223">&lt;&lt; VBFailedElement methods &gt;&gt;=

def __init__(self, name, text):
	"""Initialize from the details"""
	self.name = name
	self.text = text
	self.elements = []</t>
<t tx="pap.120703001453.224">&lt;&lt; Classes &gt;&gt;=

class VBNamespace(object):
	"""Handles a VB Namespace"""
	
	&lt;&lt; VBNamespace declarations &gt;&gt;
	&lt;&lt; VBNamespace methods &gt;&gt;</t>
<t tx="pap.120703001453.225">@c

auto_handlers = []
auto_class_handlers = None

#
# Skip handlers are automatically by-passed. This is useful for quickly ignoring a 
# handler in a base class
skip_handlers = []

#
# Used to translate () into [] under certain circumstances (LHS of an assign)
brackets_are_indexes = 0


default_scope = "Private"

# 
# Set this to 1 if the object is a function (ie requires () when accessing)
is_function = 0

#
# Set to 1 for types which would mark the end of the docstrings
would_end_docstring = 1


#
# Intrinsic VB functions - we need to know these to be able to convert
# bare references (eg Dir) to function references (Dir())
intrinsic_functions = [
    "Dir", "FreeFile", "Rnd", "Timer",
]
</t>
<t tx="pap.120703001453.226">&lt;&lt; VBNamespace methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the namespace"""
	self.locals = []
	self.local_default_scope = self.default_scope
	self.auto_class_handlers = {
		"object_definition" : (VBVariableDefinition, self.locals),
		"const_definition"   : (VBConstant, self.locals),
		"user_type_definition" : (VBUserType, self.locals),
		"event_definition" : (VBUnrendered, self.locals),
	}
	#
	# This dictionary stores names which are to be substituted if found 
	self.name_substitution = {}

	&lt;&lt; Get indenting options &gt;&gt;		


</t>
<t tx="pap.120703001453.227">@c

char_spec = Config["General", "IndentCharacter"]
if char_spec == "Space":
	self._indent_char = " "
elif char_spec == "Tab":
	self._indent_char = "\t"
else:
	raise InvalidOption("Indent character option not understood: '%s'" % char_spec)
	
self._indent_amount = int(Config["General", "IndentAmount"])</t>
<t tx="pap.120703001453.228"></t>
<t tx="pap.120703001453.229">&lt;&lt; VBNamespace methods &gt;&gt;=

def processElement(self, element):
	"""Process our tree"""
	handler = self.getHandler(element)
	if handler:
		handler(element)
	else:
		if element.elements:
			for subelement in element.elements:
				self.processElement(subelement)
	    else:
		    log.info("Unhandled element '%s' from %s\n%s" % (element.name, self, element.text))
		
</t>
<t tx="pap.120703001453.230">&lt;&lt; VBNamespace methods &gt;&gt;=

def getHandler(self, element):
	"""Find a handler for the element"""
	if element.name in self.skip_handlers:
		return None
	elif element.name in self.auto_handlers:
		log.info("Found auto handler for '%s' ('%s')" % (element.name, self))
		return self.createExtractHandler(element.name)
	elif element.name in self.auto_class_handlers:
		log.info("Found auto handler for '%s' ('%s')" % (element.name, self))
		&lt;&lt; Create class handler &gt;&gt;
	try:
		return getattr(self, "handle_%s" % element.name)
	except AttributeError:
		return None



</t>
<t tx="pap.120703001453.231">@c

obj_class, add_to = self.auto_class_handlers[element.name]

if obj_class == self.__class__:
	# Ooops, recursive handling - we should handle the sub elements
	def class_handler(element):
		for sub_element in element.elements:
			self.handleSubObject(sub_element, obj_class, add_to)
else:	
	def class_handler(element):
		self.handleSubObject(element, obj_class, add_to)
		
return class_handler
</t>
<t tx="pap.120703001453.232">&lt;&lt; VBNamespace methods &gt;&gt;=

def createExtractHandler(self, token):
	"""Create a handler which will extract a certain token value"""
	def handler(element):
		log.info("Grabbed attribute '%s' for %s as '%s'" % (token, self, element.text))
		setattr(self, token, element.text)
	return handler
		
</t>
<t tx="pap.120703001453.233">&lt;&lt; VBNamespace methods &gt;&gt;=

def asString(self):
	"""Convert to a nice representation"""
	return repr(self)</t>
<t tx="pap.120703001453.234">&lt;&lt; VBNamespace methods &gt;&gt;=

def assignParent(self, parent):
    """Set our parent

        This is kept as a separate method because it is a useful hook for subclasses.
        Once this method is called, the object is fully initialized.

        """
    self.parent = parent</t>
<t tx="pap.120703001453.235">&lt;&lt; VBNamespace methods &gt;&gt;=

def finalizeObject(self):
    """Finalize the object

        This method is called once the object has been completely parsed and can
        be used to do any processing required.

        """</t>
<t tx="pap.120703001453.236">&lt;&lt; VBNamespace methods &gt;&gt;=

def handleSubObject(self, element, obj_class, add_to):
	"""Handle an object which creates a sub object"""
	v = obj_class(self.local_default_scope)
	v.processElement(element)
    v.assignParent(self)
	v.finalizeObject()
	#
	# Assume that we are supposed to add this to a list of items
	# if this fails then perhaps this is an attribute we are supposed to set
	try:
		add_to.append(v)	
	except AttributeError:
		setattr(self, add_to, v)
	#
	log.info("Added new %s to %s" % (obj_class, self.asString()))

</t>
<t tx="pap.120703001453.237">&lt;&lt; VBNamespace methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return self.getIndent(indent) + "# Unrendered object %s\n" % (self.asString(), )</t>
<t tx="pap.120703001453.238">&lt;&lt; VBNamespace methods &gt;&gt;=

def getParentProperty(self, name, default=None):
	"""Get a property from our nearest ancestor who has it"""
	try:
		return getattr(self, name)
	except AttributeError:
		try:
			parent = self.parent
			return parent.getParentProperty(name)
		except AttributeError:
            if default is not None:
                return default
			raise NestingError("Reached outer level when trying to access a parent property: '%s'" % name)			</t>
<t tx="pap.120703001453.239">&lt;&lt; VBNamespace methods &gt;&gt;=

def searchParentProperty(self, name):
    """Search for any ancestor who has the named parameter set to true

        Stop searching if someone has the property set to StopSearch

        """
    try:
        if getattr(self, name) == StopSearch:
            return 0
        elif getattr(self, name):
            return 1
    except AttributeError:
        pass
    try:
        parent = self.parent
        return parent.searchParentProperty(name)
    except AttributeError:
        return 0			</t>
<t tx="pap.120703001453.240">&lt;&lt; VBNamespace Methods &gt;&gt;=

def findParentOfClass(self, cls):
    """Return our nearest parent who is a subclass of cls"""
    try:
        parent = self.parent
    except AttributeError:
        raise NestingError("Reached outer layer when looking for parent of class")
    if isinstance(parent, cls):
        return parent
    else:
        return parent.findParentOfClass(cls)</t>
<t tx="pap.120703001453.241">&lt;&lt; VBNamespace methods &gt;&gt;=

def getLocalNameFor(self, name):
    """Get the local version of a name

        We look for any ancestor with a name conversion in operation for this name and
        return the first one that has it. If there are none then we just use the name

        """
    try:
        return self.name_substitution[name]
    except KeyError:
        try:
            return self.parent.getLocalNameFor(name)
        except AttributeError:
            return name</t>
<t tx="pap.120703001453.242">&lt;&lt; VBNamespace methods &gt;&gt;=

def getIndent(self, indent):
	"""Return some spaces to do indenting"""
    return self._indent_char*indent*self._indent_amount
	
</t>
<t tx="pap.120703001453.243">&lt;&lt; VBNamespace methods &gt;&gt;=

def getWarning(self, warning_type, text, indent=0, crlf=0):
	"""Construct a warning comment"""
    ret = "%s# %s (%s) %s" % (
			self.getIndent(indent),
			Config["General", "AttentionMarker"],
			warning_type,
			text)
	if crlf:
		ret += "\n"
	return ret			</t>
<t tx="pap.120703001453.244">&lt;&lt; VBNamespace methods &gt;&gt;=

def checkOptionChoice(self, section, name, choices):
    """Return the index of a config option in a list of choices

        We return the actual choice name which may seem odd but is done to make
        the code readable. The main purpose of this method is to allow the choice
        to be selected with the error trapping hidden.

        """
    value = Config[section, name]
    try:
        return choices[list(choices).index(value)]
    except ValueError:
        raise InvalidOption("Invalid option for %s.%s, must be one of %s" % (
                                    section, name, choices))
</t>
<t tx="pap.120703001453.245">&lt;&lt; VBNamespace methods &gt;&gt;=

def checkOptionYesNo(self, section, name):
	"""Return the yes/no value of an option checking for invalid answers"""
	return self.checkOptionChoice(section, name, ("Yes", "No"))
</t>
<t tx="pap.120703001453.246">&lt;&lt; VBNamespace methods &gt;&gt;=

def resolveName(self, name, rendering_locals=None, requestedby=None):
    """Convert a local name to a fully resolved name

        We traverse up through the nested namespaces until someone knows
        what to do with the name. If nobody knows then we know if must be
        a local so it keeps the same name.

        """
    if rendering_locals is None:
        rendering_locals = self.getParentProperty("rendering_locals")
    if not requestedby:
        requestedby = self		
    try:
        return self.resolveLocalName(name, rendering_locals, requestedby=requestedby)
    except UnresolvableName:
        try:
            return self.parent.resolveName(name, rendering_locals, requestedby=requestedby)
        except AttributeError:
            return name	# Nobody knew the name so it must be local
		</t>
<t tx="pap.120703001453.247">&lt;&lt; VBNamespace methods &gt;&gt;=

def resolveLocalName(self, name, rendering_locals=0, requestedby=None):
	"""Convert a local name to a fully resolved name"""
	raise UnresolvableName("Name '%s' is not known in this namespace" % name)
		</t>
<t tx="pap.120703001453.248">&lt;&lt; VBNamespace methods &gt;&gt;=

def amGlobal(self, scope):
    """Decide if a variable will be considered a global

        The algorithm works by asking our parent for a 'public_is_global' flag. If this
        is true and the scope is either 'public' or 'global' then we are a global. It is
        up to each parent to decide if publics are global. Things like code modules will have this
        set whereas things like subroutines will not.

        """
    #
    # First throw out anything which is private
    log.info("Checking if global: '%s' scope is '%s'" % (self, scope))
    if scope in ("Public", "Global"):
        if self.getParentProperty("public_is_global", 0):
            log.info("We are global!")
            return 1
    return 0
</t>
<t tx="pap.120703001453.249">&lt;&lt; VBNamespace methods &gt;&gt;=

def registerAsGlobal(self):
    """Register ourselves as a global object

        We try to add ourselves to our parents "global_objects" table. This may fail
        if we are not owned by anything that has a global_obects table, as would be
        the case for converting a simple block of text.

        """
    try:
        global_objects = self.getParentProperty("global_objects")
    except NestingError:
        log.warn("Tried to register global object but there was no suitable object table")
    else:
        global_objects[self.identifier] = self
        log.info("Registered a new global object: '%s'" % self)</t>
<t tx="pap.120703001453.250">&lt;&lt; VBNamespace methods &gt;&gt;=

def registerImportRequired(self, modulename):
    """Register a need to import a certain module

        When we need to use a variable from another module we need to tell our module-like
        containner to add an 'import' statement. So we search for such a container and try
        to add the module name to the import list.

        It is possible (but unlikely) that we need the import but we are not in a container.
        If this happens we just warning and carry on.

        """
    try:
        module_imports = self.getParentProperty("module_imports")
    except NestingError:
        log.warn("Tried to request a module import (%s) but couldn't find a suitable container" % modulename)
    else:
        if modulename not in module_imports:
            module_imports.append(modulename)
        log.info("Registered a new module import: '%s'" % modulename)
</t>
<t tx="pap.120703001453.251">&lt;&lt; VBNamespace methods &gt;&gt;=

def containsStatements(self):
    """Check if we contain statements"""
    #
    # TODO: This needs refactoring - it is horrible
    if isinstance(self, NonCodeBlocks):
        return 0
    if not hasattr(self, "blocks"):
        return 1
    elif self.blocks:
        for item in self.blocks:
            if item.containsStatements():
                return 1
        return 0
    else:
        return 1
</t>
<t tx="pap.120703001453.252">&lt;&lt; VBNamespace methods &gt;&gt;=

def isAFunction(self, name):
    """Check if the name is a function or not

        We traverse up through the nested namespaces until someone knows
        the name and then see if they are a function.

        """
    if name in self.intrinsic_functions:
        return 1
    try:
        return self.checkIfFunction(name)
    except UnresolvableName:
        try:
            return self.parent.isAFunction(name)
        except (AttributeError, UnresolvableName):
            return 0	# Nobody knew the name so we can't know if it is or not</t>
<t tx="pap.120703001453.253">&lt;&lt; VBNamespace methods &gt;&gt;=

def checkIfFunction(self, name):
	"""Check if the name is a function or not"""
	for loc in self.locals:
		if loc.identifier == name:
			return loc.is_function
	raise UnresolvableName("Name '%s' is not known in this context" % name)
		</t>
<t tx="pap.120703001453.254"></t>
<t tx="pap.120703001453.255">&lt;&lt; VBNamespace methods &gt;&gt;=

def handle_scope(self, element):
	"""Handle a scope definition"""
	self.local_default_scope = element.text
	log.info("Changed default scope to %s" % self.local_default_scope)</t>
<t tx="pap.120703001453.256">&lt;&lt; VBNamespace methods &gt;&gt;=

def handle_line_end(self, element):
	"""Handle the end of a line"""
	self.local_default_scope = self.default_scope
</t>
<t tx="pap.120703001453.257">&lt;&lt; Classes &gt;&gt;=

class VBConsumer(VBNamespace):
	"""Consume and store elements"""
	
	def processElement(self, element):
		"""Eat this element"""
		self.element = element
		log.info("Consumed element: %s" % element)
</t>
<t tx="pap.120703001453.258">&lt;&lt; Classes &gt;&gt;=

class VBUnrendered(VBConsumer):
	"""Represents an unrendered statement"""
	
	would_end_docstring = 0 
	
	def renderAsCode(self, indent):
		"""Render the unrendrable!"""
		if self.checkOptionYesNo("General", "WarnAboutUnrenderedCode") == "Yes":
			return self.getWarning("UntranslatedCode", self.element.text.replace("\n", "\\n"), indent, crlf=1)
		else:
			return ""
</t>
<t tx="pap.120703001453.259">&lt;&lt; Classes &gt;&gt;=

class VBMessage(VBUnrendered):
	"""Allows a message to be placed in the python output"""
	
	def __init__(self, scope="Private", message="No message", messagetype="Unknown"):
		"""Initialise the message"""
		super(VBMessage, self).__init__(scope)
		self.message = message
		self.messagetype = messagetype
		
	def renderAsCode(self, indent=0):
		"""Render the message"""
		return self.getWarning(self.messagetype, 
							   self.message, indent, crlf=1)</t>
<t tx="pap.120703001453.260">&lt;&lt; Classes &gt;&gt;=

class VBMissingArgument(VBConsumer):
	"""Represents an missing argument"""
	
	def renderAsCode(self, indent=0):
		"""Render the unrendrable!"""
		return "VBMissingArgument"</t>
<t tx="pap.120703001453.261">&lt;&lt; Classes &gt;&gt;=

class VBCodeBlock(VBNamespace):
	"""A block of VB code"""
	
	&lt;&lt; VBCodeBlock methods &gt;&gt;
</t>
<t tx="pap.120703001453.262">&lt;&lt; VBCodeBlock methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the block"""
	super(VBCodeBlock, self).__init__()
	self.blocks = []
	self.auto_class_handlers.update({
		"assignment_statement" : (VBAssignment, self.blocks),
		"lset_statement" : (VBLSet, self.blocks),
		"rset_statement" : (VBRSet, self.blocks),
		"set_statement" : (VBSet, self.blocks),
		"comment_body" : (VBComment, self.blocks),
		"vb2py_directive" : (VB2PYDirective, self.blocks),
		"if_statement" : (VBIf, self.blocks),
		"inline_if_statement" : (VBInlineIf, self.blocks),
		"select_statement" : (VBSelect, self.blocks),
		"exit_statement" : (VBExitStatement, self.blocks),
		"while_statement" : (VBWhile, self.blocks),
		"do_statement" : (VBDo, self.blocks),
		"redim_statement" : (VBReDim, self.blocks),
		"implicit_call_statement" : (VBCall, self.blocks),
		"inline_implicit_call" : (VBCall, self.blocks),
		"label_statement" : (VBLabel, self.blocks),
		"with_statement" : (VBWith, self.blocks),
		"end_statement" : (VBEnd, self.blocks),
		
		"for_statement" : (VBFor, self.blocks),
		"inline_for_statement" : (VBFor, self.blocks),
		"for_each_statement" : (VBForEach, self.blocks),

		"open_statement" : (VBOpen, self.blocks),
		"close_statement" : (VBClose, self.blocks),
		"input_statement" : (VBInput, self.blocks),
		"print_statement" : (VBPrint, self.blocks),
		"line_input_statement" : (VBLineInput, self.blocks),
		"seek_statement" : (VBSeek, self.blocks),
		"name_statement" : (VBName, self.blocks),

		"attribute_statement" : (VBUnrendered, self.blocks),
		"resume_statement" : (VBUnrendered, self.blocks),
		"goto_statement" : (VBUnrendered, self.blocks),
		"on_statement" : (VBUnrendered, self.blocks),
		"external_declaration" : (VBUnrendered, self.blocks),
		"get_statement" : (VBUnrendered, self.blocks),
		"put_statement" : (VBUnrendered, self.blocks),
		"option_statement" : (VBUnrendered, self.blocks),
		"class_header_block" : (VBUnrenderedBlock, self.blocks),

		"parser_failure" : (VBParserFailure, self.blocks),
		
	})
	



</t>
<t tx="pap.120703001453.263">&lt;&lt; VBCodeBlock methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
    #
    # Watch out for the block not containing any statements (could be all comments!)
    if not self.containsStatements():
        self.blocks.append(VBPass())
    #
	return "".join([block.renderAsCode(indent) for block in self.blocks])</t>
<t tx="pap.120703001453.264">&lt;&lt; Classes &gt;&gt;=


class VBUnrenderedBlock(VBCodeBlock):
	"""Represents an unrendered block"""
	
	would_end_docstring = 0 
	
	def renderAsCode(self, indent):
		"""Render the unrendrable!"""
		return ""
		
	</t>
<t tx="pap.120703001453.265">&lt;&lt; Classes &gt;&gt;=

class VBOptionalCodeBlock(VBCodeBlock):
	"""A block of VB code which can be empty and still sytactically correct"""
	
	&lt;&lt; VBOptionalCodeBlock methods &gt;&gt;
</t>
<t tx="pap.120703001453.266">&lt;&lt; VBOptionalCodeBlock methods &gt;&gt;=

def containsStatements(self, indent=0):
    """Return true if this block contains statements

        We always return 1 here because it doesn't matter if we contain statements of not

        """
    return 1
</t>
<t tx="pap.120703001453.267">&lt;&lt; Classes &gt;&gt;=

class VBVariable(VBNamespace):
	"""Handles a VB Variable"""
	
	&lt;&lt; VBVariable declarations &gt;&gt;
	&lt;&lt; VBVariable methods &gt;&gt;</t>
<t tx="pap.120703001453.268">@c

auto_handlers = [
		"scope",
		"type",
		"string_size_indicator",
		"value",
		"identifier",
		"optional",
		"new_keyword",
		"preserve_keyword",
		"implicit_object",
]

skip_handlers = [
		"const_statement",
]</t>
<t tx="pap.120703001453.269">&lt;&lt; VBVariable methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the variable"""
	super(VBVariable, self).__init__(scope)
	self.identifier = None
	self.scope = scope
	self.type = "Variant"
	self.size_definitions = []
	self.value = None
	self.optional = None
	self.expression = VBMissingArgument()
	self.new_keyword = None
	self.preserve_keyword = None
	self.string_size_indicator = None
	self.object = None
	self.implicit_object = None
	self.unsized_definition = None
	
	self.auto_class_handlers = {
		"expression"	: (VBExpression, "expression"),
		"size"	: (VBSizeDefinition, self.size_definitions),
		"size_range"	: (VBSizeDefinition, self.size_definitions),
		"unsized_definition"	: (VBConsumer, "unsized_definition"),
	}

</t>
<t tx="pap.120703001453.270">&lt;&lt; VBVariable methods &gt;&gt;=

def finalizeObject(self):
    """We can use this opportunity to now determine if we are a global"""
    if self.amGlobal(self.scope):
        self.registerAsGlobal()
    </t>
<t tx="pap.120703001453.271">&lt;&lt; VBVariable methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if self.optional:
		return "%s=%s" % (self.identifier, self.expression.renderAsCode())
	else:
		return self.identifier</t>
<t tx="pap.120703001453.272">&lt;&lt; Classes &gt;&gt;=

class VBSizeDefinition(VBNamespace):
	"""Handles a VB Variable size definition"""
	
	&lt;&lt; VBSizeDefinition methods &gt;&gt;</t>
<t tx="pap.120703001453.273">&lt;&lt; VBSizeDefinition methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the size definition"""
	super(VBSizeDefinition, self).__init__(scope)
	#
	self.expression = None
	self.sizes = []
	self.size_ranges = []
	#
	self.auto_class_handlers = {
		"size"	: (VBExpression, self.sizes),
		"size_range"	: (VBSizeDefinition, self.size_ranges),
	}
</t>
<t tx="pap.120703001453.274">&lt;&lt; VBSizeDefinition methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if self.sizes:
		return ", ".join([item.renderAsCode() for item in self.sizes])
	else:
		return "(%s)" % ", ".join([item.renderAsCode() for item in self.size_ranges])</t>
<t tx="pap.120703001453.275"></t>
<t tx="pap.120703001453.276">&lt;&lt; Classes &gt;&gt;=

class VBObject(VBNamespace):
	"""Handles a VB Object"""
	
    am_on_lhs = 0 # Set to 1 if the object is on the LHS of an assignment
    
	&lt;&lt; VBObject methods &gt;&gt;
</t>
<t tx="pap.120703001453.277">&lt;&lt; VBObject methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the object"""
	super(VBObject, self).__init__(scope)
	
	self.primary = None
	self.modifiers = []
	self.implicit_object = None
	
	self.auto_class_handlers.update({
		"primary" : (VBConsumer, "primary"),
		"attribute" : (VBAttribute, self.modifiers),
		"parameter_list" : (VBParameterList, self.modifiers),
	})

	self.auto_handlers = (
		"implicit_object",
	)
</t>
<t tx="pap.120703001453.278">&lt;&lt; VBObject methods &gt;&gt;=

def renderAsCode(self, indent=0):
    """Render this subroutine"""
    return self._renderPartialObject(indent)</t>
<t tx="pap.120703001453.279">&lt;&lt; VBObject methods &gt;&gt;=

def finalizeObject(self):
    """Finalize the object

        Check for any type markers.

        """
    for obj in [self.primary] + self.modifiers:
        try:
            ending = obj.element.text[-1:] or " "
        except AttributeError:
            pass # It isn't a consumer so we can't check it
        else:
            if ending in "#$%&amp;":
                log.info("Removed type identifier from '%s'" % obj.element.text)
                obj.element.text = obj.element.text[:-1]
</t>
<t tx="pap.120703001453.280">&lt;&lt; VBObject methods &gt;&gt;=

def asString(self):
	"""Return a string representation"""
	if self.implicit_object:
		log.info("Ooops an implicit object in definition")
	ret = [self.primary.element.text] + [item.asString() for item in self.modifiers]
	return ".".join(ret)


</t>
<t tx="pap.120703001453.281">&lt;&lt; Classes &gt;&gt;=

class VBLHSObject(VBObject):
	"""Handles a VB Object appearing on the LHS of an assignment"""
	
    am_on_lhs = 1 # Set to 1 if the object is on the LHS of an assignment
</t>
<t tx="pap.120703001453.282">&lt;&lt; Classes &gt;&gt;=

class VBAttribute(VBConsumer):
	"""An attribute of an object"""
	
	def renderAsCode(self, indent=0):
		"""Render this attribute"""
		return ".%s" % self.element.text
</t>
<t tx="pap.120703001453.283">&lt;&lt; Classes &gt;&gt;=

class VBParameterList(VBCodeBlock):
	"""An parameter list for an object"""
	
	&lt;&lt; VBParameterList methods &gt;&gt;
</t>
<t tx="pap.120703001453.284">&lt;&lt; VBParameterList methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the object"""
	super(VBParameterList, self).__init__(scope)
	
	self.expressions = []
	self.auto_class_handlers.update({
		"expression" : (VBExpression, self.expressions),
		"missing_positional" : (VBMissingPositional, self.expressions),
	})
	
</t>
<t tx="pap.120703001453.285">&lt;&lt; VBParameterList methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this attribute"""
	#
	# Check if we should replace () with [] - needed on the LHS of an assignment but not
	# elsewhere since __call__ is mapped to __getitem__ for array types
	if self.searchParentProperty("brackets_are_indexes"):
		fmt = "[%s]"
		self.brackets_are_indexes = StopSearch	# Prevents double accounting in a(b(5)) expressions where b is a function		
	else:
		fmt = "(%s)"
	#	
    # Construct the list of parameters - this is harder than it looks because 
    # for any missing positional parameters we have to do some introspection
    # to dig out the default value
    param_list = []
    for idx, element in zip(xrange(1000), self.expressions):
        element.parameter_index_position = idx # Needed so that the element can get its default
        param_list.append(element.renderAsCode())
    #
	content = ", ".join(param_list)
	return fmt % content
		</t>
<t tx="pap.120703001453.286"></t>
<t tx="pap.120703001453.287">&lt;&lt; Classes &gt;&gt;=

class VBExpression(VBNamespace):
	"""Represents an comment"""
	
	&lt;&lt; VBExpression methods &gt;&gt;</t>
<t tx="pap.120703001453.288">&lt;&lt; VBExpression methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the assignment"""
	super(VBExpression, self).__init__(scope)
	self.parts = []
	self.auto_class_handlers.update({
		"sign"	: (VBExpressionPart, self.parts),
		"pre_not" : (VBExpressionPart, self.parts),
		"par_expression" : (VBParExpression, self.parts),
		"point" : (VBPoint, self.parts),
		"operation" : (VBOperation, self.parts),
		"pre_named_argument" : (VBExpressionPart, self.parts),
		"pre_typeof" : (VBUnrendered, self.parts),
	})
	self.operator_groupings = [] # operators who requested regrouping (eg 'a Like b' -&gt; 'Like(a,b)')
</t>
<t tx="pap.120703001453.289">&lt;&lt; VBExpression methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	self.checkForOperatorGroupings()
	return " ".join([item.renderAsCode(indent) for item in self.parts])
</t>
<t tx="pap.120703001453.290">&lt;&lt; VBExpression methods &gt;&gt;=

def checkForOperatorGroupings(self):
    """Look for operators who requested regrouping

        Some operator cannot be translated in place (eg Like) since they must
        be converted to functions. This means that we have to re-order the 
        parts of the expression.

        """
    for item in self.operator_groupings:
        idx = self.parts.index(item)
        rh, lh = self.parts.pop(idx+1), self.parts.pop(idx-1)
        item.rh, item.lh = rh, lh
		</t>
<t tx="pap.120703001453.291"></t>
<t tx="pap.120703001453.292">&lt;&lt; Classes &gt;&gt;=

class VBParExpression(VBNamespace):
	"""A block in an expression"""
	
	auto_handlers = [
		"l_bracket",
		"r_bracket",
	]

	&lt;&lt; VBParExpression methods &gt;&gt;</t>
<t tx="pap.120703001453.293">&lt;&lt; VBParExpression methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize"""
	super(VBParExpression, self).__init__(scope)
	self.parts = []
	self.named_argument = ""
	self.auto_class_handlers.update({
		"integer" : (VBExpressionPart, self.parts),
		"hexinteger" : (VBExpressionPart, self.parts),
		"stringliteral" : (VBStringLiteral, self.parts),
		"dateliteral" : (VBDateLiteral, self.parts),
		"floatnumber" : (VBExpressionPart, self.parts),
		"longinteger" : (VBExpressionPart, self.parts),
		"object" : (VBObject, self.parts),
		"par_expression" : (VBParExpression, self.parts),
		"operation" : (VBOperation, self.parts),
	    "named_argument" : (VBConsumer, "named_argument"),
		"pre_not" : (VBExpressionPart, self.parts),
		"pre_typeof" : (VBUnrendered, self.parts),
		"point" : (VBPoint, self.parts),
		"sign"	: (VBExpressionPart, self.parts),
	})
	
	self.l_bracket = self.r_bracket = ""
	self.operator_groupings = [] # operators who requested regrouping (eg 'a Like b' -&gt; 'Like(a,b)')
</t>
<t tx="pap.120703001453.294">&lt;&lt; VBParExpression methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	self.checkForOperatorGroupings()
	if self.named_argument:
		arg = "%s=" % self.named_argument.element.text
	else:
		arg = ""
	ascode = " ".join([item.renderAsCode(indent) for item in self.parts])
	return "%s%s%s%s" % (arg, self.l_bracket, ascode, self.r_bracket)
</t>
<t tx="pap.120703001453.295">&lt;&lt; VBParExpression methods &gt;&gt;=

def checkForOperatorGroupings(self):
    """Look for operators who requested regrouping

        Some operator cannot be translated in place (eg Like) since they must
        be converted to functions. This means that we have to re-order the 
        parts of the expression.

        """
    # Destructively scan the list so we don't try this a second time later!
    while self.operator_groupings:
        item = self.operator_groupings.pop()
        idx = self.parts.index(item)
        rh, lh = self.parts.pop(idx+1), self.parts.pop(idx-1)
        item.rh, item.lh = rh, lh
		</t>
<t tx="pap.120703001453.296">&lt;&lt; Classes &gt;&gt;=

class VBPoint(VBExpression):
	"""A block in an expression"""
	
	skip_handlers = [
		"point",
	]

	&lt;&lt; VBPoint methods &gt;&gt;</t>
<t tx="pap.120703001453.297">&lt;&lt; VBPoint methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return "(%s)" % ", ".join([item.renderAsCode() for item in self.parts])
</t>
<t tx="pap.120703001453.298">&lt;&lt; Classes &gt;&gt;=

class VBExpressionPart(VBConsumer):
	"""Part of an expression"""
	
	&lt;&lt; VBExpressionPart methods &gt;&gt;</t>
<t tx="pap.120703001453.299">&lt;&lt; VBExpressionPart methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if self.element.name == "object":
		#
		# Check for implicit object (inside a with)
		if self.element.text.startswith("."):
			return "%s%s" % (self.getParentProperty("with_object"),
							 self.element.text)
	elif self.element.text.lower() == "like":
		return "Like(%s, %s)" % (self.lh.renderAsCode(), self.rh.renderAsCode())
    elif self.element.name == "pre_named_argument":
        return "%s=" % (self.element.text.split(":=")[0],)
	elif self.element.name == "pre_not":
		self.element.text = "not"
	elif self.element.name == "hexinteger":
		if self.element.text.endswith("&amp;"):
			return "0x%s" % self.element.text[2:-1]
		else:
			return "0x%s" % self.element.text[2:]
		
	return self.element.text

</t>
<t tx="pap.120703001453.300">&lt;&lt; VBExpressionPart methods &gt;&gt;=

def finalizeObject(self):
    """Finalize the object

        Check for any type markers.

        """
    ending = self.element.text[-1:] or " "
    if ending in "#$%&amp;":
        log.info("Removed type identifier from '%s'" % self.element.text)
        self.element.text = self.element.text[:-1]</t>
<t tx="pap.120703001453.301">&lt;&lt; Classes &gt;&gt;=

class VBOperation(VBExpressionPart):
	"""An operation in an expression"""
	
	translation = {
		"&amp;" : "+",
		"^" : "**",
		"=" : "==",
		"\\" : "//",  # TODO: Is this right?
        "is" : "is",
        "or" : "or",
        "and" : "and", # TODO: are there any more?
		"xor" : "^",
		"mod" : "%", 
	}
	
	&lt;&lt; VBOperation methods &gt;&gt;
	
</t>
<t tx="pap.120703001453.302">&lt;&lt; VBOperation methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if self.element.text.lower() in self.translation:
		return self.translation[self.element.text.lower()]
	else:
		return super(VBOperation, self).renderAsCode(indent)
</t>
<t tx="pap.120703001453.303">&lt;&lt; VBOperation methods &gt;&gt;=

def finalizeObject(self):
    """Finalize the object"""
	if self.element.text.lower() in ("like", ):
		log.info("Found regrouping operator, reversing order of operands")
		self.parent.operator_groupings.append(self)

</t>
<t tx="pap.120703001453.304">&lt;&lt; Classes &gt;&gt;=

class VBStringLiteral(VBExpressionPart):
	"""Represents a string literal"""
	
	&lt;&lt; VBStringLiteral methods &gt;&gt;</t>
<t tx="pap.120703001453.305">&lt;&lt; VBStringLiteral methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	#
	# Remember to replace the double quotes with single ones
	body = self.element.text[1:-1]
	body = body.replace('""', '"')
	#
	if self.checkOptionYesNo("General", "AlwaysUseRawStringLiterals") == "Yes":
		body = body.replace("'", "\'")
		return "r'%s'" % body
	else:		
		body = body.replace('\\', '\\\\')
		body = body.replace("'", "\\'")
		return "'%s'" % body
</t>
<t tx="pap.120703001453.306">&lt;&lt; Classes &gt;&gt;=

class VBDateLiteral(VBParExpression):
	"""Represents a date literal"""
	
	skip_handlers = [
		"dateliteral",
	]
	
	&lt;&lt; VBDateLiteral methods &gt;&gt;
</t>
<t tx="pap.120703001453.307">&lt;&lt; VBDateLiteral methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return "MakeDate(%s)" % ", ".join([item.renderAsCode() for item in self.parts])
</t>
<t tx="pap.120703001453.308"></t>
<t tx="pap.120703001453.309">&lt;&lt; Classes &gt;&gt;=

class VBProject(VBNamespace):
	"""Handles a VB Project"""
	
	&lt;&lt; VBProject methods &gt;&gt;</t>
<t tx="pap.120703001453.310">&lt;&lt; VBProject methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the module"""
	super(VBProject, self).__init__(scope)
    self.global_objects = {} # This is where global variables live
</t>
<t tx="pap.120703001453.311">&lt;&lt; VBProject methods &gt;&gt;=

def resolveLocalName(self, name, rendering_locals=0, requestedby=None):
    """Convert a local name to a fully resolved name

        We search our local modules to see if they have a matching global variable
        and if they do then we can construct the local name from it.

        """
    #import pdb; pdb.set_trace()
    if name in self.global_objects:
        # Found as another module's public var - so mark it up and request an import
        modulename = self.global_objects[name].getParentProperty("modulename")
        if requestedby:
            requestedby.registerImportRequired(modulename)
        return "%s.%s" % (modulename,
                          name)
    else:
        raise UnresolvableName("Name '%s' is not known in this namespace" % name)						
		</t>
<t tx="pap.120703001453.312">&lt;&lt; Classes &gt;&gt;=

class VBModule(VBCodeBlock):
	"""Handles a VB Module"""
	
	skip_handlers = [
	]
	
	convert_functions_to_methods = 0  # If this is 1 then local functions will become methods
	indent_all_blocks = 0
    allow_new_style_class = 1 # Can be used to dissallow new style classes
    
    public_is_global = 0 # Public objects defined here will not be globals
    
    # Put methods and attribute names in here which always need to be public
    # like Class_Initialize and Class_Terminate for classes
    always_public_attributes = []
    
	&lt;&lt; VBModule methods &gt;&gt;</t>
<t tx="pap.120703001453.313">&lt;&lt; VBModule methods &gt;&gt;=

def __init__(self, scope="Private", modulename="unknownmodule", classname="MyClass",
             superclasses=None):
	"""Initialize the module"""
	super(VBModule, self).__init__(scope)
	self.auto_class_handlers.update({
		"sub_definition" : (VBSubroutine, self.locals),
		"fn_definition" : (VBFunction, self.locals),
		"property_definition" : (VBProperty, self.locals),
		"enumeration_definition" : (VBEnum, self.locals),
	})
    self.local_names = []
    self.modulename = modulename
    self.classname = classname
    self.superclasses = superclasses or []
	#
	self.rendering_locals = 0
	self.docstrings = []
	self.module_imports = [] # The additional modules we need to import</t>
<t tx="pap.120703001453.314">&lt;&lt; VBModule methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
    self.setCustomModulesAsGlobals()
	if self.checkOptionYesNo("General", "TryToExtractDocStrings") == "Yes":
		self.extractDocStrings()
	#
	# Pre-render the following before the import statments in case any
	# of them ask us to do additional imports
	header = self.renderModuleHeader(indent)
	docstrings = self.renderDocStrings(indent)
	declarations = self.renderDeclarations(indent+self.indent_all_blocks)
	blocks = self.renderBlocks(indent+self.indent_all_blocks)
	#
	return "%s\n\n%s%s\n%s\n%s" % (
				   self.importStatements(indent),
				   header,
				   docstrings,
				   declarations,
				   blocks,
				  )
</t>
<t tx="pap.120703001453.315">&lt;&lt; VBModule methods &gt;&gt;=

def importStatements(self, indent=0):
	"""Render the standard import statements for this block"""
	other = [""]+["import %s" % item for item in self.module_imports] # Leading [""] gives a newline
	if self.checkOptionYesNo("General", "IncludeDebugCode") == "Yes":
		debug = "\nfrom vb2py.vbdebug import *"
	else:
		debug = ""
	return "from vb2py.vbfunctions import *%s%s" % (debug, "\n".join(other))</t>
<t tx="pap.120703001453.316">&lt;&lt; VBModule methods &gt;&gt;=

def renderDeclarations(self, indent):
    """Render the declarations as code

        Most of the rendering is delegated to the individual declaration classes. However,
        we cannot do this with properties since they need to be grouped into a single assignment.
        We do the grouping here and delegate the rendering to them.

        """
    #
    ret = []
    self.rendering_locals = 1 # Used for switching behaviour (eg adding 'self')
    #
    # Handle non-properties and group properties together
    properties = {}
    for declaration in self.locals:
        # Check for property
        if isinstance(declaration, VBProperty):
            log.info("Collected property '%s', decorator '%s'" % (
                        declaration.identifier, declaration.property_decorator_type))
            decorators = properties.setdefault(declaration.identifier, {})
            decorators[declaration.property_decorator_type] = declaration
        else:
            ret.append(declaration.renderAsCode(indent))
    #
    # Now render all the properties
    for property in properties:
        if properties[property]:
                ret.append(properties[property].values()[0].renderPropertyGroup(indent, property, **properties[property]))
    #		
    self.rendering_locals = 0
    #
    return "".join(ret)</t>
<t tx="pap.120703001453.317">&lt;&lt; VBModule methods &gt;&gt;=

def renderBlocks(self, indent=0):
	"""Render this module's blocks"""
	return "".join([block.renderAsCode(indent) for block in self.blocks])</t>
<t tx="pap.120703001453.318">&lt;&lt; VBModule methods &gt;&gt;=

def extractDocStrings(self, indent=0):
    """Extract doc strings from this module

        We look for comments in the body of the module and take all the ones before
        anything that isn't a comment.

        """
    for line in self.blocks[:]:
        if isinstance(line, VBComment):
            self.docstrings.append(line)
            self.blocks.remove(line)
        elif line.would_end_docstring:
            break
			</t>
<t tx="pap.120703001453.319">&lt;&lt; VBModule methods &gt;&gt;=

def renderDocStrings(self, indent=0):
	"""Render this module's docstrings"""
	local_indent = indent+self.indent_all_blocks
	if not self.docstrings:
		return ""
	elif len(self.docstrings) == 1:
		return '%s"""%s"""\n'  % (
				self.getIndent(local_indent),
				self.docstrings[0].asString())
	else:
		joiner = "\n%s" % self.getIndent(local_indent)
		return '%s"""%s\n%s%s\n%s"""\n' % (
				self.getIndent(local_indent),
				self.docstrings[0].asString(),
				self.getIndent(local_indent),
				joiner.join([item.asString() for item in self.docstrings[1:]]),
				self.getIndent(local_indent),
				)
				
				</t>
<t tx="pap.120703001453.320">&lt;&lt; VBModule methods &gt;&gt;=

def renderModuleHeader(self, indent=0):
	"""Render a header for the module"""
	return ""</t>
<t tx="pap.120703001453.321">&lt;&lt; VBModule methods &gt;&gt;=

def resolveLocalName(self, name, rendering_locals=0, requestedby=None):
    """Convert a local name to a fully resolved name

        We search our local variables to see if we know the name. If we do then we
        just report it.

        """
    if name in self.local_names:
        return name
    for obj in self.locals:
        if obj.identifier == name:
            return self.enforcePrivateName(obj)
    raise UnresolvableName("Name '%s' is not known in this namespace" % name)			
		
</t>
<t tx="pap.120703001453.322">&lt;&lt; VBModule methods &gt;&gt;=

def enforcePrivateName(self, obj):
    """Enforce the privacy for this object name if required"""
    if obj.scope == "Private" and self.checkOptionYesNo("General", "RespectPrivateStatus") == "Yes" \
       and not obj.identifier in self.always_public_attributes:
        return "%s%s" % (Config["General", "PrivateDataPrefix"], obj.identifier)
    else:
        return obj.identifier

</t>
<t tx="pap.120703001453.323">&lt;&lt; Classes &gt;&gt;=

class VBClassModule(VBModule):
	"""Handles a VB Class"""
	
	convert_functions_to_methods = 1  # If this is 1 then local functions will become methods
	indent_all_blocks = 1

    # Put methods and attribute names in here which always need to be public
    # like Class_Initialize and Class_Terminate for classes
    always_public_attributes = ["Class_Initialize", "Class_Terminate"]
    
	&lt;&lt; VBClassModule methods &gt;&gt;
</t>
<t tx="pap.120703001453.324">&lt;&lt; VBClassModule methods &gt;&gt;=

def __init__(self, *args, **kw):
	"""Initialize the class module"""
	super(VBClassModule, self).__init__(*args, **kw)
	self.name_substitution = {"Me" : "self"}
</t>
<t tx="pap.120703001453.325">&lt;&lt; VBClassModule methods &gt;&gt;=

def renderModuleHeader(self, indent=0):
	"""Render this element as code"""
    supers = self.superclasses[:]
    if self.checkOptionYesNo("Classes", "UseNewStyleClasses") == "Yes" and \
             self.allow_new_style_class:
	    supers.insert(0, "Object")
    if supers:
        return "class %s(%s):\n" % (self.classname, ", ".join(supers))
    else:        
        return "class %s:\n" % self.classname
</t>
<t tx="pap.120703001453.326">&lt;&lt; VBClassModule methods &gt;&gt;=

def resolveLocalName(self, name, rendering_locals=0, requestedby=None):
    """Convert a local name to a fully resolved name

        We search our local variables to see if we know the name. If we do then we
        need to add a self.

        """
    # Don't do anything for locals
    if rendering_locals:
        prefix = ""
    else:
        prefix = "self."
    #
    if name in self.local_names:
        return "%s%s" % (prefix, name)
    for obj in self.locals:
        if obj.identifier == name:
            return "%s%s" % (prefix, self.enforcePrivateName(obj))
    raise UnresolvableName("Name '%s' is not known in this namespace" % name)			
		</t>
<t tx="pap.120703001453.327">&lt;&lt; Classes &gt;&gt;=

class VBCodeModule(VBModule):
	"""Handles a VB Code module"""
	
    public_is_global = 1 # Public objects defined here will be globals

    &lt;&lt; VBCodeModule methods &gt;&gt;</t>
<t tx="pap.120703001453.328">&lt;&lt; VBCodeModule methods &gt;&gt;=

def enforcePrivateName(self, obj):
    """Enforce the privacy for this object name if required

        In a code module this is not required. Private variables and definitions in a code
        module are not really hidden in the same way as in a class module. They are accessible
        still. The main thing is that they are not global.

        """
    return obj.identifier

</t>
<t tx="pap.120703001453.329">&lt;&lt; Classes &gt;&gt;=

class VBFormModule(VBClassModule):
	"""Handles a VB Form module"""
	
	convert_functions_to_methods = 1  # If this is 1 then local functions will become methods

</t>
<t tx="pap.120703001453.330"></t>
<t tx="pap.120703001453.331">&lt;&lt; Classes &gt;&gt;=

class VBVariableDefinition(VBVariable):
	"""Handles a VB Dim of a Variable"""
	
	&lt;&lt; VBVariableDefinition methods &gt;&gt;</t>
<t tx="pap.120703001453.332">&lt;&lt; VBVariableDefinition methods &gt;&gt;=

def renderAsCode(self, indent=0):
    """Render this element as code"""
    #
    local_name = self.resolveName(self.identifier)
    #
    # TODO: Can't handle implicit objects yet
    if self.implicit_object:
        warning = self.getWarning(
                "UnhandledDefinition", 
                "Dim of implicit 'With' object (%s) is not supported" % local_name, 
                indent=indent, crlf=1)
    else:
        warning = ""
    #
    if self.string_size_indicator:
        size = self.string_size_indicator
        self.type = "FixedString"
    else:
        size = ""
    #
    # Make sure we resolve the type properly
    local_type = self.resolveName(self.type)
    #
    if self.unsized_definition: # This is a 'Dim a()' statement
        return "%s%s%s = vbObjectInitialize(objtype=%s)\n" % (
                        warning,
                        self.getIndent(indent),
                        local_name,
                        local_type)						
    elif self.size_definitions: # There is a size 'Dim a(10)'
        if self.preserve_keyword:
            preserve = ", %s" % (local_name, )
        else:
            preserve = ""
        if size:
            size = ", stringsize=" + size
        return "%s%s%s = vbObjectInitialize((%s,), %s%s%s)\n" % (
                        warning,
                        self.getIndent(indent),
                        local_name,
                        ", ".join([item.renderAsCode() for item in self.size_definitions]),
                        local_type,
                        preserve,
                        size)
    elif self.new_keyword: # It is an 'Dim a as new ...'
        return "%s%s%s = %s(%s)\n" % (
                        warning,
                        self.getIndent(indent),
                        local_name,
                        local_type,
                        size)
    else: # This is just 'Dim a as frob'
        return "%s%s%s = %s(%s)\n" % (
                        warning,
                        self.getIndent(indent),
                        local_name,
                        local_type,
                        size)
		
</t>
<t tx="pap.120703001453.333">&lt;&lt; Classes &gt;&gt;=

class VBConstant(VBVariableDefinition):
	"""Represents a constant in VB"""
	
	&lt;&lt; VBConstant methods &gt;&gt;
	
	
</t>
<t tx="pap.120703001453.334">&lt;&lt; VBConstant methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	#local_name = self.getLocalNameFor(self.identifier)
	local_name = self.resolveName(self.identifier)
	return "%s%s = %s\n" % (
						self.getIndent(indent),
						local_name,
						self.expression.renderAsCode())
		

</t>
<t tx="pap.120703001453.335">&lt;&lt; Classes &gt;&gt;=

class VBReDim(VBCodeBlock):
	"""Represents a Redim statement"""
	
	&lt;&lt; VBReDim methods &gt;&gt;</t>
<t tx="pap.120703001453.336">&lt;&lt; VBReDim methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Redim"""
	super(VBReDim, self).__init__(scope)
	#
	self.variables = []
	self.preserve = None
	#
	self.auto_class_handlers = {
		"object_definition" : (VBVariableDefinition, self.variables),
		"preserve_keyword" : (VBConsumer, "preserve"),
	}
	
</t>
<t tx="pap.120703001453.337">&lt;&lt; VBReDim methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	for var in self.variables:
		var.preserve_keyword = self.preserve
	return "".join([var.renderAsCode(indent) for var in self.variables])</t>
<t tx="pap.120703001453.338">&lt;&lt; Classes &gt;&gt;=

class VBAssignment(VBNamespace):
	"""An assignment statement"""
	
	auto_handlers = [
	]

	&lt;&lt; VBAssignment methods &gt;&gt;</t>
<t tx="pap.120703001453.339">&lt;&lt; VBAssignment methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the assignment"""
	super(VBAssignment, self).__init__(scope)
	self.parts = []
	self.object = None
	self.auto_class_handlers.update({
		"expression" : (VBExpression, self.parts),
		"object" : (VBLHSObject, "object")
	})
</t>
<t tx="pap.120703001453.340">&lt;&lt; VBAssignment methods &gt;&gt;=

def asString(self):
	"""Convert to a nice representation"""
	return "%s = %s" % (self.object, self.parts)</t>
<t tx="pap.120703001453.341">&lt;&lt; VBAssignment methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
    self.checkForModuleGlobals()
	self.object.brackets_are_indexes = 1 # Convert brackets on LHS to []
	return "%s%s = %s\n" % (self.getIndent(indent),
							self.object.renderAsCode(), 
							self.parts[0].renderAsCode(indent))
</t>
<t tx="pap.120703001453.342">&lt;&lt; VBAssignment methods &gt;&gt;=

def checkForModuleGlobals(self):
    """Check if this assignment requires a global statement

        We can use this opportunity to now check if we need to append a 'global' statement
        to our container. If we are in a CodeModule an assignment and the LHS of the assignment is a
        module level variable which is not locally shadowed then we need a global.

        So the procedure is,
         - look for our parent who is a subroutine type
         - if we don't have one then skip out
         - see if this parent knows us, if so then we are a subroutine local
         - also see if we are the subroutine name
         - look for our parent who is a module type
         - see if this parent knows us, if so then we are a module local
         - if we are then tell our subroutine parent that we need a global statement

        """        
    log.info("Checking whether to use a global statement for '%s'" % self.object.primary.element.text)
    #import pdb; pdb.set_trace()
    try:
        enclosing_sub = self.findParentOfClass(VBSubroutine)
    except NestingError:
        return # We are not in a subroutine

    log.info("Found sub")    
    try:
        name = enclosing_sub.resolveLocalName(self.object.primary.element.text)
    except UnresolvableName:
        if enclosing_sub.identifier == self.object.primary.element.text:
            return
    else:
        return # We are a subroutine local

    log.info("Am not local")    
    try:
        enclosing_module = self.findParentOfClass(VBCodeModule)
    except NestingError:
        return # We are not in a module

    log.info("Found code module")        
    try:
        name = enclosing_module.resolveLocalName(self.object.primary.element.text)
    except UnresolvableName:
        return # We are not known at the module level

    # If we get to here then we are a module level local!
    enclosing_sub.globals_required[self.resolveName(self.object.primary.element.text)] = 1

    log.info("Added a module level global: '%s'" % self.resolveName(self.object.primary.element.text))
    

</t>
<t tx="pap.120703001453.343">&lt;&lt; Classes &gt;&gt;=

class VBSpecialAssignment(VBAssignment):
	"""A special assignment eg LSet, RSet where the assignment ends up as a function call"""
	
	fn_name = None
	
	&lt;&lt; VBSpecialAssignment methods &gt;&gt;

</t>
<t tx="pap.120703001453.344">&lt;&lt; VBSpecialAssignment methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
    self.checkForModuleGlobals()
	self.object.brackets_are_indexes = 1 # Convert brackets on LHS to []
	return "%s%s = %s(%s, %s)\n" % (self.getIndent(indent),
							self.object.renderAsCode(), 
							self.fn_name, 
							self.object.renderAsCode(), 
							self.parts[0].renderAsCode(indent))
</t>
<t tx="pap.120703001453.345">&lt;&lt; Classes &gt;&gt;=

class VBLSet(VBSpecialAssignment):
	"""An LSet statement"""
	
	fn_name = "LSet"

</t>
<t tx="pap.120703001453.346">&lt;&lt; Classes &gt;&gt;=

class VBRSet(VBSpecialAssignment):
	"""An RSet statement"""
	
	fn_name = "RSet"

</t>
<t tx="pap.120703001453.347">&lt;&lt; Classes &gt;&gt;=

class VBSet(VBAssignment):
	"""A set statement"""
	
	auto_handlers = [
		"new_keyword",
	]

	new_keyword = ""
	
	&lt;&lt; VBSet methods &gt;&gt;
</t>
<t tx="pap.120703001453.348">&lt;&lt; VBSet methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if not self.new_keyword:
		return super(VBSet, self).renderAsCode(indent)
	else:
		return "%s%s = %s()\n" % (
					self.getIndent(indent),
					self.object.renderAsCode(), 
					self.parts[0].renderAsCode(indent))
</t>
<t tx="pap.120703001453.349">&lt;&lt; Classes &gt;&gt;=

class VBEnd(VBAssignment):
	"""An end statement"""
	
	&lt;&lt; VBEnd methods &gt;&gt;
</t>
<t tx="pap.120703001453.350">&lt;&lt; VBEnd methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return "%ssys.exit(0)\n" % self.getIndent(indent)
</t>
<t tx="pap.120703001453.351">&lt;&lt; Classes &gt;&gt;=

class VBCall(VBCodeBlock):
	"""A set statement"""
	
	auto_handlers = [
	]

	
	&lt;&lt; VBCall methods &gt;&gt;
</t>
<t tx="pap.120703001453.352">&lt;&lt; VBCall methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the assignment"""
	super(VBCall, self).__init__(scope)
	self.parameters = []
	self.object = None
	self.auto_class_handlers = ({
		"expression" : (VBParExpression, self.parameters),
		"missing_positional" : (VBMissingPositional, self.parameters),
		"object" : (VBObject, "object")
	})
</t>
<t tx="pap.120703001453.353">&lt;&lt; VBCall methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if self.parameters:
        #	
        # Construct the list of parameters - this is harder than it looks because 
        # for any missing positional parameters we have to do some introspection
        # to dig out the default value
        param_list = []
        for idx, element in zip(xrange(1000), self.parameters):
            element.parameter_index_position = idx # Needed so that the element can get its default
            param_list.append(element.renderAsCode())
        params = ", ".join(param_list)
    else:
		params = ""
	#
	self.object.am_on_lhs = 1
	#
	return "%s%s(%s)\n" % (self.getIndent(indent),
						 self.object.renderAsCode(), 
						 params)</t>
<t tx="pap.120703001453.354">&lt;&lt; Classes &gt;&gt;=

class VBExitStatement(VBConsumer):
	"""Represents an exit statement"""
	
	&lt;&lt; VBExitStatement methods &gt;&gt;</t>
<t tx="pap.120703001453.355">&lt;&lt; VBExitStatement methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	indenter = self.getIndent(indent)
	if self.element.text == "Exit Function":
		return "%sreturn %s\n" % (indenter, Config["Functions", "ReturnVariableName"])
	elif self.element.text == "Exit Sub":
		return "%sreturn\n" % indenter
	elif self.element.text == "Exit Property":
		if self.getParentProperty("property_decorator_type") == "Get":
			return "%sreturn %s\n" % (indenter, Config["Functions", "ReturnVariableName"])
		else:
			return "%sreturn\n" % indenter		
	else:
		return "%sbreak\n" % indenter
</t>
<t tx="pap.120703001453.356">&lt;&lt; Classes &gt;&gt;=

class VBComment(VBConsumer):
	"""Represents an comment"""
		
    #
    # Used to indicate if this is a valid statement
    not_a_statement = 0
    
	&lt;&lt; VBComment methods &gt;&gt;</t>
<t tx="pap.120703001453.357">&lt;&lt; VBComment methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return self.getIndent(indent) + "#%s\n" % self.element.text</t>
<t tx="pap.120703001453.358">&lt;&lt; VBComment methods &gt;&gt;=

def asString(self):
	"""Render this element as a string"""
	return self.element.text</t>
<t tx="pap.120703001453.359">&lt;&lt; Classes &gt;&gt;=

class VBLabel(VBUnrendered):
	"""Represents a label"""

	def renderAsCode(self, indent):
		"""Render the label"""
		if Config["Labels", "IgnoreLabels"] == "Yes":
			return ""
		else:
			return super(VBLabel, self).renderAsCode(indent)
</t>
<t tx="pap.120703001453.360"></t>
<t tx="pap.120703001453.361">&lt;&lt; Classes &gt;&gt;=

class VBOpen(VBCodeBlock):
	"""Represents an open statement"""
		
	&lt;&lt; VBOpen methods &gt;&gt;</t>
<t tx="pap.120703001453.362">&lt;&lt; VBOpen methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the open"""
	super(VBOpen, self).__init__(scope)
	#
	self.filename = None
	self.open_modes = []
	self.channel = None
	#
	self.auto_class_handlers = ({
		"filename" : (VBParExpression, "filename"),
		"open_mode" : (VBConsumer, self.open_modes),
		"channel" : (VBParExpression, "channel"),
	})
	#
	self.open_mode_lookup = {
		"Input" : "r",
		"Output" : "w",
		"Append" : "a",
		"Binary" : "b",
	}

</t>
<t tx="pap.120703001453.363">&lt;&lt; VBOpen methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	file_mode = ""
	todo = []
	for mode in self.open_modes:
		m = mode.element.text.strip()
		try:
			file_mode += self.open_mode_lookup[m.strip()]
		except KeyError:
			todo.append("'%s'" % m.strip())
	if todo:
		todo_warning = self.getWarning("UnknownFileMode", ", ".join(todo))	
	else:
		todo_warning = ""
	#
	return "%sVBFiles.openFile(%s, %s, '%s') %s\n" % (
				self.getIndent(indent),
				self.channel.renderAsCode(),
				self.filename.renderAsCode(),
				file_mode,
				todo_warning)</t>
<t tx="pap.120703001453.364">&lt;&lt; Classes &gt;&gt;=

class VBClose(VBCodeBlock):
	"""Represents a close statement"""
		
	&lt;&lt; VBClose methods &gt;&gt;</t>
<t tx="pap.120703001453.365">&lt;&lt; VBClose methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the open"""
	super(VBClose, self).__init__(scope)
	#
	self.channels = []
	#
	self.auto_class_handlers = ({
		"expression" : (VBParExpression, self.channels),
	})</t>
<t tx="pap.120703001453.366">&lt;&lt; VBClose methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if not self.channels:
		return "%sVBFiles.closeFile()\n" % (
					self.getIndent(indent))
	else:
		ret = []
		for channel in self.channels:
			ret.append("%sVBFiles.closeFile(%s)\n" % (
					self.getIndent(indent),
					channel.renderAsCode()))
		return "".join(ret)
</t>
<t tx="pap.120703001453.367">&lt;&lt; Classes &gt;&gt;=

class VBSeek(VBCodeBlock):
	"""Represents a seek statement"""
		
	&lt;&lt; VBSeek methods &gt;&gt;</t>
<t tx="pap.120703001453.368">&lt;&lt; VBSeek methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the seek"""
	super(VBSeek, self).__init__(scope)
	#
	self.expressions = []
	#
	self.auto_class_handlers = ({
		"expression" : (VBParExpression, self.expressions),
	})
</t>
<t tx="pap.120703001453.369">&lt;&lt; VBSeek methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return "%sVBFiles.seekFile(%s, %s)\n" % (
				self.getIndent(indent),
				self.expressions[0].renderAsCode(),
				self.expressions[1].renderAsCode(),)
</t>
<t tx="pap.120703001453.370">&lt;&lt; Classes &gt;&gt;=

class VBInput(VBCodeBlock):
	"""Represents an input statement"""
		
	input_type = "Input"
	
	&lt;&lt; VBInput methods &gt;&gt;
</t>
<t tx="pap.120703001453.371">&lt;&lt; VBInput methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the open"""
	super(VBInput, self).__init__(scope)
	#
	self.channel = None
	self.variables = []
	#
	self.auto_class_handlers = ({
		"channel_id" : (VBParExpression, "channel"),
		"expression" : (VBExpression, self.variables),
	})</t>
<t tx="pap.120703001453.372">&lt;&lt; VBInput methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	# Make sure variables are converted as if they are on the LHS of an assignment
	for var in self.variables:
		var.brackets_are_indexes = 1
	#
	return "%s%s = VBFiles.get%s(%s, %d)\n" % (
				self.getIndent(indent),
				", ".join([var.renderAsCode() for var in self.variables]),
				self.input_type,
				self.channel.renderAsCode(),
				len(self.variables))
</t>
<t tx="pap.120703001453.373">&lt;&lt; Classes &gt;&gt;=

class VBLineInput(VBInput):
	"""Represents an input statement"""
		
	input_type = "LineInput"
</t>
<t tx="pap.120703001453.374">&lt;&lt; Classes &gt;&gt;=

class VBPrint(VBCodeBlock):
	"""Represents a print statement"""
		
	&lt;&lt; VBPrint methods &gt;&gt;
</t>
<t tx="pap.120703001453.375">&lt;&lt; VBPrint methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the print"""
	super(VBPrint, self).__init__(scope)
	#
	self.channel = VBRenderDirect("None")
	self.variables = []
	self.hold_cr = None
	#
	self.auto_class_handlers = ({
		"channel_id" : (VBParExpression, "channel"),
		"expression" : (VBExpression, self.variables),
		"print_separator" : (VBPrintSeparator, self.variables),
	})</t>
<t tx="pap.120703001453.376">&lt;&lt; VBPrint methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	print_list = ", ".join([var.renderAsCode() for var in self.variables if var.renderAsCode()])
	if self.variables:
		if self.variables[-1].renderAsCode() not in (None, "\t"):
			print_list += ", '\\n'"
	return "%sVBFiles.writeText(%s, %s)\n" % (
				self.getIndent(indent),
				self.channel.renderAsCode(),
				print_list)</t>
<t tx="pap.120703001453.377">&lt;&lt; Classes &gt;&gt;=

class VBPrintSeparator(VBConsumer):
	"""Represents a print statement separator"""
	
	&lt;&lt; VBPrintSeparator methods &gt;&gt;</t>
<t tx="pap.120703001453.378">&lt;&lt; VBPrintSeparator methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	if self.element.text == ";":
		return None
	elif self.element.text == ",":
		return '"\\t"'
	else:
		raise UnhandledStructureError("Unknown print separator '%s'" % self.element.text)</t>
<t tx="pap.120703001453.379">&lt;&lt; Classes &gt;&gt;=

class VBName(VBCodeBlock):
	"""Represents a name statement"""
	
	&lt;&lt; VBName methods &gt;&gt;</t>
<t tx="pap.120703001453.380">&lt;&lt; VBName methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the print"""
	super(VBName, self).__init__(scope)
	#
	self.channel = VBRenderDirect("None")
	self.files = []
	#
	self.auto_class_handlers = ({
		"expression" : (VBExpression, self.files),
	})</t>
<t tx="pap.120703001453.381">&lt;&lt; VBName methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	self.registerImportRequired("os")
	file_list = ", ".join([fle.renderAsCode() for fle in self.files])
	return "%sos.rename(%s)\n" % (
				self.getIndent(indent),
				file_list)</t>
<t tx="pap.120703001453.382"></t>
<t tx="pap.120703001453.383">&lt;&lt; Classes &gt;&gt;=

class VBUserType(VBCodeBlock):
	"""Represents a select block"""
	
	auto_handlers = [
	]
	
	select_variable_index = 0
		
	&lt;&lt; VBUserType methods &gt;&gt;
</t>
<t tx="pap.120703001453.384">&lt;&lt; VBUserType methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBUserType, self).__init__(scope)
	#
	self.variables = []
	self.identifier = None
	#
	self.auto_class_handlers = {
		"identifier" : (VBConsumer, "identifier"),
		"object_definition" : (VBVariable, self.variables),
	}
</t>
<t tx="pap.120703001453.385">&lt;&lt; VBUserType methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	vars = []
	if not self.variables:
		vars.append(VBPass().renderAsCode(indent+2))
	else:
		for var in self.variables:
			vars.append("%sself.%s = %s()" % (
							self.getIndent(indent+2),
							var.identifier,
							var.type))
	#
	return ("%sclass %s:\n"
		    "%sdef __init__(self):\n%s\n\n" % (
				self.getIndent(indent),
				self.identifier.element.text,
				self.getIndent(indent+1),
				"\n".join(vars)))</t>
<t tx="pap.120703001453.386">&lt;&lt; Classes &gt;&gt;=

class VBSubroutine(VBCodeBlock):
	"""Represents a subroutine"""
	
    public_is_global = 0 # Public objects defined here will not be globals

	&lt;&lt; VBSubroutine methods &gt;&gt;</t>
<t tx="pap.120703001453.387">&lt;&lt; VBSubroutine methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the subroutine"""
	super(VBSubroutine, self).__init__(scope)
	self.identifier = None
	self.scope = scope
	self.block = VBPass()
	self.parameters = []
    self.globals_required = {} # A list of objects required in a global statement
    self.type = None
	self.static = None
    #
	self.auto_class_handlers.update({
		"formal_param" : (VBVariable, self.parameters),
		"block" : (VBCodeBlock, "block"),
        "type_definition" : (VBUnrendered, "type"),
	})
	
	self.auto_handlers = [
			"identifier",
			"scope",
			"static",
	]
	
	self.skip_handlers = [
			"sub_definition",
	]
		
	self.rendering_locals = 0</t>
<t tx="pap.120703001453.388">&lt;&lt; VBSubroutine methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this subroutine"""
    code_block = self.block.renderAsCode(indent+1)
    locals = [declaration.renderAsCode(indent+1) for declaration in self.block.locals]
	if self.static:
		log.warn("Static function detected - static is not supported")
	ret = "\n%sdef %s(%s):\n%s%s%s" % (
				self.getIndent(indent),
				self.getParentProperty("enforcePrivateName")(self),
				self.renderParameters(),
                self.renderGlobalStatement(indent+1),
                "\n".join(locals),
				code_block)
	return ret

</t>
<t tx="pap.120703001453.389">&lt;&lt; VBSubroutine methods &gt;&gt;=

def renderParameters(self):
	"""Render the parameter list"""
	params = [param.renderAsCode() for param in self.parameters]
	if self.getParentProperty("convert_functions_to_methods"):
		params.insert(0, "self")
	return ", ".join(params)</t>
<t tx="pap.120703001453.390">&lt;&lt; VBSubroutine methods &gt;&gt;=

def resolveLocalName(self, name, rendering_locals=0, requestedby=None):
    """Convert a local name to a fully resolved name

        We search our local variables and parameters to see if we know the name. If we do then we
        return the original name.

        """
    names = [obj.identifier for obj in self.block.locals + self.parameters]
    if name in names:
        return name
    else:
        raise UnresolvableName("Name '%s' is not known in this namespace" % name)			
		</t>
<t tx="pap.120703001453.391">&lt;&lt; VBSubroutine methods &gt;&gt;=

def renderGlobalStatement(self, indent=0):
    """Render the global statement if we need it"""
    if self.globals_required:
        return "%sglobal %s\n" % (self.getIndent(indent),
                                  ", ".join(self.globals_required.keys()))
    else:
        return ""</t>
<t tx="pap.120703001453.392">&lt;&lt; VBSubroutine methods &gt;&gt;=

def assignParent(self, *args, **kw):
    """Assign our parent

        We can use this opportunity to now determine if we are a global

        """
    super(VBSubroutine, self).assignParent(*args, **kw)
    #
    # Check if we will be considered a global for the project
    if hasattr(self, "parent"):
        if self.parent.amGlobal(self.scope):
            self.registerAsGlobal()
</t>
<t tx="pap.120703001453.393">&lt;&lt; Classes &gt;&gt;=

class VBFunction(VBSubroutine):
	"""Represents a function"""
	
	is_function = 1 # We need () if we are accessed directly
	
	&lt;&lt; VBFunction methods &gt;&gt;</t>
<t tx="pap.120703001453.394">&lt;&lt; VBFunction methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this subroutine"""
	#
	# Set a name conversion to capture the function name
	# Assignments to this function name should go to the _ret parameter
	return_var = Config["Functions", "ReturnVariableName"]
	self.name_substitution[self.identifier] = return_var
	#
	if self.block:
		block = self.block.renderAsCode(indent+1)
	else:
		block = self.getIndent(indent+1) + "pass\n"
    #
    locals = [declaration.renderAsCode(indent+1) for declaration in self.block.locals]
	#
	if Config["Functions", "PreInitializeReturnVariable"] == "Yes":
		pre_init = "%s%s = None\n" % (				
				self.getIndent(indent+1),
				return_var)
	else:
		pre_init = ""

	ret = "\n%sdef %s(%s):\n%s%s%s%s%sreturn %s\n" % (
				self.getIndent(indent),
				self.getParentProperty("enforcePrivateName")(self), 
				self.renderParameters(),
                self.renderGlobalStatement(indent+1),
				pre_init,
                "\n".join(locals),
				block,
				self.getIndent(indent+1),
				return_var)
	return ret</t>
<t tx="pap.120703001453.395"></t>
<t tx="pap.120703001453.396">&lt;&lt; Classes &gt;&gt;=

class VBIf(VBCodeBlock):
	"""Represents an if block"""
	
	auto_handlers = [
	]
	
	skip_handlers = [
			"if_statement",
	]

		
	&lt;&lt; VBIf methods &gt;&gt;</t>
<t tx="pap.120703001453.397">&lt;&lt; VBIf methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the If"""
	super(VBIf, self).__init__(scope)
	#
	self.condition = None
	self.if_block = VBPass()
	self.elif_blocks = []
	self.else_block = None
	#
	self.auto_class_handlers = {
		"condition" : (VBExpression, "condition"),
		"if_block" : (VBCodeBlock, "if_block"),
		"else_if_statement" : (VBElseIf, self.elif_blocks),
		"else_block" : (VBCodeBlock, "else_block"),
	}

</t>
<t tx="pap.120703001453.398">&lt;&lt; VBIf methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	ret = self.getIndent(indent) + "if %s:\n" % self.condition.renderAsCode()
	ret += self.if_block.renderAsCode(indent+1)
	if self.elif_blocks:
		for elif_block in self.elif_blocks:
			ret += elif_block.renderAsCode(indent)
	if self.else_block:
		ret += self.getIndent(indent) + "else:\n"
		ret += self.else_block.renderAsCode(indent+1)
	return ret</t>
<t tx="pap.120703001453.399">&lt;&lt; Classes &gt;&gt;=

class VBElseIf(VBIf):
	"""Represents an ElseIf statement"""
	
	&lt;&lt; VBElseIf methods &gt;&gt;
</t>
<t tx="pap.120703001453.400">&lt;&lt; VBElseIf methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the If"""
	super(VBIf, self).__init__(scope)
	#
	self.condition = None
	self.elif_block = VBPass()
	#
	self.auto_class_handlers = {
		"condition" : (VBExpression, "condition"),
		"else_if_block" : (VBCodeBlock, "elif_block"),
	}
</t>
<t tx="pap.120703001453.401">&lt;&lt; VBElseIf methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	ret = self.getIndent(indent) + "elif %s:\n" % self.condition.renderAsCode()
	ret += self.elif_block.renderAsCode(indent+1)
	return ret</t>
<t tx="pap.120703001453.402">&lt;&lt; Classes &gt;&gt;=

class VBInlineIf(VBCodeBlock):
	"""Represents an if block"""
	
	auto_handlers = [
	]
	
	skip_handlers = [
			"if_statement",
	]

		
	&lt;&lt; VBInlineIf methods &gt;&gt;</t>
<t tx="pap.120703001453.403">&lt;&lt; VBInlineIf methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the If"""
	super(VBInlineIf, self).__init__(scope)
	#
	self.condition = None
	self.statements = []
	#
	self.auto_class_handlers = {
		"condition" : (VBExpression, "condition"),
		"statement" : (VBCodeBlock, self.statements),
		"inline_implicit_call" : (VBCodeBlock, self.statements),  # TODO: remove me
	}
</t>
<t tx="pap.120703001453.404">&lt;&lt; VBInlineIf methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	assert self.statements, "Inline If has no statements!"
		
	ret = "%sif %s:\n%s" % (
				self.getIndent(indent),
				self.condition.renderAsCode(),
				self.statements[0].renderAsCode(indent+1),)
	#
	if len(self.statements) == 2:
		ret += "%selse:\n%s" % (
				self.getIndent(indent),
				self.statements[1].renderAsCode(indent+1))
	elif len(self.statements) &gt; 2:
		raise VBParserError("Inline if with more than one clause not supported")
	#
	return ret
		
		
</t>
<t tx="pap.120703001453.405"></t>
<t tx="pap.120703001453.406">&lt;&lt; Classes &gt;&gt;=

class VBSelect(VBCodeBlock):
	"""Represents a select block"""
	
	auto_handlers = [
	]
	
	_select_variable_index = 0
		
	&lt;&lt; VBSelect methods &gt;&gt;
</t>
<t tx="pap.120703001453.407">&lt;&lt; VBSelect methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBSelect, self).__init__(scope)
	#
	self.blocks = []
	self.comment_block = VBNothing()
	#
	self.auto_class_handlers = {
		"expression" : (VBExpression, "expression"),
		"case_item_block" : (VBCaseItem, self.blocks),
		"case_else_block" : (VBCaseElse, self.blocks),
		"case_comment_block" : (VBOptionalCodeBlock, "comment_block"),
	}
	#
	# Change the variable index if we are a select
	if self.__class__ == VBSelect:
		self.select_variable_index = VBSelect._select_variable_index
		VBSelect._select_variable_index = VBSelect._select_variable_index + 1
</t>
<t tx="pap.120703001453.408">&lt;&lt; VBSelect methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	#
	# Change if/elif status on the first child
	if self.blocks:
		self.blocks[0].if_or_elif = "if"
	#
	if Config["Select", "EvaluateVariable"] &lt;&gt; "EachTime":
		ret = "%s%s = %s\n" % (self.getIndent(indent),
								 self.getSelectVariable(),
								 self.expression.renderAsCode())
	else:
		ret = ""
	ret += self.comment_block.renderAsCode()
	ret += "".join([item.renderAsCode(indent) for item in self.blocks])
	return ret</t>
<t tx="pap.120703001453.409">&lt;&lt; VBSelect methods &gt;&gt;=

def getSelectVariable(self):
	"""Return the name of the select variable"""
	eval_variable = Config["Select", "EvaluateVariable"]
	if eval_variable == "Once":
		if Config["Select", "UseNumericIndex"] == "Yes":
			select_var = "%s%d" % (Config["Select", "SelectVariablePrefix"], 
								   self.getParentProperty("select_variable_index"))
		else:
			select_var = Config["Select", "SelectVariablePrefix"]
	elif eval_variable == "EachTime":
		select_var = "%s" % self.getParentProperty("expression").renderAsCode()
	else:
		raise InvalidOption("Evaluate variable option not understood: '%s'" % eval_variable)
	return select_var
</t>
<t tx="pap.120703001453.410">&lt;&lt; Classes &gt;&gt;=

class VBCaseBlock(VBSelect):
	"""Represents a select block"""
			
	if_or_elif = "elif" # Our parent will change this if we are the first
	
	&lt;&lt; VBCaseBlock methods &gt;&gt;</t>
<t tx="pap.120703001453.411">&lt;&lt; VBCaseBlock methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBCaseBlock, self).__init__(scope)
	#
	self.lists = []
	self.expressions = []
	self.block = VBPass()
	#
	self.auto_class_handlers = {
		"case_list" : (VBCaseItem, self.lists),
		"expression" : (VBExpression, self.expressions),
		"block" : (VBCodeBlock, "block"),
	}
</t>
<t tx="pap.120703001453.412">&lt;&lt; Classes &gt;&gt;=

class VBCaseItem(VBCaseBlock):
	"""Represents a select block"""
			
	&lt;&lt; VBCaseItem methods &gt;&gt;</t>
<t tx="pap.120703001453.413">&lt;&lt; VBCaseItem methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	select_variable_index = self.getParentProperty("select_variable_index")
	if self.lists:
		expr = " or ".join(["(%s)" % item.renderAsCode() for item in self.lists])
		return "%s%s %s:\n%s" % (
					   self.getIndent(indent),
					   self.if_or_elif,
					   expr,
					   self.block.renderAsCode(indent+1))						   
	elif len(self.expressions) == 1:
		&lt;&lt; Handle single expression &gt;&gt;
	elif len(self.expressions) == 2:
		return "%s &lt;= %s &lt;= %s" % (
									   self.expressions[0].renderAsCode(),
									   self.getSelectVariable(),
									   self.expressions[1].renderAsCode())
	raise VBParserError("Error rendering case item")</t>
<t tx="pap.120703001453.414">&lt;&lt; Classes &gt;&gt;=

class VBCaseElse(VBCaseBlock):
	"""Represents a select block"""
			
	&lt;&lt; VBCaseElse methods &gt;&gt;</t>
<t tx="pap.120703001453.415">&lt;&lt; VBCaseElse methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return "%selse:\n%s" % (self.getIndent(indent),
							 self.block.renderAsCode(indent+1))
</t>
<t tx="pap.120703001453.416">&lt;&lt; Classes &gt;&gt;=

class VBFor(VBCodeBlock):
	"""Represents a for statement"""
	
    _for_variable_index = 0

	&lt;&lt; VBFor methods &gt;&gt;</t>
<t tx="pap.120703001453.417">&lt;&lt; VBFor methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBFor, self).__init__(scope)
	#
	self.block = VBPass()
	self.expressions = []
	#
	self.auto_class_handlers = {
		"expression" : (VBExpression, self.expressions),
		"block" : (VBCodeBlock, "block"), # Used for full 'for'
		"body" : (VBCodeBlock, "block"),  # Used for inline 'for'
	}
	
	self.auto_handlers = [
		"object",
	]
</t>
<t tx="pap.120703001453.418">&lt;&lt; VBFor methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	range_statement = ", ".join([item.renderAsCode() for item in self.expressions])
    # Watch out for the weird dotted name in the for
    self.handleDottedName(indent)
	return "%sfor %s in vbForRange(%s):\n%s%s" % (
							 self.getIndent(indent),
							 self.loopname,
							 range_statement,
                             self.copiedname,
							 self.block.renderAsCode(indent+1))
</t>
<t tx="pap.120703001453.419">&lt;&lt; Classes &gt;&gt;=

class VBForEach(VBFor):
	"""Represents a for each statement"""
	
	&lt;&lt; VBForEach methods &gt;&gt;</t>
<t tx="pap.120703001453.420">&lt;&lt; VBForEach methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
    # Watch out for the weird dotted name in the for
    self.handleDottedName(indent)    
	return "%sfor %s in %s:\n%s%s" % (
							 self.getIndent(indent),
							 self.loopname,
							 self.expressions[0].renderAsCode(),
                             self.copiedname,
							 self.block.renderAsCode(indent+1))
</t>
<t tx="pap.120703001453.421">&lt;&lt; Classes &gt;&gt;=

class VBWhile(VBCodeBlock):
	"""Represents a while statement"""
	
	&lt;&lt; VBWhile methods &gt;&gt;</t>
<t tx="pap.120703001453.422">&lt;&lt; VBWhile methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBWhile, self).__init__(scope)	
	#
	self.block = VBPass()
	self.expression = None
	#
	self.auto_class_handlers = {
		"expression" : (VBExpression, "expression"),
		"block" : (VBCodeBlock, "block"),
	}
</t>
<t tx="pap.120703001453.423">&lt;&lt; VBWhile methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render this element as code"""
	return "%swhile %s:\n%s" % (
						self.getIndent(indent),
						self.expression.renderAsCode(),
						self.block.renderAsCode(indent+1))</t>
<t tx="pap.120703001453.424">&lt;&lt; Classes &gt;&gt;=

class VBDo(VBCodeBlock):
	"""Represents a do statement"""
	
	&lt;&lt; VBDo methods &gt;&gt;</t>
<t tx="pap.120703001453.425">&lt;&lt; VBDo methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBDo, self).__init__(scope)
	#
	self.block = VBPass()
	self.pre_while = None
	self.pre_until = None
	self.post_while = None
	self.post_until = None
	#
	self.auto_class_handlers = {
		"while_clause" : (VBExpression, "pre_while"),
		"until_clause" : (VBExpression, "pre_until"),
		"post_while_clause" : (VBExpression, "post_while"),
		"post_until_clause" : (VBExpression, "post_until"),
		"block" : (VBCodeBlock, "block"),
	}
	
</t>
<t tx="pap.120703001453.426">&lt;&lt; VBDo methods &gt;&gt;=

def renderAsCode(self, indent=0):
    """Render this element as code

        There are five different kinds of do loop
            pre_while
            pre_until
            post_while
            post_until
            no conditions

        """
    if self.pre_while:
        return "%swhile %s:\n%s" % (
                        self.getIndent(indent),
                        self.pre_while.renderAsCode(),
                        self.block.renderAsCode(indent+1))
    elif self.pre_until:
        return "%swhile not (%s):\n%s" % (
                        self.getIndent(indent),
                        self.pre_until.renderAsCode(),
                        self.block.renderAsCode(indent+1))
    elif self.post_while:
        return "%swhile 1:\n%s%sif not (%s):\n%sbreak\n" % (
                        self.getIndent(indent),
                        self.block.renderAsCode(indent+1),
                        self.getIndent(indent+1),
                        self.post_while.renderAsCode(),
                        self.getIndent(indent+2))
    elif self.post_until:
        return "%swhile 1:\n%s%sif %s:\n%sbreak\n" % (
                        self.getIndent(indent),
                        self.block.renderAsCode(indent+1),
                        self.getIndent(indent+1),
                        self.post_until.renderAsCode(),
                        self.getIndent(indent+2))						
    else:
        return "%swhile 1:\n%s" % (
                        self.getIndent(indent),
                        self.block.renderAsCode(indent+1))</t>
<t tx="pap.120703001453.427">&lt;&lt; Classes &gt;&gt;=

class VBWith(VBCodeBlock):
	"""Represents a with statement"""
	
	_with_variable_index = 0
	
	&lt;&lt; VBWith methods &gt;&gt;
</t>
<t tx="pap.120703001453.428">&lt;&lt; VBWith methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBWith, self).__init__(scope)
	#
	self.block = None
	self.expression = None
	#
	self.auto_class_handlers = {
		"expression" : (VBExpression, "expression"),
		"block" : (VBCodeBlock, "block"),
	}
	#
	self.with_variable_index = VBWith._with_variable_index
	VBWith._with_variable_index = VBWith._with_variable_index + 1
</t>
<t tx="pap.120703001453.429">&lt;&lt; VBWith methods &gt;&gt;=

def renderAsCode(self, indent=0):
    """Render this element as code"""
    #
    # Don't even do anything if there is no body to the With
    if self.block:
        #
        # Before we render the expression we change its parent to our parent because
        # we don't want any ".implicit" objects to be evaluated using our With object
        self.expression.parent = self.parent
        #
        if self.checkOptionChoice("With", "EvaluateVariable", ("EveryTime", "Once")) == "EveryTime":
            self.with_object = self.expression.renderAsCode()
            return self.block.renderAsCode(indent)
        else:
            if self.checkOptionYesNo("With", "UseNumericIndex") == "Yes":
                varname = "%s%d" % (Config["With", "WithVariablePrefix"],
                                    self.with_variable_index)
            else:
                varname = Config["With", "WithVariablePrefix"]

            self.with_object = varname

            return "%s%s = %s\n%s" % (
                            self.getIndent(indent),
                            varname,
                            self.expression.renderAsCode(),
                            self.block.renderAsCode(indent))
    else:
        return ""
</t>
<t tx="pap.120703001453.430">&lt;&lt; Classes &gt;&gt;=

class VBProperty(VBSubroutine):
	"""Represents a property definition"""
	
	&lt;&lt; VBProperty methods &gt;&gt;
</t>
<t tx="pap.120703001453.431">&lt;&lt; VBProperty methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBProperty, self).__init__(scope)
	self.property_decorator_type = None
	#
	self.auto_handlers.append("property_decorator_type")
</t>
<t tx="pap.120703001453.432">&lt;&lt; VBProperty methods &gt;&gt;=

def renderPropertyGroup(self, indent, name, Let=None, Set=None, Get=None):
	"""Render a group of property statements"""
	if Let and Set:
		raise UnhandledStructureError("Cannot handle both Let and Set properties for an object")
	
	log.info("Rendering property group '%s'" % name)
	
	ret = []
	params = []
	pset = Let or Set
	pget = Get
	
    #
    # Get the name for this property - respecting the hidden status
    obj = pset or pget # Need at least one!
    proper_name = self.getParentProperty("enforcePrivateName")(obj)
    
	if pset:
        self.getParentProperty("local_names").append(pset.identifier) # Store property name for namespace analysis
		pset.identifier = "%s%s" % (Config["Properties", "LetSetVariablePrefix"], pset.identifier)		
		ret.append(pset.renderAsCode(indent))
		params.append("fset=%s" % self.getParentProperty("enforcePrivateName")(pset))
	if pget:
        self.getParentProperty("local_names").append(pget.identifier) # Store property name for namespace analysis
		pget.__class__ = VBFunction # Needs to be a function
		pget.name_substitution[pget.identifier] = Config["Functions", "ReturnVariableName"]
		pget.identifier = "%s%s" % (Config["Properties", "GetVariablePrefix"], pget.identifier)		
		ret.append(pget.renderAsCode(indent))
		params.append("fget=%s" % self.getParentProperty("enforcePrivateName")(pget))

	return "\n%s%s%s = property(%s)\n" % (
				"".join(ret),
				self.getIndent(indent),
				proper_name,
				", ".join(params))
				
				


</t>
<t tx="pap.120703001453.433"></t>
<t tx="pap.120703001453.434">&lt;&lt; Classes &gt;&gt;=

class VBEnum(VBCodeBlock):
	"""Represents an enum definition"""
	
	&lt;&lt; VBEnum methods &gt;&gt;
</t>
<t tx="pap.120703001453.435">&lt;&lt; VBEnum methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBEnum, self).__init__(scope)
	self.enumerations = []
    self.identifier = None
	#
	self.auto_class_handlers = {
            "enumeration_item" : (VBEnumItem, self.enumerations),
        }

    self.auto_handlers = ["identifier"]</t>
<t tx="pap.120703001453.436">&lt;&lt; VBEnum methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""Render a group of property statements"""
    count = 0
	ret = []
	for enumeration in self.enumerations:
		if enumeration.expression:
			cnt = enumeration.expression.renderAsCode()
		else:
			cnt = count
			count += 1
		ret.append("%s%s = %s" % (self.getIndent(indent),
								  enumeration.identifier.element.text,
								  cnt))
		
    return "%s# Enumeration '%s'\n%s\n" % (
                        self.getIndent(indent),
                        self.identifier,
                        "\n".join(ret),
                )
				



</t>
<t tx="pap.120703001453.437">&lt;&lt; Classes &gt;&gt;=

class VBEnumItem(VBCodeBlock):
	"""Represents an enum item"""
	
	&lt;&lt; VBEnumItem methods &gt;&gt;
</t>
<t tx="pap.120703001453.438">&lt;&lt; VBEnumItem methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the Select"""
	super(VBEnumItem, self).__init__(scope)
    self.identifier = None
    self.expression = None
	#
	self.auto_class_handlers = {
            "identifier" : (VBConsumer, "identifier"),
            "expression" : (VBExpression, "expression"),
        }

</t>
<t tx="pap.120703001453.439"></t>
<t tx="pap.120703001453.440">&lt;&lt; Classes &gt;&gt;=

class VB2PYDirective(VBCodeBlock):
	"""Handles a vb2py directive"""
	
	skip_handlers = [
			"vb2py_directive",
	]
    
	would_end_docstring = 0

	&lt;&lt; VB2PYDirective methods &gt;&gt;</t>
<t tx="pap.120703001453.441">&lt;&lt; VB2PYDirective methods &gt;&gt;=

def __init__(self, scope="Private"):
	"""Initialize the module"""
	super(VB2PYDirective, self).__init__(scope)
	self.auto_handlers = (
		"directive_type",
		"config_name",
        "config_section",
        "expression",
	)
    self.directive_type = "Set"
    self.config_name = None
    self.config_section = None
    self.expression = None</t>
<t tx="pap.120703001453.442">&lt;&lt; VB2PYDirective methods &gt;&gt;=

def renderAsCode(self, indent=0):
	"""We use the rendering to do our stuff"""
    if self.directive_type == "Set":
        Config.setLocalOveride(self.config_section, self.config_name, self.expression)
        log.info("Doing a set: %s" % str((self.config_section, self.config_name, self.expression)))
    elif self.directive_type == "Unset":
        Config.removeLocalOveride(self.config_section, self.config_name)
        log.info("Doing an uset: %s" % str((self.config_section, self.config_name)))
    elif self.directive_type in ("GlobalSet", "GlobalAdd"):
        pass # already handled this
    elif self.directive_type == "Add":
        Config.addLocalOveride(self.config_section, self.config_name, self.expression)
        log.info("Adding a setting: %s" % str((self.config_section, self.config_name, self.expression)))
    else:
        raise DirectiveError("Directive not understood: '%s'" % self.directive_type)
    return ""</t>
<t tx="pap.120703001453.443">&lt;&lt; VB2PYDirective methods &gt;&gt;=

def assignParent(self, *args, **kw):
    """Assign our parent

        We can use this opportunity to now determine if we are a global

        """
    super(VB2PYDirective, self).assignParent(*args, **kw)
    #
    # Check if we are a global level option - if se we set it now
    if self.directive_type == "GlobalSet":
        Config.setLocalOveride(self.config_section, self.config_name, self.expression)
    elif self.directive_type == "GlobalAdd":
        Config.addLocalOveride(self.config_section, self.config_name, self.expression)
</t>
<t tx="pap.120703001453.444">&lt;&lt; Classes &gt;&gt;=

class VBPass(VBCodeBlock):
	"""Represents an empty statement"""
	
	def renderAsCode(self, indent=0):
		"""Render it!"""
		return "%spass\n" % (self.getIndent(indent),)
</t>
<t tx="pap.120703001453.445">&lt;&lt; Classes &gt;&gt;=

class VBRenderDirect(VBCodeBlock):
	"""Represents a pre-rendered statement"""
	
	def __init__(self, text, indent=0, crlf=0):
		"""Initialize"""
		super(VBRenderDirect, self).__init__()
		self.identifier = text
		self.indent = indent
		self.crlf = crlf
		
	def renderAsCode(self, indent=0):
		"""Render it!"""
		s = ""
		if self.indent:
			s += self.getIndent(indent)
		s += self.identifier
		if self.crlf:
			s += "\n"
		return s

    def asString(self):
        """Return string representation"""
        return self.identifier </t>
<t tx="pap.120703001453.446">&lt;&lt; Classes &gt;&gt;=

class VBNothing(VBCodeBlock):
	"""Represents a block which renders to nothing at all"""
	
	def renderAsCode(self, indent=0):
		"""Render it!"""
		return ""
</t>
<t tx="pap.120703001453.447">&lt;&lt; Classes &gt;&gt;=

class VBParserFailure(VBConsumer):
	"""Represents a block which failed to parse"""
	
	def renderAsCode(self, indent=0):
		"""Render it!"""
		fail_option = Config["General", "InsertIntoFailedCode"].lower()
		warn = self.getWarning("ParserError", self.element.text, indent, crlf=1) + \
		       self.getWarning("ParserStop", "Conversion of VB code halted", indent, crlf=1)
		if fail_option == "exception":
			warn += "%sraise NotImplemented('VB2PY Code conversion failed at this point')" % self.getIndent(indent)
		elif fail_option == "warning":
			warn += "%simport warnings;warnings.warn('VB2PY Code conversion failed at this point')" % self.getIndent(indent)
		#
		return warn</t>
<t tx="pap.120703001453.448"></t>
<t tx="pap.120703001453.449">@root vbclasses.py

"""
Classes which mimic the behaviour of VB classes

- Collection
"""

import vbfunctions
import time
import os
import sys

&lt;&lt; VB Classes &gt;&gt;
</t>
<t tx="pap.120703001453.450">&lt;&lt; VB Classes &gt;&gt;=

class Collection(dict):
    """A Collection Class
	
    An implementation of Visual Basic Collections.
    This implementation assumes that indexing by integers is rare and
    that memory is a less scarce resource than CPU time.
	
	Based on original code submitted by Jacob Halln.
	
    """
	
	&lt;&lt; Collection Methods &gt;&gt;    




if __name__ == '__main__':
    # Tests
    c = Collection()
    c['a'] = 'va'
    c['b'] = 'vb'
    print c['a']
    print c[2]
    del c[1]
    print c[1]
</t>
<t tx="pap.120703001453.451"></t>
<t tx="pap.120703001453.452">&lt;&lt; Collection Methods &gt;&gt;=     

def __init__(self):
    dict.__init__(self)
	# self.insertOrder is used as the relative index when the collection
	# is treated as an array.
	# It is also used as the dictionary key for entries that have no
	# assigned key. This always works because VB keys can only be strings. 
    self.insertOrder = 1</t>
<t tx="pap.120703001453.453">&lt;&lt; Collection Methods &gt;&gt;=     

def __setitem__(self, Key, Item):
	if isinstance(Key, int):
		raise TypeError("Index must be a non-numeric string")
	if Key is None:
		Key = self.insertOrder
	dict.__setitem__(self, Key, (Item, self.insertOrder, Key))
	self.insertOrder += 1
</t>
<t tx="pap.120703001453.454">&lt;&lt; Collection Methods &gt;&gt;=     

def __getitem__(self, Key):
	try:
		Key = int(Key)
		if Key &lt; 1:
			raise IndexError
		list = self.values()
		list.sort(self._order)
		return list[Key-1][0]
	except ValueError:
		return dict.__getitem__(self, Key)[0]
	</t>
<t tx="pap.120703001453.455">&lt;&lt; Collection Methods &gt;&gt;=     

def __delitem__(self, Key):
	try:
		key = int(Key)
		list = self.values()
		list.sort(self._order)
		_, _, key = list[Key-1]
	except ValueError:
		pass
	dict.__delitem__(self, Key)
</t>
<t tx="pap.120703001453.456">&lt;&lt; Collection Methods &gt;&gt;=     

def __call__(self, Key):
	return self.Item(Key)</t>
<t tx="pap.120703001453.457">&lt;&lt; Collection Methods &gt;&gt;=     

def __iter__(self):
	lst = self.values()
	lst.sort(self._order)
	return iter([val[0] for val in lst])
</t>
<t tx="pap.120703001453.458">&lt;&lt; Collection Methods &gt;&gt;=     

def _getElement(self, Key):
	if isinstance(Key, int):
		list = self.values()
		list.sort(self._order)
		return list[Key-1]
	else:
		return dict.__getitem__(self, Key)
</t>
<t tx="pap.120703001453.459">&lt;&lt; Collection Methods &gt;&gt;=     

def _order(self, a, b):
	# Equality is impossible
	if a[1] &lt; b[1]:
		return -1
	else:
		return 1</t>
<t tx="pap.120703001453.460">&lt;&lt; Collection Methods &gt;&gt;=     

def Add(self, Item, Key=None, Before=None, After=None):
	"""
	Add's an item with an optional key. The item can also be added
	before or after an existing item. The before/after parameters
	can either be integer indices or keys.
	**kw can contain
	- key
	- before
	- after
	before and after exclude each other
	"""
	if Before is None and After is None: 
		self[Key] = Item
	
	elif Before is not None and After is None:
		_, order, _ = self._getElement(Before)
		for k, entry in self.iteritems():
			if entry[1] &gt;= order:
				dict.__setitem__(self, k, (entry[0], entry[1]+1, k))
		if not isinstance(Key, str):
			Key = self.insertOrder
		dict.__setitem__(self, Key, (Item, order, Key))
		self.insertOrder += 1
	
	elif After is not None and Before is None:
		_, order, _ = self._getElement(After)
		for k, entry in self.iteritems():
			if entry[1] &gt; order:
				dict.__setitem__(self, k, (entry[0], entry[1]+1, k))
		if not isinstance(Key, str):
			Key = self.insertOrder
		dict.__setitem__(self, Key, (Item, order+1, Key))
		self.insertOrder += 1
	
	else:
		raise VB2PYCodeError("Can't specify both 'before' and 'after' parameters to Collection.Add")
</t>
<t tx="pap.120703001453.461">&lt;&lt; Collection Methods &gt;&gt;=     

def Count(self):
	"""Return the length of the collection"""
	return len(self)</t>
<t tx="pap.120703001453.462">&lt;&lt; Collection Methods &gt;&gt;=     

def Remove(self, Key):
	"""Remove an item from the collection"""
	self.__delitem__(Key)</t>
<t tx="pap.120703001453.463">&lt;&lt; Collection Methods &gt;&gt;= 
    
def Item(self, Key):
	"""Get an item from the collection"""
	return self.__getitem__(Key)</t>
<t tx="pap.120703001453.464">&lt;&lt; VB Classes &gt;&gt;=

class _DebugClass:
	"""Intercept calls to Debug.Print"""
	
	_logger = None
	
	def Print(self, *args):
		"""Print debugging output"""
		if self._logger:
			self._logger.debug("\t".join([str(arg) for arg in args]))
			
Debug = _DebugClass()			</t>
<t tx="pap.120703001453.465">&lt;&lt; VB Classes &gt;&gt;=

class _TimeClass(str):
	"""Represent the current time"""
	
	def __repr__(self):
		return time.ctime()
		
	__str__ = __repr__
		
Time = _TimeClass()			
</t>
<t tx="pap.120703001453.466">&lt;&lt; VB Classes &gt;&gt;=

class Integer(int):
	"""Python version of VB's integer"""
</t>
<t tx="pap.120703001453.467">&lt;&lt; VB Classes &gt;&gt;=

class Single(float):
	"""Python version of VB's Single"""
</t>
<t tx="pap.120703001453.468">&lt;&lt; VB Classes &gt;&gt;=

class Double(float):
	"""Python version of VB's Double"""
</t>
<t tx="pap.120703001453.469">&lt;&lt; VB Classes &gt;&gt;=

class Long(int):
	"""Python version of VB's Long"""
</t>
<t tx="pap.120703001453.470">&lt;&lt; VB Classes &gt;&gt;=

class Boolean(int):
	"""Python version of VB's Boolean"""
</t>
<t tx="pap.120703001453.471">&lt;&lt; VB Classes &gt;&gt;=

class Byte(int):
	"""Python version of VB's Byte"""
</t>
<t tx="pap.120703001453.472">&lt;&lt; VB Classes &gt;&gt;=

class Object(object):
	"""Python version of VB's Object"""
</t>
<t tx="pap.120703001453.473">&lt;&lt; VB Classes &gt;&gt;=

class Variant(float):
	"""Python version of VB's Variant"""
</t>
<t tx="pap.120703001453.474">&lt;&lt; VB Classes &gt;&gt;=

class FixedString(str):
	"""Python version of VB's fixed length string"""

	def __new__(cls, length):
		"""Initialize the string"""
		return " "*length</t>
<t tx="pap.120703001453.475">&lt;&lt; VB Classes &gt;&gt;=

def IsMissing(argument):
	"""Check if an argument was omitted from a function call
	
	Missing arguments default to the VBMissingArgument class so
	we just check if the argument is an instance of this type and
	return true if this is the case.
	
	"""
	try:
		return argument._missing
	except AttributeError:
		return 0</t>
<t tx="pap.120703001453.476">&lt;&lt; VB Classes &gt;&gt;=

class VBArray(list):
	"""Represents an array in VB
	
	This is basically a list but we use the __call__ syntax to
	access indexes of the array
	
	"""
	
	&lt;&lt; VBArray methods &gt;&gt;</t>
<t tx="pap.120703001453.477">&lt;&lt; VBArray methods &gt;&gt;=

def __init__(self, size, init_type=None):
	"""Initialize with a size or a low and upper bound"""
	if not isinstance(size, tuple) == 1:
		size = (0, size)
	self._min, self._max = size
	if init_type:
		for i in range(size[0], size[1]+1):
			self.append(init_type())
		self.init_type = init_type
	else:
		self.init_type = Variant</t>
<t tx="pap.120703001453.478">&lt;&lt; VBArray methods &gt;&gt;=

def __call__(self, *args):
	"""Index the array"""
	return self.__getitem__(args)</t>
<t tx="pap.120703001453.479">&lt;&lt; VBArray methods &gt;&gt;=

def __setitem__(self, index, value):
	"""Set an item in the array"""
	if isinstance(index, tuple):
		if len(index) == 1:
			myindex, rest = index[0], ()
		else:
			myindex, rest = index[0], index[1:]
	else:
		myindex, rest = index, ()
	if rest:
		list.__getitem__(self, myindex-self._min).__setitem__(rest, value)
	else:
		list.__setitem__(self, myindex-self._min, value)</t>
<t tx="pap.120703001453.480">&lt;&lt; VBArray methods &gt;&gt;=

def __getitem__(self, args):
	"""Get an item from the array"""
	if isinstance(args, tuple):
		if len(args) == 1:
			myindex, rest = args[0], ()
		else:
			myindex, rest = args[0], args[1:]
	else:
		myindex, rest = args, ()
	if self._min &lt;= myindex &lt;= self._max:
		if rest:
			return list.__getitem__(self, myindex-self._min).__getitem__(rest)
		else:
			return list.__getitem__(self, myindex-self._min)		
	else:
		raise IndexError("Index '%d' is out of range (%d, %d)" % (myindex, self._min, self._max))</t>
<t tx="pap.120703001453.481">&lt;&lt; VBArray methods &gt;&gt;=

def __ubound__(self, dimension=1):
	"""Return the upper bound"""
	if dimension &lt;= 0:
		raise ValueError("Invalid dimension for UBound: %s" % dimension)
	elif dimension == 1:
		return self._max
	else:
		return self[self._min].__ubound__(dimension-1)</t>
<t tx="pap.120703001453.482">&lt;&lt; VBArray methods &gt;&gt;=

def __lbound__(self, dimension=1):
	"""Return the lower bound"""
	if dimension &lt;= 0:
		raise ValueError("Invalid dimension for LBound: %s" % dimension)
	elif dimension == 1:
		return self._min
	else:
		return self[self._min].__lbound__(dimension-1)</t>
<t tx="pap.120703001453.483">&lt;&lt; VBArray methods &gt;&gt;=

def __contents__(self, pre=()):
	"""Iterate over the contents of the array"""
	idx = 0
	ret = []
	for item in self:
		if isinstance(item, VBArray):
			ret.extend(item.__contents__(pre + (idx,)))
		else:
			ret.append((pre+(idx,), item))
		idx +=1
	return ret</t>
<t tx="pap.120703001453.484">&lt;&lt; VBArray methods &gt;&gt;=

def __copyto__(self, other):
	"""Copy our values to another array"""
	for index, value in self.__contents__():
		try:
			other.__setitem__(index, value)
		except IndexError:
			pass # Throw away values which aren't in the new range</t>
<t tx="pap.120703001453.485">&lt;&lt; VBArray methods &gt;&gt;=

def createFromData(cls, data):
	"""Create an array from some data"""
	arr = cls(len(data))
	arr.extend(data)
	return arr
	
createFromData = classmethod(createFromData)	
</t>
<t tx="pap.120703001453.486">&lt;&lt; VBArray methods &gt;&gt;=

def erase(self):
	"""Return this array to its initial form"""
	for element in self:
		try:
			element.erase()
		except AttributeError:
			self[:] = []
			self.__init__((self._min, self._max), self.init_type)
		
	
</t>
<t tx="pap.120703001453.487">&lt;&lt; VB Classes &gt;&gt;=

import threading

class _VBFiles:
	"""A class to control all interfaces to the file system
	
	This is required since VB accesses files through channel numbers rather than
	file objects. Since a channel number might be an expression that is evaluated at
	runtime we can't do a static conversion.
	
	The solution used here is to have a global object which everyone interfaces to when
	doing reading and writing to files. This object maintains the list of open channels 
	and marshalls all read and write operations.
	
	"""
	
	&lt;&lt; VBFiles methods &gt;&gt;


VBFiles = _VBFiles()</t>
<t tx="pap.120703001453.488">&lt;&lt; VBFiles methods &gt;&gt;=

def __init__(self):
	"""Initialize the file interface"""
	self._channels = {}
	self._lock = threading.Lock()</t>
<t tx="pap.120703001453.489">&lt;&lt; VBFiles methods &gt;&gt;=

def openFile(self, channelid, filename, mode):
	"""Open a file
	
	If the channel is already one then close it. There are likely to be some
	race conditions here in multithreaded applications so we use a lock to make
	this entire process atomic.
	
	"""
	self._lock.acquire()
	try:
		try:
			old_file = self._channels[channelid]
		except KeyError:
			pass
		else:
			old_file.close()
		#
		self._channels[channelid] = open(filename, mode)
	finally:
		self._lock.release()</t>
<t tx="pap.120703001453.490">&lt;&lt; VBFiles methods &gt;&gt;=

def closeFile(self, channelid=None):
	"""Close a file
	
	TODO - what should the error be if there is no file open?
	
	"""
	if channelid is None:
		for channel in self._channels.keys():
			self.closeFile(channel)
	else:
		self._channels[channelid].close()
		del(self._channels[channelid])
</t>
<t tx="pap.120703001453.491">&lt;&lt; VBFiles methods &gt;&gt;=

def getInput(self, channelid, number, separators=None, evaloutput=1):
	"""Get data from a file
	
	VB nicely parses the input from files into variables so we have to mimic this
	here. 
	
	For safety sake we go one character at a time here. TODO: find out how VB does this
	and what the implications of chunking would be in a multithreaded app.
	
	We use the lock to prevent multiple reads.
	
	"""
	if separators is None:
		separators = ("\n", ",", "\t", "")
	#
	self._lock.acquire()
	try:
		vars = []
		f = self._channels[channelid]
		buffer = ""
		while len(vars) &lt; number:
			char = f.read(1)
			if char in separators:
				if evaloutput:
					# Try to eval it - if we get a syntax error then assume it is a string
					try:
						vars.append(eval(buffer))
					except SyntaxError:
						vars.append(buffer)
				else:
					vars.append(buffer)
				buffer = ""	
			else:
				buffer += char
	finally:
		self._lock.release()
	#	
	if number == 1:
		return vars[0]
	else:
		return vars</t>
<t tx="pap.120703001453.492">&lt;&lt; VBFiles methods &gt;&gt;=

def getLineInput(self, channelid, number=1):
	"""Get data from a file one line at a time with no parsing"""
	return self.getInput(channelid, number, separators=("\n", ""), evaloutput=0)
	
	
</t>
<t tx="pap.120703001453.493">&lt;&lt; VBFiles methods &gt;&gt;=

def writeText(self, channelid, *args):
	"""Write data to the file
	
	We write with tabs separating the variables that are given in the *args parameter. The 
	lock is used to protect this section in multithreaded environments.
	
	If the channelid is None then this is a bare Print statement which we
	send using Python's normal 'print'. TODO: Is this really what VB does?
	
	"""
	output = "".join([str(arg) for arg in args])
	if channelid is None:
		print output
	else:
		self._lock.acquire()
		try:
			if args:
				self._channels[channelid].write(output)
			else:
				self._channels[channelid].write("\n")
		finally:
			self._lock.release()
		
</t>
<t tx="pap.120703001453.494">&lt;&lt; VBFiles methods &gt;&gt;=

def seekFile(self, channelid, position):
	"""Move to the specified point in the given channel"""
	self._channels[channelid].seek(position-1) # VB starts at 1
	</t>
<t tx="pap.120703001453.495">&lt;&lt; VBFiles methods &gt;&gt;=

def getFile(self, channelid):
	"""Return the underlying file link to a channel"""
	return self._channels[channelid]
	</t>
<t tx="pap.120703001453.496">&lt;&lt; VBFiles methods &gt;&gt;=

def getChars(self, channelid, length):
	"""Return the specified number of characters from a file"""
	return self._channels[channelid].read(length)
	</t>
<t tx="pap.120703001453.497">&lt;&lt; VBFiles methods &gt;&gt;=

def getOpenChannels(self):
	"""Return a list of currently open channels"""
	return self._channels.keys()
	

	</t>
<t tx="pap.120703001453.498">&lt;&lt; VB Classes &gt;&gt;=


class _App:
	"""Represents the App object in VB"""
	
	def __init__(self):
		"""Initialize the App objects"""
		# Application path is the path of the file we exectuted to run this
		self.Path = os.path.split(os.path.abspath(sys.argv[0]))[0]
	
	
App = _App()	
</t>
<t tx="pap.120703001453.499">@root vbfunctions.py

"""
Functions to mimic VB intrinsic functions or things
"""

from __future__ import generators

from vbclasses import *
from vbconstants import *
import utils
import config

import math
import sys
import fnmatch # For Like
import glob    # For Dir
import os
import shutil # For FileCopy
import random # For Rnd, Randomize
import time   # For timing
import inspect
import new

&lt;&lt; Error classes &gt;&gt;
&lt;&lt; VBFunctions &gt;&gt;</t>
<t tx="pap.120703001453.500">@c

class VB2PYCodeError(Exception): """An error occured executing a vb2py function"""

class VB2PYNotSupported(VB2PYCodeError): """The requested function is not supported"""



class VB2PYFileError(VB2PYCodeError): """Some kind of file error"""
class VB2PYEndOfFile(VB2PYFileError): """Reached the end of file"""</t>
<t tx="pap.120703001453.501">&lt;&lt; VBFunctions &gt;&gt;=

class VBMissingArgument:
	"""A generic class to represent an argument omitted from a call"""
	
	_missing = 1</t>
<t tx="pap.120703001453.502">&lt;&lt; VBFunctions &gt;&gt;=

def vbForRange(start, stop, step=1):
	"""Mimic the range in a for statement
	
	VB's range is inclusive and can include non-integer elements so
	we use an generator. 
	
	"""
	num_repeats = (stop-start)/step
	if num_repeats &lt; 0:
		raise StopIteration
	current = start
	while num_repeats &gt;= 0:
		yield current
		current += step
		num_repeats -= 1
</t>
<t tx="pap.120703001453.503">&lt;&lt; VBFunctions &gt;&gt;=

def vbObjectInitialize(size=None, objtype=None, preserve=None):
	"""Return a new object with the given size and type"""
	if size is None:
		size = [0]
	#
	# Create the object
	def getObj():
		if len(size) == 1:
			return objtype()
		else:
			return vbObjectInitialize(size[1:], objtype)
	ret = VBArray(size[0], getObj)
	#
	# Preserve the old values if needed
	if preserve is not None:
		preserve.__copyto__(ret)
	return ret


</t>
<t tx="pap.120703001453.504">&lt;&lt; VBFunctions &gt;&gt;=

def vbGetEventArgs(names, arguments):
	"""Return arguments passed in an event
	
	VB Control events have parameters passed in the call, eg MouseMove(Button, Shift, X, Y).
	In PythonCard the event parameters are all passed as a single event object. We
	can easily unpack the attributes back to the values in the Event Handler but
	we also have to account for the fact that someone might call the Handler
	directly and therefore assume that they can pass parameters individually.
	
	This function tries to unpack the params from an event object and, if
	successful, returns them as a tuple. If this fails then it tries to 
	assume that they were already in a tuple and return them that way.
	
	This can still fail if there are keyword arguments ... TODO!
	
	"""
	# arguments is the *args tuple
	#
	# Is there only one parameter
	if len(arguments) == 1:
		# Try to unpack names from this argument
		try:
			ret = []
			for name in names:
				if name.endswith("()"):
					ret.append(getattr(arguments[0], name[:-2])())
				else:
					ret.append(getattr(arguments[0], name))
			return ret
		except AttributeError:
			pass
	# If we have as many arguments as we need then just return them
	if len(names) == len(arguments):
		return arguments
	# Couldn't unpack the event and didn't have the right number of args so we are dead
	raise VB2PYCodeError("EventHandler couldn't unpack arguments")</t>
<t tx="pap.120703001453.505">&lt;&lt; VBFunctions &gt;&gt;=

def Left(text, number):
	"""Return the left most characters in the text"""
	return text[:number]
</t>
<t tx="pap.120703001453.506">&lt;&lt; VBFunctions &gt;&gt;=

def Right(text, number):
	"""Return the right most characters in the text"""
	return text[-number:]
</t>
<t tx="pap.120703001453.507">&lt;&lt; VBFunctions &gt;&gt;=

def Mid(text, start, num=None):
	"""Return some characters from the text"""
	if num is None:
		return text[start-1:]
	else:
		return text[(start-1):(start+num-1)]
</t>
<t tx="pap.120703001453.508">&lt;&lt; VBFunctions &gt;&gt;=

def Sgn(num):
	"""Return the sign of a number"""
	n = float(num)
	if n &lt; 0:
		return -1
	elif n == 0:
		return 0
	else:
		return 1</t>
<t tx="pap.120703001453.509">&lt;&lt; VBFunctions &gt;&gt;=

def CBool(num):
	"""Return the boolean version of a number"""
	n = float(num)
	if n:
		return 1
	else:
		return 0</t>
<t tx="pap.120703001453.510">&lt;&lt; VBFunctions &gt;&gt;=

def Int(num):
	"""Return the int of a value"""
	n = float(num)
	if -32767 &lt;= n &lt;= 32767: 
		return int(n)
	else:
		raise ValueError("Out of range in Int (%s)" % n)
	
def CByte(num):
	"""Return the closest byte of a value"""
	n = round(float(num))
	if 0 &lt;= n &lt;= 255: 
		return int(n)
	else:
		raise ValueError("Out of range in CByte (%s)" % n)

def CInt(num):
	"""Return the closest int of a value"""
	n = round(float(num))
	if -32767 &lt;= n &lt;= 32767: 
		return int(n)
	else:
		raise ValueError("Out of range in Int (%s)" % n)
	
def CLng(num):
	"""Return the closest long of a value"""
	return long(round(float(num)))	</t>
<t tx="pap.120703001453.511">&lt;&lt; VBFunctions &gt;&gt;=

def Sqr(num):
	"""Return the square root of a value"""
	return math.sqrt(float(num))

def Sin(num):
	"""Return the sin of a value"""
	return math.sin(float(num))

def Cos(num):
	"""Return the cosine of a value"""
	return math.cos(float(num))

def Tan(num):
	"""Return the tangent of a value"""
	return math.tan(float(num))

def Atn(num):
	"""Return the arc-tangent of a value"""
	return math.atan(float(num))
</t>
<t tx="pap.120703001453.512">&lt;&lt; VBFunctions &gt;&gt;=

def Log(num):
	"""Return the log of a value"""
	return math.log(float(num))

def Exp(num):
	"""Return the log of a value"""
	return math.exp(float(num))
</t>
<t tx="pap.120703001453.513">&lt;&lt; VBFunctions &gt;&gt;=

def Oct(num):
	"""Return the oct of a value"""
	n = CInt(num)
	if n == 0:
		return "0"
	else:
		return oct(n)[1:]
	
</t>
<t tx="pap.120703001453.514">&lt;&lt; VBFunctions &gt;&gt;=

def Hex(num):
	"""Return the hex of a value"""
	return hex(CInt(num))[2:].upper()
	
</t>
<t tx="pap.120703001453.515">&lt;&lt; VBFunctions &gt;&gt;=

def InStr(*args):
	"""Return the location of one string in another"""
	if len(args) == 2:
		text, subtext = args
		return text.find(subtext)+1
	else:
		start, text, subtext = args
		pos = text[start-1:].find(subtext)
		if pos == -1:
			return 0
		else:
			return pos + start
	
</t>
<t tx="pap.120703001453.516">&lt;&lt; VBFunctions &gt;&gt;=

def Val(text):
	"""Return the value of a string
	
	This function finds the longest leftmost number in the string and
	returns it. If there are no valid numbers then it returns 0.
	
	The method chosen here is very poor - we just keep trying to convert the 
	string to a float and just use the last successful as we increase
	the size of the string. A Regular expression approach is probably 
	quicker.
	
	"""
	best = 0
	for idx in range(len(text)):
		try:
			best = float(text[:idx+1])
		except ValueError:
			pass
	return best
</t>
<t tx="pap.120703001453.517">&lt;&lt; VBFunctions &gt;&gt;=

def IsNumeric(text):
	"""Return true if the string contains a valid number"""
	try:
		dummy = float(text)
	except ValueError:
		return 0
	else:
		return 1
</t>
<t tx="pap.120703001453.518">&lt;&lt; VBFunctions &gt;&gt;=

def Like(text, pattern):
	"""Return true if the text matches the pattern
	
	The pattern is a string containing wildcards
		* = any string of characters
		? = any one character
		
	Fortunately, the fnmatch library module does this for us!
	
	"""
	return fnmatch.fnmatch(text, pattern)
</t>
<t tx="pap.120703001453.519">&lt;&lt; VBFunctions &gt;&gt;=

def Seek(channel):
	"""Return the current 'cursor' position in the specified channel"""
	return VBFiles.getFile(Int(channel)).tell()+1 # VB starts at 1
</t>
<t tx="pap.120703001453.520">&lt;&lt; VBFunctions &gt;&gt;=

_last_files = []

def Dir(path=None):
	"""Recursively return the contents of a path matching a certain pattern

	The complicating part here is that when you first call Dir it return the
	first file. Subsequent calls to Dir with no parameters return the other
	files. When all the files are exhausted, we return an empty string.

	Since we need to remember the original path we have to use a global variable
	which is a bit ugly.

	"""
	global _last_files
	if path:
		_last_files = glob.glob(path)
	if _last_files:
		return os.path.split(_last_files.pop(0))[1] # VB just returns the filename, not full path
	else:
		return ""
</t>
<t tx="pap.120703001453.521">&lt;&lt; VBFunctions &gt;&gt;=


def Erase(*args):
	"""Erase the contents of fixed size arrays and return them to their initialized form"""
	for array in args:
		array.erase()
</t>
<t tx="pap.120703001453.522">&lt;&lt; VBFunctions &gt;&gt;=


def LSet(var, value):
	"""Do a VB LSet
	
	Left aligns a string within a string variable, or copies a variable of one 
	user-defined type to another variable of a different user-defined type.
	
	LSet stringvar = string
	
	LSet replaces any leftover characters in stringvar with spaces.
	
	If string is longer than stringvar, LSet places only the leftmost characters, 
	up to the length of the stringvar, in stringvar.
	
	Warning   Using LSet to copy a variable of one user-defined type into a 
	variable of a different user-defined type is not recommended. Copying data 
	of one data type into space reserved for a different data type can cause unpredictable results.
	
	When you copy a variable from one user-defined type to another, the binary data 
	from one variable is copied into the memory space of the other, without regard 
	for the data types specified for the elements.
	
	"""
	return value[:len(var)] + " "*(len(var)-len(value))


</t>
<t tx="pap.120703001453.523">&lt;&lt; VBFunctions &gt;&gt;=


def RSet(var, value):
	"""Do a VB RSet
	
	Right aligns a string within a string variable.
	
	RSet stringvar = string
		
	If stringvar is longer than string, RSet replaces any leftover characters 
	in stringvar with spaces, back to its beginning.
	
	"""
	return " "*(len(var)-len(value)) + value[:len(var)] </t>
<t tx="pap.120703001453.524">&lt;&lt; VBFunctions &gt;&gt;=

def Input(length, channelid):
	"""Return the given number of characters from the given channel"""
	return VBFiles.getChars(channelid, length)
</t>
<t tx="pap.120703001453.525">&lt;&lt; VBFunctions &gt;&gt;=

def FreeFile():
	"""Return the next available channel number"""
	existing = VBFiles.getOpenChannels()
	if existing:
		return max(existing)+1
	else:
		return 1</t>
<t tx="pap.120703001453.526">&lt;&lt; VBFunctions &gt;&gt;=

def LCase(text):
	"""Return the lower case version of a string"""
	return text.lower()
	
def UCase(text):
	"""Return the lower case version of a string"""
	return text.upper()
</t>
<t tx="pap.120703001453.527">&lt;&lt; VBFunctions &gt;&gt;=

def String(num=None, text=None):
	"""Return a repeated number of string items"""
	if num is None and text is None:
		return str()
	else:
		return text[:1]*CInt(num)
	
def Space(num):
	"""Return a repeated number of spaces"""
	return String(num, " ")
	
Spc = Space</t>
<t tx="pap.120703001453.528">&lt;&lt; VBFunctions &gt;&gt;=

def Trim(text):
	"""Strip spaces from the text"""
	return str(text).strip()

def LTrim(text):
	"""Strip spaces from the left of the text"""
	return str(text).lstrip()

def RTrim(text):
	"""Strip spaces from the right of the text"""
	return str(text).rstrip()
</t>
<t tx="pap.120703001453.529">&lt;&lt; VBFunctions &gt;&gt;=

def UBound(obj, dimension=1):
	"""Return the upper bound for the index"""
	try:
		return obj.__ubound__(dimension)
	except AttributeError:
		raise ValueError("UBound called for invalid object")

		
def LBound(obj, dimension=1):
	"""Return the lower bound for the index"""
	try:
		return obj.__lbound__(dimension)
	except AttributeError:
		raise ValueError("LBound called for invalid object")
</t>
<t tx="pap.120703001453.530">&lt;&lt; VBFunctions &gt;&gt;=

def CreateObject(classname, ipaddress=None):
	"""Try to create an OLE object
	
	This only works on windows!
	
	"""
	if ipaddress:
		raise VB2PYNotSupported("DCOM not supported")
	import win32com.client
	return win32com.client.Dispatch(classname)
	
</t>
<t tx="pap.120703001453.531">&lt;&lt; VBFunctions &gt;&gt;=

from PythonCard.graphic import Bitmap

def LoadPicture(filename):
	"""Load an image as a bitmap for display in a BitmapImage control"""
	return Bitmap(filename)
	
</t>
<t tx="pap.120703001453.532">@doc 

VB has some weird behaviour here. For instance, 

- a call to Rnd with 0 returns the last number generated
- a call to Rnd with &lt; 0 seeds the random generator to return a consistent sequence
- a call to Randomize seeds the RNG but doesn't produce a consistent sequence

&lt;&lt; VBFunctions &gt;&gt;=

_last_rnd_number = random.random()

def Rnd(value=1):
	"""Return a random numer and optionally seed the current state"""
	global _last_rnd_number
	if value == 0:
		return _last_rnd_number
	elif value &lt; 0:
		random.seed(value)
	r = random.random()
	_last_rnd_number = r
	return r
	
	
def Randomize(seed=None):
	"""Seed the RNG
	
	In VB this doesn't return a consistent sequence so we basically ignore the seed.
	
	"""
	random.seed()	
		</t>
<t tx="pap.120703001453.533">&lt;&lt; VBFunctions &gt;&gt;=

def Array(*args):
	"""Create an array from our arguments"""
	array = VBArray(len(args)-1, Variant)
	for idx in range(len(args)):
		array[idx] = args[idx]
	return array</t>
<t tx="pap.120703001453.534">&lt;&lt; VBFunctions &gt;&gt;=

def IsArray(obj):
	"""Determine if an object is an array"""
	return isinstance(obj, (list, tuple))</t>
<t tx="pap.120703001453.535">&lt;&lt; VBFunctions &gt;&gt;=

def IIf(cond, truepart, falsepart):
	"""Conditional operator"""
	if cond:
		return truepart
	else:
		return falsepart</t>
<t tx="pap.120703001453.536">&lt;&lt; VBFunctions &gt;&gt;=

def StrReverse(s):
	"""Reverse a string"""
	l = list(str(s))
	l.reverse()
	return "".join(l)</t>
<t tx="pap.120703001453.537">&lt;&lt; VBFunctions &gt;&gt;=

def Join(sourcearray, delimeter=" "):
	"""Join a list of strings"""
	s_list = map(str, sourcearray)
	return delimeter.join(s_list)</t>
<t tx="pap.120703001453.538">&lt;&lt; VBFunctions &gt;&gt;=

def Choose(index, *args):
	"""Choose from a list of options
	
	If the index is out of range then we return None. The list is
	indexed from 1.
	
	"""
	if index &lt;= 0:
		return None
	try:
		return args[index-1]
	except IndexError:
		return None</t>
<t tx="pap.120703001453.539">&lt;&lt; VBFunctions &gt;&gt;=

def Switch(*args):
	"""Choose from a list of expression each with its own condition
	
	The arguments are presented as a sequence of condition, expression pairs
	and the first condition that returns a true causes its expression to be
	returned. If no conditions are true then the function returns None
	
	"""
	arg_list = list(args)
	arg_list.reverse()
	#
	while arg_list:
		cond, expr = arg_list.pop(), arg_list.pop()
		if cond:
			return expr
	return None</t>
<t tx="pap.120703001453.540">&lt;&lt; VBFunctions &gt;&gt;=

def Split(text, delimiter=" ", limit=-1, compare=None):
	"""Split a string using the delimiter
	
	If the optional limit is present then this defines the number
	of items returned. The compare is used for different string comparison
	types in VB, but this is not implemented at the moment
	
	"""
	if compare is not None:
		raise VB2PYNotSupported("Compare options for Split are not currently supported")
	#
	if limit == 0:
		return VBArray()
	elif limit &gt; 0:
		return Array(*str(text).split(delimiter, limit-1))
	else:
		return Array(*str(text).split(delimiter))</t>
<t tx="pap.120703001453.541">@doc
Settings in VB are stored in the registry. However, we can't do this in a cross platform way so we implement these as a central INI file stored in the vb2py package directory. Why a central file? Well, if it wasn't a central file then multiple applications written in VB and converted which tried to access each other's settings would fail.

Presumably we could alter this with options to allow the user to select a local setting file or even the registry if they are on Windows.

Also as an implementation detail we open the INI file and parse it every time we want to do something. Again, this is "safe" because other applications may be changing settings, but this can be slow so we may want an option here also.</t>
<t tx="pap.120703001453.542">&lt;&lt; VBFunctions &gt;&gt;=

class _OptionsDB(config.VB2PYConfigObject):
	"""A special config parser class to handle central VB options"""
	
	def __init__(self, appname):
		"""Initialize the parser"""
		config.VB2PYConfigObject.__init__(self, filename=utils.relativePath("settings.ini"))
		self.appname = appname
	
	def __getitem__(self, key):
		"""Get an item"""
		section, name = key
		section = self._getSettingName(section)
		return config.VB2PYConfigObject.__getitem__(self, (section, name))
		
	def __setitem__(self, key, value):
		"""Set an item"""
		section, name = key
		section = self._getSettingName(section)
        if not self._config.has_section(section):
			self._config.add_section(section)
		self._config.set(section, name, value)
		self.save()
		
	def save(self):
		"""Store the options"""
		f = open(utils.relativePath("settings.ini"), "w")
		self._config.write(f)
		f.close()
		
	def _getSettingName(self, section):
		"""Return the name for a section"""
		return "%s.%s" % (self.appname, section)
	

	def getAll(self, section):
		"""Return all the items in a sections"""
		thissection = self._getSettingName(section)
		options = self._config.options(thissection)
		ret = vbObjectInitialize(size=(len(options)-1, 1), objtype=str)
		for idx in range(len(options)):
			ret[idx, 0] = options[idx]
			ret[idx, 1] = self[section, options[idx]]
		return ret
		
	def delete(self, section, name):
		"""Delete a setting from the settings file"""
		section = self._getSettingName(section)
		self._config.remove_option(section, name)
		self.save()		
		</t>
<t tx="pap.120703001453.543">&lt;&lt; VBFunctions &gt;&gt;=

def GetSetting(appname, section, key, default=None):
	"""Get a setting from the central setting file"""
	settings = _OptionsDB(appname)
	try:
		return settings[section, key]
	except config.ConfigParser.Error:
		if default is not None:
			return default
		raise</t>
<t tx="pap.120703001453.544">&lt;&lt; VBFunctions &gt;&gt;=

def GetAllSettings(appname, section):
	"""Get all settings from the central setting file"""
	settings = _OptionsDB(appname)
	return settings.getAll(section)
</t>
<t tx="pap.120703001453.545">&lt;&lt; VBFunctions &gt;&gt;=

def SaveSetting(appname, section, key, value):
	"""Set a setting in the central setting file"""
	settings = _OptionsDB(appname)
	settings[section, key] = str(value)
</t>
<t tx="pap.120703001453.546">&lt;&lt; VBFunctions &gt;&gt;=

def DeleteSetting(appname, section, key):
	"""Delete a setting in the central setting file"""
	settings = _OptionsDB(appname)
	settings.delete(section, key)
</t>
<t tx="pap.120703001453.547">&lt;&lt; VBFunctions &gt;&gt;=

Abs = abs
Asc = AscB = AscW = ord
Chr = ChrB = ChrW = chr
Fix = Int
CStr = Str = str
CSng = CDbl = float
Len = len
StrComp = cmp
Round = round

True = 1
False = 0

#
# Command line parameters are retrieved as a whole
Command = " ".join(sys.argv[1:])

#
# File stuff
Kill = os.remove
RmDir = os.rmdir
MkDir = os.mkdir
ChDir = os.chdir
FileCopy = shutil.copyfile</t>
<t tx="pap.120703001453.548"></t>
<t tx="pap.120703001453.549">@root vbdebug.py

"""Set up logging"""

import vbclasses

import logger   # For logging output and debugging 
_vb_debug_log = logger.getLogger("vb2PyApp")

vbclasses.Debug._logger = _vb_debug_log



</t>
<t tx="pap.120703001453.550"></t>
<t tx="pap.120703001453.551">@others
  
</t>
<t tx="pap.120703001453.552">@root config.py

from utils import rootPath
import ConfigParser
import os

class VB2PYConfigObject(dict):
	"""A dictionary of configuration options
	
	Options are accessed via a tuple
	c[section, key]
	
	"""
	
	def __init__(self, *args, **kw):
		"""Initialize the dictionary"""
		self.initConfig(*args, **kw)
		
	def __getitem__(self, key):
		"""Get an item"""
        try:
            return self._local_overide["%s.%s" % key]
        except KeyError:
            return self._config.get(*key)
		
	def initConfig(self, filename="vb2py.ini", path=None):
		"""Read the values"""
		if path is None:
			path = rootPath()
		self._config = ConfigParser.ConfigParser()
		self._config.read(os.path.join(path, filename))
	    self._local_overide = {}	
		
	def setLocalOveride(self, section, name, value):
        """Set a local overide for a value"""
		self.checkValue(section, name)
        self.addLocalOveride(section, name, value)

	def addLocalOveride(self, section, name, value):
        """Add a local overide for a value"""
        if self._config.has_section(section):
            self._local_overide["%s.%s" % (section, name)] = value
        else:
            raise ConfigParser.NoSectionError("No such section '%s'" % section)
        
    def removeLocalOveride(self, section, name,):
        """Remove a local overide"""
		self.checkValue(section, name)
        del(self._local_overide["%s.%s" % (section, name)])        

	def checkValue(self, section, name):
		"""Make sure we have this section and name"""
		dummy = self[section, name]    
        
    def getItemNames(self, section):
        """Return the list of items in a section"""
        base = self._config.options(section) 
        local = []
        for name in self._local_overide:
            section_name, option = name.split(".")
            if section_name == section:
                local.append(option)
        return base + local
#
# We always want people to use the same one
_VB2PYConfig = VB2PYConfigObject()

def VB2PYConfig(init=0):
	ret = _VB2PYConfig
	if init:
		ret.initConfig()
	return ret

</t>
<t tx="pap.120703001453.553"></t>
<t tx="pap.120703001453.554">@root plugins\__init__.py

import glob
import os

# Depends who imports us ... don't understand this
try:
	from vb2py.utils import rootPath
except ImportError:
	from utils import rootPath	

mods = []
for fn in glob.glob(os.path.join(rootPath(), "plugins", "*.py")):
    name = os.path.splitext(os.path.basename(fn))[0]
    if not name.startswith("_"):
        mods.append(name)</t>
<t tx="pap.120703001453.555">@root extensions.py

"""Base classes for all plug-ins"""

import glob
import os
import imp

from utils import rootPath
from config import VB2PYConfig

Config = VB2PYConfig()

import logger
log = logger.getLogger("PlugInLoader")

&lt;&lt; Plug-in functions &gt;&gt;
&lt;&lt; Plug-in classes &gt;&gt;

if __name__ == "__main__":
    loadAllPlugins()
</t>
<t tx="pap.120703001453.556">&lt;&lt; Plug-in functions &gt;&gt;=

def loadAllPlugins():
    """Load all plug-ins from the plug-in directory and return a list of all the classes"""
    import plugins
    mods = []
    for mod in plugins.mods:
        log.info("Checking '%s' for plugins" % mod)
        #
        f = open(os.path.join(rootPath(), "plugins", "%s.py" % mod), "r")
        try:
            try:
                m = imp.load_module(mod, f, "Plugin-%s" % mod, ('*.py', 'r', 1))
            finally:
                f.close()
        except Exception, err:
            log.warn("Error importing '%s' (%s). Module skipped" % (mod, err))
            continue
        #
        for name in dir(m):
            cls = getattr(m, name)
            #import pdb; pdb.set_trace()
            try:
                is_plugin = cls.__is_plugin__
            except AttributeError:
                is_plugin = 0
            if is_plugin:
                try:
                    p = cls()               
                    log.info("Added new plug-in: '%s" % p.name)
                    mods.append(p)
                except Exception, err:
                    log.warn("Error creating plugin '%s' (%s). Class skipped" % (cls, err))
    #
    # Now sort
    mods.sort()                
    return mods</t>
<t tx="pap.120703001453.557">&lt;&lt; Plug-in functions &gt;&gt;=

def disableLogging():
    """Disable logging in all plugins"""
    #
    # Disable the main logger
    log.setLevel(0)
    #
    # Now do so for pluging
    BasePlugin.logging_level = 0</t>
<t tx="pap.120703001453.558">&lt;&lt; Plug-in classes &gt;&gt;=

class BasePlugin(object):
    """All plug-ins should inherit from this base class or define __is_plugin__"""
    
    __is_plugin__ = 1 # Set to true if you want to be loaded plug-in
    
    system_plugin = 0 # True if you are a system plugin
    __enabled = 1   # If false the plugin will not be called
    order = 1000  # Determines order of execution. lower = earlier
    
    logging_level = int(Config["General", "LoggingLevel"])
    
    &lt;&lt; BasePlugin methods &gt;&gt;</t>
<t tx="pap.120703001453.559">&lt;&lt; BasePlugin Methods &gt;&gt;=

def __init__(self):
    """Initialize the plugin
    
    This method should always be called by subclasses as it is required to set up logging etc
    
    """
    if not hasattr(self, "name"):
        self.name = self.__class__.__name__
        
    self.log = logger.getLogger(self.name)
    self.log.setLevel(self.logging_level)
</t>
<t tx="pap.120703001453.560">&lt;&lt; BasePlugin methods &gt;&gt;=

def preProcessVBText(self, text):
    """Process raw VB text prior to any conversion
    
    This method should return a new version of the text with any changes made
    to it. If there is no preprocessing required then do not define this method.
    
    """
    return text</t>
<t tx="pap.120703001453.561">&lt;&lt; BasePlugin methods &gt;&gt;=

def postProcessPythonText(self, text):
    """Process Python text following the conversion
    
    This method should return a new version of the text with any changes made
    to it. If there is no postprocessing required then do not define this method.
    
    """
    return text</t>
<t tx="pap.120703001453.562">&lt;&lt; BasePlugin methods &gt;&gt;=

def disable(self):
    """Disable the plugin"""
    self.__enabled = 0</t>
<t tx="pap.120703001453.563">&lt;&lt; BasePlugin methods &gt;&gt;=

def isEnabled(self):
    """Return 1 if plugin is enabled"""
    return self.__enabled</t>
<t tx="pap.120703001453.564">&lt;&lt; BasePlugin methods &gt;&gt;=

def __cmp__(self, other):
    """Used to allow plugins to be sorted to run in a certain order"""
    return cmp(self.order, other.order)</t>
<t tx="pap.120703001453.565">&lt;&lt; Plug-in classes &gt;&gt;=

import re

class RETextMarkup(BasePlugin):
    """A utility class to apply regular expression based text markup
    
    The plug-in allows simple re text replacements as a pre and post conversion
    passes simple by reading from lists of replacements defined as class methods.
    
    Users can simply create instances of their own classes to handle whatever markup
    they desire.
    
    """
    
    name = "RETextMarkup"
    re_flags = 0 # Put re flags here if you need them
    
    # Define your patterns by assigning to these properties in the sub-class
    pre_process_patterns = ()
    post_process_patterns = ()
    
    &lt;&lt; RETextMarkup methods &gt;&gt;
</t>
<t tx="pap.120703001453.566">&lt;&lt; RETextMarkup methods &gt;&gt;=

def preProcessVBText(self, text):
    """Process raw VB text prior to any conversion"""
    if self.pre_process_patterns:
        self.log.info("Processing pre patterns")
    return self.processText(text, self.pre_process_patterns)
</t>
<t tx="pap.120703001453.567">&lt;&lt; RETextMarkup methods &gt;&gt;=

def postProcessPythonText(self, text):
    """Process Python text following the conversion"""
    if self.post_process_patterns:
        self.log.info("Processing post patterns")
    return self.processText(text, self.post_process_patterns)</t>
<t tx="pap.120703001453.568">&lt;&lt; RETextMarkup methods &gt;&gt;=

def processText(self, text, patterns):
    """Process the text and mark it up"""
    for re_pattern, replace in patterns:
        def doSub(match):
            self.log.info("Replacing '%s' with %s, %s" % (re_pattern, replace, match.groupdict()))
            return replace % match.groupdict()
        r = re.compile(re_pattern, self.re_flags)
        text = r.sub(doSub, text)
    return text
</t>
<t tx="pap.120703001453.569">&lt;&lt; Plug-in classes &gt;&gt;=

import re

class RenderHookPlugin(BasePlugin):
    """A utility plugin to hook a render method and apply markup after the render
    
    The plugin replaces the specified objects normal renderCode method with one which
    calls the plugins addMarkup method when it is complete.
    
    """
    
    name = "RenderHookPlugin"
    hooked_class_name = None # Name of class should go here
        
    &lt;&lt; RenderHookPlugin methods &gt;&gt;

</t>
<t tx="pap.120703001453.570">&lt;&lt; RenderHookPlugin Methods &gt;&gt;=

def __init__(self):
    """Initialize the plugin
    
    This method should always be called by subclasses as it is required to set up logging etc
    
    """
    super(RenderHookPlugin, self).__init__()
    #
    # Look for class and replace its renderAsCode method
    import parserclasses
    self.hooked_class = getattr(parserclasses, self.hooked_class_name)
    old_render_method = self.hooked_class.renderAsCode
    #
    def newRender(obj, indent=0):
        ret = old_render_method(obj, indent)
        return self.addMarkup(indent, ret)
    #    
    self.hooked_class.renderAsCode = newRender

</t>
<t tx="pap.120703001453.571">&lt;&lt; RenderHookPlugin Methods &gt;&gt;=

def addMarkup(self, indent, text):
    """Add markup to the rendered text"""
    return text

</t>
<t tx="pap.120703001453.572">&lt;&lt; Plug-in classes &gt;&gt;=

class SystemPlugin(BasePlugin):
    """Special kind of plug-in which is used by the system and cannot be disabled"""
    
    system_plugin = 1

class SystemPluginREPlugin(RETextMarkup):
    """Special kind of plug-in which is used by the system and cannot be disabled"""
    
    system_plugin = 1
</t>
<t tx="pap.120703001453.573"></t>
<t tx="pap.120703001453.574">@root plugins\testplugin1.py

try:
	import vb2py.extensions as extensions
except ImportError:
	import extensions

        
class TestREPlugin(extensions.RETextMarkup):
    """An example plugin"""    
    
    name = "REPlugin"
    
    pre_process_patterns = (
            ("(?P&lt;Object&gt;.*)_Click", "%(Object)s_click"),
            ("\sError\s", " _errfn "),
    )    
    
    
class NotAPlugIn:
    """Something that isn't a plugin"""    

</t>
<t tx="pap.120703001453.575"></t>
<t tx="pap.120703001453.576">@root plugins\continuations.py

try:
	import vb2py.extensions as extensions
except ImportError:
	import extensions
	

class LineContinuations(extensions.SystemPlugin):
    """Plugin to handle line continuations
    
    Line continuations are indicated by a '_' at the end of a line and imply that
    the current line and the one following should be joined together. We could
    parse this out in the grammar but it is just easier to handle it as a pre-processor
    text as we aren't going to use it in the Python conversion.
    
    """
    
    order = 10 # We would like to happen quite early
       
    def preProcessVBText(self, txt):
        """Convert continuation markers by joining adjacent lines"""

        txt_lines = txt.split("\n")
        txtout = "\n".join([lne.strip() for lne in txt_lines if lne.strip()])
        txtout = txtout.replace(" _\n", " ")
        txtout += "\n\n"
        self.log.info("Line continuation:\nConverted '%s'\nTo '%s'" % (txt, txtout))
        return txtout
            

</t>
<t tx="pap.120703001453.577">@root plugins\removetypes.py

try:
	import vb2py.extensions as extensions
except ImportError:
	import extensions

class RemoveTypeMarkers(extensions.SystemPluginREPlugin):
    """Plugin to remove the type identifiers from functions
	
	Some VB functions have $, %, #, &amp; markers at the end of their names and we
	need to remove them. The proper place to do this is in the parsing but this
	is a quick fix!
    
    """
    
	name = "Remove $ from functions"
	
    post_process_patterns = (
			(r"Left\$\(", "Left("),
			(r"Right\$\(", "Right("),
			(r"Mid\$\(", "Mid("),
			(r"Chr\$\(", "Chr("),	
			(r"Dir\$\(", "Dir("),	
			(r"Trim\$\(", "Dir("),	
	)
            


</t>
<t tx="pap.120703001453.578">@root plugins\classmethods.py

try:
	import vb2py.extensions as extensions
except ImportError:
	import extensions

class RemoveTypeMarkers(extensions.SystemPluginREPlugin):
    """Plugin to replace Class Method names with their Python equivalents
    
    This could be done in the parser but is done here to expose the translation and
    allow it to be customized.
    
    """
    
    post_process_patterns = (
			(r"Class_Initialize\(", "__init__("),
			(r"Class_Terminate\(", "__del__("),
	)
            

</t>
<t tx="pap.120703001453.579">@root plugins\nothingtonone.py

try:
	import vb2py.extensions as extensions
except ImportError:
	import extensions

class ReplaceNothingWithNone(extensions.RenderHookPlugin, extensions.SystemPlugin):
    """Plugin to replace Nothing with None in objects"""
    
    hooked_class_name = "VBObject"
    
    def addMarkup(self, indent, text):
        """Add markup to the rendered text"""
        return text.replace("Nothing", "None")
        
</t>
<t tx="pap.120703001453.580">@root plugins\attributenames.py

try:
	import vb2py.extensions as extensions
except ImportError:
	import extensions

class TranslateAttributes(extensions.SystemPluginREPlugin):
    """Plugin to convert attribute names from VB to Pythoncard
	
	There are attribute like 'Text' and 'Visible' which are in lower
	case in Pythoncard and others are simply different. We do the conversion
	here. 
	
	Note that this means we will convert these names even if they don't belong
	to controls - this is unfortunate but still safe as we do the conversion
	consistently.
    
    """
    
	name = "PlugInAttributeNames"
    __enabled = 0   # If false the plugin will not be called
	
    post_process_patterns = (
#			(r"\.Text\b", ".text"),
#			(r"\.Caption\b", ".text"),
#			(r"\.Visible\b", ".visible"),
#			(r"\.Enabled\b", ".enabled"),
#			(r"\.BackColor\b", ".backgroundColor"),
#			(r"\.ToolTipText\b", ".ToolTipText"),
#			(r"\.AddItem\b", ".append"),
	)
            



</t>
<t tx="pap.120703001453.581"></t>
<t tx="pap.120703001453.582">@root setup.py

"""Install vb2Py

Much of the following code is copied from the PythonCard installation script
because the original setup.py would copy files to all sorts of weird location
on Linux.

You must run this to create the setup distribution from the site-packages!

"""


WIN_DEFAULT_COMMAND = "install"
APPLICATION_NAME = "vb2py"
from distutils.core import setup
from distutils.command.install_data import install_data
import glob, os, sys
if len(sys.argv) == 1 and sys.platform.startswith("win"):
    sys.argv.append(WIN_DEFAULT_COMMAND)

"""
This script is setup.py of the vb2py package.

"""

&lt;&lt; Support functions &gt;&gt;

setup(name=APPLICATION_NAME, 
      version="0.2.2",
      description="Visual Basic to Python Converter",
      author="Paul Paterson",
      author_email="paulpaterson@users.sourceforge.net",
      url="http://vb2py.sourceforge.net",
      packages=["vb2py", "vb2py.test", "vb2py.sandbox", 
	  		    "vb2py.plugins", "vb2py.targets", "vb2py.targets.pythoncard"],
      package_dir={APPLICATION_NAME: '.'},
      license="BSD",
      cmdclass = { 'install_data': smart_install_data},
      data_files=makeDataDirs(dataDirs=[".", "./test", "./vb", "./doc", "./sandbox", "./targets", "./vb"]),
     )



</t>
<t tx="pap.120703001453.583">&lt;&lt; Support Functions &gt;&gt;=

class smart_install_data(install_data):
    def run(self):
        #need to change self.install_dir to the actual library dir
        install_cmd = self.get_finalized_command('install')
        self.install_dir = getattr(install_cmd, 'install_lib')
        return install_data.run(self) 

def recurseDir(startDir):
    # This should all be replaced by calls to os.path.walk, but later
    listX=[startDir]
    for fyle in os.listdir(startDir):
        file=os.path.join(startDir,fyle)
        if os.path.isdir(file):
            listX.extend(recurseDir(file))
    return listX

def makeDataDirs(rootDir=APPLICATION_NAME, dataDirs=[]):
    "Construct a list of the data directories to be included"
    # This function will return a list of tuples, each tuple being of the form;
    #  ( &lt;target_directory_name&gt;, [&lt;list_of_files&gt;] )
    listX=[]
    results=[]
    for directory in dataDirs:
        directories=recurseDir(directory)
        results.extend(directories)
    for directory in results:
        if not "svn" in os.path.split(directory)[1]:
            # Add this directory and its contents to list
            files=[]
            for file in os.listdir(directory):
                if file!='CVS' and file!='.cvsignore' and os.path.splitext(file)[1].lower() &lt;&gt; ".htm":
                    if os.path.isfile(os.path.join(directory, file)):
                        files.append(os.path.join(directory, file))
            listX.append((rootDir+'/'+directory, files))
    # list.append((rootDir, 'stc_styles.cfg'))
        
    return listX</t>
<t tx="pap.120703001453.584">@root MANIFEST.in

include *.py
include *.txt
include *.ini
recursive-include targets *.*
recursive-include vb *.*
recursive-include doc *.html
recursive-include doc *.css
recursive-include doc *.gif
prune *.svn*</t>
<t tx="pap.120703001453.585">The main documentation lives at .\doc\index.html


vb2Py Installation
==================

**Important** If you installed v0.1, or the CVS version, prior to v0.2 please remove the old directories completely before installing v0.2. Changes in the package (in particular the renaming of ``vb2py.py``) **will** causes problems. Sorry for the confusion!

* `Main Installation`_
* `GUI Installation`_
* `Simpleparse Installation`_
* `mxTools Installation`_
* `PythonCard Installation`_

``vb2Py`` uses Python and has been tested on Python 2.2. Python 2.3 should work but earlier versions will not.
 

Main Installation
~~~~~~~~~~~~~~~~~

vb2Py is written in Python and runs on any platform which has a Python interpreter.

Once you have downloaded the ``vb2py`` package you will have a zip file. Before you can do anything you must have Python installed. After Python is installed you can install the ``vb2py`` modules by going to the directory you unzipped the files to and typing::

	&gt; python setup.py install

Now you should have a 'vb2py' folder in your Python site packages directory.

You also need to make sure you have both PythonCard_ and Simpleparse_ installed on your system.

Once these additional resources are installed on your system you should be ready to go and use the converter.

Note: You do not need VB to run the converter!


GUI Installation
~~~~~~~~~~~~~~~~

The vb2Py GUI is also written in Python and uses the PythonCard GUI toolkit. Installation of the GUI is the same as for the main libraries. Once you have downloaded the ``vb2pygui`` you will have a zip file. You can install the ``vb2pygui`` module by going to the directory you unzipped the files to and typing::

	&gt; python setup.py install

Now you should have a 'vb2pygui' folder in your Python site packages directory.


Simpleparse Installation
~~~~~~~~~~~~~~~~~~~~~~~~

vb2Py uses the ``Simpleparse`` module to parse the Visual Basic code. You can download the ``Simpleparse`` files from the Simpleparse_ download site. *NB You need ``Simpleparse v2.0.1a2`` or later.* Follow the instructions on the `Simpleparse homepage`_ to install the software.

You will also need to do the `mxTools Installation`_.


mxTextTools Installation
~~~~~~~~~~~~~~~~~~~~

The ``Simpleparse`` library uses the mxTextTools_ libraries. Once you have downloaded these, follow the instructions on the `mxTools homepage`_.


PythonCard Installation
~~~~~~~~~~~~~~~~~~~~~~~

If you want to use the ``vb2Py`` GUI or view converted forms actually running, then you will need the ``PythonCard`` GUI library. You can download the software from the PythonCard_ download site. Installation instructions are on the `PythonCard homepage`_. ``vb2Py`` has been tested with the 0.7 Prototype version but should work with later versions also.

.. _Simpleparse: http://sourceforge.net/project/showfiles.php?group_id=55673
.. _`Simpleparse homepage`: http://simpleparse.sourceforge.net
.. _mxTextTools: http://www.egenix.com
.. _`mxTools homepage`: http://www.egenix.com
.. _PythonCard: http://sourceforge.net/project/showfiles.php?group_id=19015
.. _`PythonCard homepage`: http://pythoncard.sourceforge.net/installation.html


Command Line Usage
==================

The easiest way to use vb2Py from the command line is by working in the vb2py directory in your Python site-packages location.

To check the basic usage from the command line::

	&gt; python converter.py -h

Two example projects should be installed in the folder, ``vb2py/vb/test1`` and ``test2``. To convert the ``test2`` project (which is slightly more meaningful than ``test1``!) to a PythonCard project, use the command::

	&gt; python converter.py -c vb/test/test2.vbp vb/test/test2
	
	-c = convert the code also	
	vb/test/test2.vbp = the VB project file for the project	
	vb/test/test2 = the location of the generated Python files

The directory where the Python files will be put **must** exist before you run the conversion.

If you have PythonCard_ installed you can see what the forms look like by typing::

	&gt; python vb/test/test2/frmMain.py

You should see a form open with a lot of controls on it. Clicking on the controls should perform the same actions as for the VB version.

.. image:: images/sm_test2_frmmain_py.gif

See the `full form`_

For cases where you don't have a VB project file (``*.vbp``), you can still use the converter to convert individual files on at a time. The following command will convert the single code module in the test2 project::

	&gt; python converter.py -c -f vb/test/Utils.bas vb/test/test2

The code will be placed in the destination directory. Note that when doing file-by-file conversions certain parts of the conversion will not be possible. In particular, global variables will not be correctly handled since in order to determine the correct qualified name for a global, vb2Py needs to know all the files within the project.

For example, when converting an entire project the following code segment (where ``BASEDIR`` is defined in a module called ``FileGlobals``)::

	Function addBaseDirectory(Path as String)
		addBaseDirectory = BASEDIR &amp; Path ' BASEDIR is a global
	End Function

Would be converted to::

	def addBaseDirectory(Path):
		_ret = FileGlobals.BASEDIR + Path
		return _ret

However, if the file is translated on its own (using the ``-f`` command line switch) then it would be converted to::



</t>
<t tx="pap.120703001453.586">Copyright (c) 2003, Paul Paterson
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 
Neither the name of the vb2Py Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</t>
<t tx="pap.120703001453.588">@root vbbutton.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBButton")

from PythonCard.components import button
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBButton(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
        } 

    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
        } 
    
    _proxy_for = button.Button 
    

log.debug("Registering VBButton as '%s'" % sys.modules[__name__].VBButton)
Register(VBButton)
</t>
<t tx="pap.120703001453.589">@root vbstatictext.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBStaticText")

from PythonCard.components import statictext
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBStaticText(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Caption" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
        } 

    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
        } 
    
    _proxy_for = statictext.StaticText
    



log.debug("Registering VBStaticText as '%s'" % sys.modules[__name__].VBStaticText)
Register(VBStaticText)</t>
<t tx="pap.120703001453.590">@root vbtextfield.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBTextField")

from PythonCard.components import textfield
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBTextField(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
        } 

    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
        } 
    
    _proxy_for = textfield.TextField
    

log.debug("Registering VBTextField as '%s'" % sys.modules[__name__].VBTextField)
Register(VBTextField)</t>
<t tx="pap.120703001453.591">@root vbcombobox.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBComboBox")

from PythonCard.components import combobox
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBComboBox(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
			"List" : "items",
    } 

	_name_to_method_translations = {
			"ListCount" : ("getNumber", None),
			"ListIndex" : ("getSelectionIndex", None),
	}
	
    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
    } 
    
	_method_translations = {			
			"Clear" : "clear",
			"RemoveItem" : "delete",	
	}
    
    _proxy_for = combobox.ComboBox
	
	&lt;&lt; VBComboBox methods &gt;&gt;   
    

log.debug("Registering VBComboBox as '%s'" % sys.modules[__name__].VBComboBox)
Register(VBComboBox)</t>
<t tx="pap.120703001453.592">&lt;&lt; VBComboBox methods &gt;&gt;=

def AddItem(self, item, position=None):
	"""Add an item to the list
	
	We cannot just map this to a PythonCard control event because it only has
	an 'append' and an 'insertItems' method, which isn't exactly the same
	
	"""
	if position is None:
		self.append(item)
	else:
		self.insertItems([item], position)</t>
<t tx="pap.120703001453.593">&lt;&lt; VBComboBox methods &gt;&gt;=

def getNumber(self):
	"""Get the number of items in the Combo
	
	This doesn't appear to be in the PythonCard control
	
	"""
	return len(self.items)</t>
<t tx="pap.120703001453.594">&lt;&lt; VBComboBox methods &gt;&gt;=

def getSelectionIndex(self):
	"""Get the index of the currently selected item
	
	This doesn't appear to be in the PythonCard control
	
	"""
	try:
		return self.items.index(self.selection)
	except ValueError:
		return -1</t>
<t tx="pap.120703001453.595">&lt;&lt; VBComboBox methods &gt;&gt;=

def delete(self, position):
	"""Remove the specified item from the Combo
	
	This doesn't appear to be in the PythonCard control
	
	"""
	del(self.items[position]) # TODO - this doesn't actually work</t>
<t tx="pap.120703001453.596">@root vblist.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBListBox")

from PythonCard.components import list
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBList(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
			"List" : "items",
    } 

	_name_to_method_translations = {
			"ListCount" : ("getNumber", None),
			"ListIndex" : ("getSelectionIndex", None),
	}
	
    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
    } 
    
	_method_translations = {			
			"Clear" : "clear",
			"RemoveItem" : "delete",	
	}
	
    _proxy_for = list.List

	&lt;&lt; VBList methods &gt;&gt;   

log.debug("Registering VBList as '%s'" % sys.modules[__name__].VBList)
Register(VBList)
</t>
<t tx="pap.120703001453.597">&lt;&lt; VBList methods &gt;&gt;=

def AddItem(self, item, position=None):
	"""Add an item to the list
	
	We cannot just map this to a PythonCard control event because it only has
	an 'append' and an 'insertItems' method, which isn't exactly the same
	
	"""
	if position is None:
		self.append(item)
	else:
		self.insertItems([item], position)</t>
<t tx="pap.120703001453.598">@root vbcheckbox.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBCheckBox")

from PythonCard.components import checkbox
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBCheckBox(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
			"Value" : "checked",
			"Caption" : "label",
        } 

    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
        } 
    
    _proxy_for = checkbox.CheckBox
    

log.debug("Registering VBCheckBox as '%s'" % sys.modules[__name__].VBCheckBox)
Register(VBCheckBox)</t>
<t tx="pap.120703001453.599">@root vbtextarea.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBTextArea")

from PythonCard.components import textarea
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBTextArea(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
        } 

    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
        } 
    
    _proxy_for = textarea.TextArea
    

log.debug("Registering VBTextArea as '%s'" % sys.modules[__name__].VBTextArea)
Register(VBTextArea)</t>
<t tx="pap.120703001453.600">@doc
The general testing methodology is,

- read a string containing VB
- convert the VB to Python
- execute the Python
- examine the resulting dictionary and test against the expected results

@c</t>
<t tx="pap.120703001453.601">@root test\__init__.py

pass</t>
<t tx="pap.120703001453.602">@root test\testmini.py

#
# Turn off logging in extensions (too loud!)
import vb2py.extensions
vb2py.extensions.disableLogging()

from unittest import *
from vb2py.vbparser import buildParseTree, VBParserError

#
# Set some config options which are appropriate for testing
import vb2py.config
Config = vb2py.config.VB2PYConfig()
Config.setLocalOveride("General", "ReportPartialConversion", "No")


tests = []

&lt;&lt; Parsing tests &gt;&gt;

class ParsingTest(TestCase):
	"""Holder class which gets built into a whole test case"""
	
	
def getTestMethod(vb):
	"""Create a test method"""
	def testMethod(self):
		try:
			buildParseTree(vb)
		except VBParserError:
			raise "Unable to parse ...\n%s" % vb
	return testMethod
	
#
# Add tests to main test class
for idx in range(len(tests)):
	setattr(ParsingTest, "test%d" % idx, getTestMethod(tests[idx]))
	

if __name__ == "__main__":
	main()
</t>
<t tx="pap.120703001453.603">&lt;&lt; Parsing Tests &gt;&gt;=

# The Debug.Print statement
tests.extend([
"Debug.Print",
"Debug.Print a",
"Debug.Print a,b",
"Debug.Print a;b",
"Debug.Print a+10;b+20",
"Debug.Print a+20, b-20",
"Debug.Print a;b;",
])
</t>
<t tx="pap.120703001453.604">@root test\testparser.py

#
# Turn off logging in extensions (too loud!)
import vb2py.extensions
vb2py.extensions.disableLogging()

from unittest import *
from vb2py.vbparser import buildParseTree, VBParserError

#
# Set some config options which are appropriate for testing
import vb2py.config
Config = vb2py.config.VB2PYConfig()
Config.setLocalOveride("General", "ReportPartialConversion", "No")


tests = []

&lt;&lt; Parsing tests &gt;&gt;

class ParsingTest(TestCase):
	"""Holder class which gets built into a whole test case"""
	
	
def getTestMethod(vb):
	"""Create a test method"""
	def testMethod(self):
		try:
			buildParseTree(vb)
		except VBParserError:
			raise "Unable to parse ...\n%s" % vb
	return testMethod
	
#
# Add tests to main test class
for idx in range(len(tests)):
	setattr(ParsingTest, "test%d" % idx, getTestMethod(tests[idx]))
	

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.605"></t>
<t tx="pap.120703001453.606">&lt;&lt; Parsing tests &gt;&gt;=

# Simple assignments
tests.append("""
a = 10
b = 20+30
c = "hello there"
oneVal = 10
twoVals = Array(10,20)
functioncall = myfunction.mymethod(10)
""")

# Set type assignments
tests.append("""
Set a = myobject
Set b = myobject.subobject
Set obj = function(10, 20, 30+40)
""")


# Set type assignments with "New" objects
tests.append("""
Set a = New myobject
Set b = New myobject.subobject
""")

# Assignments with tough parenthesis
tests.extend([
		"d=(((4*5)/2+10)-10)",
])

# Assignments with tough string quotes
tests.extend([
		'd="g""h""j"""',
])

# Assignments with tough strings in general
tests.extend([
		r'a="\"',  # The single slash is a killer
])
</t>
<t tx="pap.120703001453.607">&lt;&lt; Parsing tests &gt;&gt;=

# Simple expressions
tests.extend([
'a = 10',
'a = 20+30',
'a = "hello there"',
'a = 10',
'a = Array(10,20)',
'a = myfunction.mymethod(10)',
'a = &amp;HFF',
'a = &amp;HFF&amp;',
'a = #1/10/2000#',
'a = #1/10#',
'a = 10 Mod 2',
])


# Nested expressions
tests.extend(["a = 10+(10+(20+(30+40)))",
			  "a = (10+20)+(30+40)",
			  "a = ((10+20)+(30+40))",
])

# Conditional expressions
tests.extend(["a = a = 1",
			  "a = a &lt;&gt; 10",
			  "a = a &gt; 10",
			  "a = a &lt; 10",
			  "a = a &lt;= 10",
			  "a = a &gt;= 10",
			  "a = a = 1 And b = 2",
			  "a = a = 1 Or b = 2",
			  "a = a Or b",
			  "a = a Or Not b",
			  "a = Not a = 1",
			  "a = Not a",
			  "a = a Xor b",
			  "a = b Is Nothing",
			  "a = b \ 2",
			  "a = b Like c",
			  'a = "hello" Like "goodbye"',
])

# Things that failed
tests.extend([
			"a = -(x*x)",
			"a = -x*10",
			"a = 10 Mod 6",
			"Set NewEnum = mCol.[_NewEnum]",
            "a = 10 ^ -bob",
])

# Functions
tests.extend([
			"a = myfunction",
			"a = myfunction()",
			"a = myfunction(1,2,3,4)",
			"a = myfunction(1,2,3,z:=4)",
			"a = myfunction(x:=1,y:=2,z:=4)",
			"a = myfunction(b(10))",
			"a = myfunction(b _\n(10))",
])

# String Functions
tests.extend([
			'a = Trim$("hello")',
			'a = Left$("hello", 4)',
])			

# Things that failed
tests.extend([
			"a = -(x*x)",
			"a = -x*10",
			"a = 10 Mod 6",
])

# Address of
tests.extend([
		"a = fn(AddressOf fn)",
		"a = fn(a, b, c, AddressOf fn)",
		"a = fn(a, AddressOf b, AddressOf c, AddressOf fn)",
		"a = fn(a, AddressOf b.m.m, AddressOf c.k.l, AddressOf fn)",
])

# Type of
tests.extend([
		"a = fn(TypeOf fn)",
		"a = fn(a, b, c, TypeOf fn)",
		"a = fn(a, TypeOf b, TypeOf c, TypeOf fn)",
		"a = fn(a, TypeOf b.m.m, TypeOf c.k.l, TypeOf fn)",
		"a = TypeOf Control Is This",
		"a = TypeOf Control Is This Or TypeOf Control Is That",])</t>
<t tx="pap.120703001453.608">&lt;&lt; Parsing tests &gt;&gt;=

# Using ByVal and ByRef in a call or expression
tests.extend([
'a = fn(ByVal b)',
'a = fn(x, y, z, ByVal b)',
'a = fn(x, y, z, ByVal b, 10, 20, 30)',
'a = fn(ByVal a, ByVal b, ByVal c)',
'a = fn(ByRef b)',
'a = fn(x, y, z, ByRef b)',
'a = fn(x, y, z, ByRef b, 10, 20, 30)',
'a = fn(ByRef a, ByRef b, ByRef c)',
'fn ByVal b',
'fn x, y, z, ByVal b',
'fn x, y, z, ByVal b, 10, 20, 30',
'fn ByVal a, ByVal b, ByVal c',
'fn ByRef b',
'fn x, y, z, ByRef b',
'fn x, y, z, ByRef b, 10, 20, 30',
'fn ByRef a, ByRef b, ByRef c',

])
</t>
<t tx="pap.120703001453.609">&lt;&lt; Parsing tests &gt;&gt;=

# One line comments
tests.append("""
a = 10
' b = 20+30
' c = "hello there"
' oneVal = 10
twoVals = Array(10,20)
' functioncall = myfunction.mymethod(10)
""")

# One line comments with Rem
tests.append("""
a = 10
Rem b = 20+30
Rem not needed c = "hello there"
Rem opps oneVal = 10
twoVals = Array(10,20)
Rem dont do this anymore functioncall = myfunction.mymethod(10)
""")

# In-line comments
tests.append("""
a = 10
b = 20+30 ' comment
c = "hello there" ' another comment
oneVal = 10 ' yet another comment
twoVals = Array(10,20)
functioncall = myfunction.mymethod(10)
""")

# In-line comments with Rem
tests.append("""
a = 10
b = 20+30 Rem comment
c = "hello there" Rem another comment
oneVal = 10 Rem yet another comment
twoVals = Array(10,20)
functioncall = myfunction.mymethod(10)
""")

# Things which aren't comments
tests.append("""
a = "hello, this might ' look like ' a comment ' "
b = "wow there are a lot of '''''''' these here"
""")

# tough inline comments
tests.extend([
	"Public a As Integer ' and a comment"
])

# comments in awkward places
tests.extend([
"""
If a =0 Then ' nasty comment
	b=1
End If ' other nasty comment
""",

"""
While a&lt;0 ' nasty comment
	b=1
Wend ' other nasty comment
""",

"""
Select Case a ' nasty comment
Case 10 ' oops
	b=1
Case Else ' other nasty comment
	b = 2
End Select ' gotcha
""",

"""
For i = 0 To 100 ' nasty comment
	b=1
Next i ' other nasty comment
""",

"""
Sub a() ' nasty comment
	b=1
End Sub ' other nasty comment
""",

"""
Function f() ' nasty comment
	b=1
End Function ' other nasty comment
""",

])</t>
<t tx="pap.120703001453.610">&lt;&lt; Parsing tests &gt;&gt;=

# Directives
tests.extend([
	"' VB2PY-Set General.Blah = Yes",
	"' VB2PY-Set General.Blah = ___",
	"' VB2PY-Unset General.Blah",
    "' VB2PY-Add: General.Option = 10",
])</t>
<t tx="pap.120703001453.611">&lt;&lt; Parsing tests &gt;&gt;=

# Two line continuations
tests.append("""
a = _
10 + 20 + 30
b = 10/ _
25
c = (one + _
     two + three)
""")

# Milti-line continuations
tests.append("""
a = _
      10 + 20 + 30 _
    * 10/ _
      25
c = (one + _
     two + three) * _
	 four.five()
""")

tests.extend(["""
Private Declare Function GetTempPathA Lib "kernel32" _
 (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
""",
"""
Function GetTempPathA _
(ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long
End Function
""",

])</t>
<t tx="pap.120703001453.612"></t>
<t tx="pap.120703001453.613">&lt;&lt; Parsing tests &gt;&gt;=

# Simple dims
tests.extend([
		"Dim A",
		"Dim B As String",
		"Dim variable As Object.OtherObj",
		"Dim Var As Variant",
		"Dim A As String * 100",
])

# Dims with New
tests.extend([
		"Dim A As New Object",
		"Dim B As New Collection",
])

# Multiple dims on one line
tests.extend([
		"Dim A, B, C, D, E, F",
		"Dim B As String, B As Long, B As Integer, B As String, B As String",
		"Dim variable As Object.OtherObj, B, C, D, E",
		"Dim Var As Variant",
		"Dim A, B, C As New Collection",
		"Dim E As New Collection, F As New Object, F, G",
		"Dim H As New Object, G As New Object",
])

# Array type dims
tests.extend([
		"Dim A()",
		"Dim B(10, 20, 30) As String",
		"Dim variable() As Object.OtherObj",
		"Dim Var(mysize) As Variant",
])

# Scoped dims
tests.extend([
		"Public A",
		"Private B As String",
		"Private A, B, C, D, E, F",
		"Private B As String, B As Long, B As Integer, B As String, B As String",
		"Private variable As Object.OtherObj, B, C, D, E",
		"Public Var As Variant",
])

# Static dims
tests.extend([
		"Static A",
		"Static B As String",
		"Static A, B, C, D, E, F",
		"Static B As String, B As Long, B As Integer, B As String, B As String",
		"Static variable As Object.OtherObj, B, C, D, E",
		"Static Var As Variant",
])</t>
<t tx="pap.120703001453.614">&lt;&lt; Parsing tests &gt;&gt;=

# Arrays
tests.extend([
	"Dim a(10)",
	"Dim a(0)",
	"Dim a(0), b(20), c(30)",
	"Dim a(10+20)",
	"Dim a(10+20, 1+3)",
	"Dim a(1 To 10)",
	"Dim a(1 To 10, 5 To 20)",
])

# Redims
tests.extend([
	"ReDim a(10)",
	"ReDim a(0)",
	"ReDim Preserve a(20)",
	"ReDim a(0), b(20), c(30)",
	"ReDim Preserve a(20), b(20)",
	"ReDim a(10+20)",
	"ReDim a(10+20, 1+3)",
	"ReDim a(1 To 10)",
	"ReDim a(1 To 10, 5 To 20)",
	"ReDim a(10).b(10)",
])


# Complex examples
tests.extend([
"""
With Obj
	ReDim .Child(10)
End With
""",
])</t>
<t tx="pap.120703001453.615">&lt;&lt; Parsing tests &gt;&gt;=

# Constants with different types
tests.extend([
	"Const a = 10",
	'Const a = "Hello"',
	"Const a = &amp;HA1",
	"Const a = 1#",
	"Const a = 1%",
	"Const a = 1&amp;",
	"Public Const a = 10",
	'Public Const a = "Hello"',
	"Public Const a = &amp;HA1",
	"Public Const a = 1#",
	"Public Const a = 1%",
	"Public Const a = 1&amp;",
	"Private Const a = 10",
	'Private Const a = "Hello"',
	"Private Const a = &amp;HA1",
	"Private Const a = 1#",
	"Private Const a = 1%",
	"Private Const a = 1&amp;",
])

# Constants
tests.extend([
		"Const A = 20",
		'Const B = "one"',
		"Private Const A = 1234.5 + 20",
		"Const a=10, b=20, c=30",
		"Private Const a=10, b=20, d=12345",
])

# Typed Constants
tests.extend([
		"Const A As Long = 20",
		'Const B As String = "one"',
		"Private Const A As Single = 1234.5 + 20",
		'Const a As Integer = 10, b As String = "hello", c As String * 10 = 43',
		'Private Const a As Integer = 10, b As String = "hello", c As String * 10 = 43',
])</t>
<t tx="pap.120703001453.616">&lt;&lt; Parsing tests &gt;&gt;=

# Odds and ends
tests.extend([
"Private WithEvents A As Button",
])</t>
<t tx="pap.120703001453.617">&lt;&lt; Parsing tests &gt;&gt;=

# Bare calls
tests.extend([
		"subr",
		"object.method",
		"object.method.method2.method",
])

# Explicit bare calls
tests.extend([
		"Call subr",
		"Call object.method",
		"Call object.method.method2.method",
])

# Bare calls with arguments
tests.extend([
		"subr 10, 20, 30",
		"object.method a, b, c+d, e",
		'object.method.method2.method 10, "hello", "goodbye" &amp; name',
])

# Explicit calls with arguments
tests.extend([
		"Call subr(10, 20, 30)",
		"Call object.method(a, b, c+d, e)",
		'Call object.method.method2.method(10, "hello", "goodbye" &amp; name)',
		"Call subr()",
])

# Bare calls with arguments and functions
tests.extend([
		"subr 10, 20, 30",
		"object(23).method a, b, c+d, e",
		'object.method(5, 10, 20).method2.method 10, "hello", "goodbye" &amp; name',
])

# Bare calls with named arguments and functions
tests.extend([
		"subr 10, 20, z:=30",
		"object(23).method one:=a, two:=b, three:=c+d, four:=e",
		'object.method(5, 10, 20).method2.method 10, "hello", two:="goodbye" &amp; name',
])

# Bare calls with ommitted arguments
tests.extend([
		"subr 10, , 30",
		"subr ,,,,0",
		"subr 10, , , , 5",
])

</t>
<t tx="pap.120703001453.618">&lt;&lt; Parsing tests &gt;&gt;=

# labels
tests.extend([
	"label:",
	"label20:",
	"20:",
	"label: a=1",
	"20: a=1",
	"101: doit",
	"101:\ndoit",
	"102: doit now",
	"103: doit now, for, ever",
])

# Goto's
tests.extend([
	"GoTo Label",
	"GoTo 20",
	"GoTo Label:",
	"GoTo 20:",
])

# Structures with labels
tests.extend([
"""
101: If a &lt; 10 Then
102:		b=1
103: End If
""",

"""
101: While a &lt; 0
102:		b=1
103: Wend
""",

"""
101: Select Case a
102:		Case 10
103:			b= 1
104:		Case Else
105:			b=2
103: End Select
""",

"""
101: For i = 0 To 100
102:		b=1
103: Next i
""",

"""
101: Sub a()
102:		b=1
103: End Sub
""",

])

# Numeric labels don't even need a ':' ... aarg!
tests.extend([
"""
101 If a &lt; 10 Then
102		b=1
103 End If
""",

"""
101 While a &lt; 0
102		b=1
103 Wend
""",

"""
101 Select Case a
102		Case 10
103			b= 1
104		Case Else
105			b=2
103 End Select
""",

"""
101 For i = 0 To 100
102		b=1
103 Next i
""",

"""
101 Sub a()
102		b=1
103 End Sub
""",

])
</t>
<t tx="pap.120703001453.619">&lt;&lt; Parsing tests &gt;&gt;=

# simple multi-line statements
tests.extend([
	"a = 10: b = 20",
	"a = 10: b = 20: c=1: d=1: e=2",
	"a=10:",
	"a=10: b=20:",
])

# Blocks on a line
tests.extend([
	"For i = 0 To 10: b=b+i: Next i",
	"If a &gt; b Then a = 10: b = 20"
])


# Bug #809979 - Line ending with a colon fails 
tests.extend([
	"a = 10:\nb = 20",
	"a = 10: b = 20:\nc=1: d=1: e=2",
	"a=10:\nb=20:\nc=1",
])
</t>
<t tx="pap.120703001453.620">&lt;&lt; Parsing tests &gt;&gt;=

# open statements
tests.extend([
	"Open fn For Output As 12",
	"Open fn For Output As #12",
	"Open fn For Input As 12",
	"Open fn For Input As #12",
	"Open fn.gk.gl() For Input As #NxtChn()",
	"Open fn For Append Lock Write As 23",
	"Close 1",
	"Close #1",
	"Close channel",
	"Close #channel",
	"Close",
	"Close\na=1",
	"Closet = 10",
])


# Bug #810968 Close #1, #2 ' fails to parse 
tests.extend([
	"Close #1, #2, #3, #4",
	"Close 1, 2, 3, 4",
	"Close #1, 2, #3, 4",
	"Close #one, #two, #three, #four",
	"Close one, two, three, four",
	"Close #1,#2,#3,#4",
	"Close   #1   ,   #2   ,   #3   ,   #4   ",
])
</t>
<t tx="pap.120703001453.621">&lt;&lt; Parsing tests &gt;&gt;=

# print# statements
tests.extend([
	"Print 10",
	"Print #1, 10",
	"Print 10, 20, 30;",
	"Print #1, 10, 20, 30;",
	"Print #1, 10; 20; 30;",
	"Print #1, 10; 20; 30; 40, 50, 60, 70; 80; 90",
	"Print 10, 20, 30,",
	"Print 10, 20, 30",
	"Print",
	"Print ;;;",
	"Print ,,,",
	"Print 1,,,2,,,3,,,;",
	"Print #3,",
	"Print #3,;;;",
	"Print #3,,,",
	"Print #3,1,,,2,,,3,,,;",
])

# get# statements
tests.extend([
	"Get #1, a, b",
	"Get #1, , b",
])

# input # statements
tests.extend([
	"Input #1, a, b",
	"Input #1, b",
	"a = Input(20, #3)",
	"a = Input(20, #id)",
])

# line input # statements
tests.extend([
	"Line Input #1, b",
])


# Seek
tests.extend([
	"Seek #filenum, value",
	"10: Seek #filenum, value",
	"10: Seek #filenum, value ' comment",
	"Seek #filenum, value ' comment",
])	</t>
<t tx="pap.120703001453.622">&lt;&lt; Parsing Tests &gt;&gt;=

tests.extend([
	'Private Declare Function FileTimeToSystemTime Lib "kernel32" (ftFileTime As FILETIME, stSystemTime As SYSTEMTIME) As Long',
	'Private Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)',
	'Private Declare Function GetFileAttributes Lib "kernel32" Alias "GetFileAttributesA" (ByVal lpFileName As String) As Long',
	'Private Declare Function GetFileAttributes Lib "kernel32" _ \n(ByVal lpFileName As String) As Long',
	'Private Declare Function GetFileAttributes Lib "kernel32" _ \n(ByVal lpFileName As String, A) As Long',
	'Private Declare Function GetFileAttributes Lib "kernel32" _ \n(ByVal lpFileName As String , A) As Long',
	'Private Declare Function GetFileAttributes Lib "kernel32" _ \n(ByVal lpFileName As String ) As Long',
])</t>
<t tx="pap.120703001453.623">&lt;&lt; Parsing Tests &gt;&gt;=

# General on error goto
tests.extend([
	"On Error GoTo 100",
	"On Error GoTo ErrTrap",
	"On Error GoTo 100 ' comment",
	"On Error GoTo ErrTrap ' comment",
	"100: On Error GoTo 100",
	"label: On Error GoTo ErrTrap",
	"100: On Error GoTo 100 ' comment",
	"label: On Error GoTo ErrTrap ' comment",
])

# General on error resume next
tests.extend([
	"On Error Resume Next",
	"On Error Resume Next ' comment",
	"100: On Error Resume Next",
	"label: On Error Resume Next",
	"100: On Error Resume Next ' comment",
	"label: On Error Resume Next ' comment",
])

# General on error goto - 
tests.extend([
	"On Error GoTo 0",
	"On Error GoTo 0 ' comment",
	"100: On Error GoTo 0",
	"100: On Error GoTo 0 ' comment",
])


# On something goto list 
tests.extend([
	"On var GoTo 20",
	"On var GoTo 10,20,30,40",
])

# Resume
tests.extend([
	"label: Resume Next",
	"Resume Next",
	"label: Resume Next ' Comment",
	"label: Resume 7",
	"Resume 7",
	"label: Resume 7 ' Comment",
	"label: Resume",
	"Resume\na=1",
	"label: Resume' Comment",
])

# General on local error resume next
tests.extend([
	"On Local Error Resume Next",
	"On Local Error Resume Next ' comment",
	"100: On Local Error Resume Next",
	"label: On Local Error Resume Next",
	"100: On Local Error Resume Next ' comment",
	"label: On Local Error Resume Next ' comment",
])

# Bug #809979 - On Error with : after the label fails 
tests.extend([
	"On Error GoTo 0:\na=1",
	"On Error GoTo 0: ' comment",
	"100: On Error GoTo 0:\na=1",
	"100: On Error GoTo 0: ' comment",
	"On Error GoTo lbl:\na=1",
	"On Error GoTo lbl: ' comment",
	"100: On Error GoTo lbl:\na=1",
	"100: On Error GoTo lbl: ' comment",
])
</t>
<t tx="pap.120703001453.624">&lt;&lt; Parsing tests &gt;&gt;=

# Lines
tests.extend([
		"Line (10,20)-(30,40), 10, 20",
		"obj.Pset (10, 20), RGB(1,2,2)",
])

# Move
tests.extend([
		"Move (Screen.Width - Width) / 2, (Screen.Height - Height) / 2",
])		</t>
<t tx="pap.120703001453.625">&lt;&lt; Parsing Tests &gt;&gt;=

# General name test (rename a file)
tests.extend([
		"Name file As otherfile",
		"Name file &amp; extension As otherfile",
		"Name file &amp; extension As otherfile &amp; otherextension",
		'Name path &amp; "\origname.txt" As path &amp; "\knewname.txt"',
])
</t>
<t tx="pap.120703001453.626">&lt;&lt; Parsing Tests &gt;&gt;=

# Attributes at the head of a file
tests.extend([
    'Attribute VB_Name = "frmMain"',
    'Attribute VB_GlobalNameSpace = False',
    'Attribute VB_Creatable = False',
    'Attribute VB_PredeclaredId = True',
    'Attribute VB_Exposed = False',
    'Attribute Me.VB_Exposed = False',
    'Attribute Me.VB_Exposed = False, 1, 2, 3, 4',
    'Attribute Me.VB_Exposed = False, "1", "2, 3,", 4',
])</t>
<t tx="pap.120703001453.627">&lt;&lt; Parsing Tests &gt;&gt;=

# Attributes at the head of a file
tests.extend([
"""
Enum thing
    _one = 1
    _two = 2
    _three = 3
    _four = 4
End Enum
""",
"""
Enum thing
    _one
    _two
    _three
    _four
End Enum
""",
])</t>
<t tx="pap.120703001453.628">&lt;&lt; Parsing Tests &gt;&gt;=

# Types
tests.extend([
"""
Private Type ShellFileInfoType
 hIcon As Long
 iIcon As Long
 dwAttributes As Long
 szDisplayName As String * 260
 szTypeName As String * 80
End Type
"""
])
</t>
<t tx="pap.120703001453.629">&lt;&lt; Parsing Tests &gt;&gt;=

# The Option statement
tests.extend([
"Option Base 0",
"Option Base 1",
"Option Explicit",
"Option String Compare",
"Option String Compare Text",
])
</t>
<t tx="pap.120703001453.630">&lt;&lt; Parsing Tests &gt;&gt;=

# The End statement
tests.extend([
"10: End",
"End",
"End ' wow this is it",
"10: End ' this is the end",
])

# If with an 'End' in there
tests.append("""
If a = 10 Then
	End
End If
""")

# Sub with an 'End' in there
tests.append("""
Sub doit()
 End
End Sub
""")

# Fn with an 'End' in there
tests.append("""
Function doit()
 End
End Function
""")

# With with an 'End' in there
tests.append("""
With obj
 End
End With
""")
</t>
<t tx="pap.120703001453.631">&lt;&lt; Parsing Tests &gt;&gt;=

# The Event statement
tests.extend([
"Event doit()",
"Public Event doit()",
"Private Event doit()",
"Public Event doit(a, b, c, e)",
"Public Event doit(a As Integer, b As Long, c(), e As Command.Button)",
])
</t>
<t tx="pap.120703001453.632"></t>
<t tx="pap.120703001453.633"></t>
<t tx="pap.120703001453.634">&lt;&lt; Parsing tests &gt;&gt;=

# Simple If
tests.append("""
If a = 10 Then
	b = 20
End If
If c &lt; 1 Then
	d = 15
End If
""")

# Empty If
tests.append("""
If a = 10 Then
End If
""")

# Empty If with comments
tests.append("""
If a = 10 Then ' comment here
End If
""")

# Simple If with And/Or
tests.append("""
If a = 10 And k = "test" Then
	b = 20
End If
If c &lt; 1 Or d Then
	d = 15
End If
""")

# Simple If with compount And/Or expression
tests.append("""
If (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	b = 20
End If
If (c &lt; 1) Or d And e = "hello" Or e &lt; "wow" Then
	d = 15
End If
""")

#  If Not
tests.append("""
If Not a = 10 Then
	b=2
End If
""")

#  If With labels and comment
tests.append("""
10: If Not a = 10 Then 'heres a comment
20:   	b=2  ' antoher here
30: End If ' here too
""")
</t>
<t tx="pap.120703001453.635">&lt;&lt; Parsing tests &gt;&gt;=

# Simple If/Else
tests.append("""
If a = 10 Then
	b = 20
Else
	b = 10
End If
If c &lt; 1 Then
	d = 15
Else
	d = -12
End If
""")

# Empty If/Else
tests.append("""
If a = 10 Then
Else
End If
""")

# Simple If with And/Or
tests.append("""
If a = 10 And k = "test" Then
	b = 20
Else
	b = 1234
End If
If c &lt; 1 Or d Then
	d = 15
Else
	e = "hello"
End If
""")

# Simple If with compount And/Or expression
tests.append("""
If (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	b = 20
Else
	g = 12
End If
If (c &lt; 1) Or d And e = "hello" Or e &lt; "wow" Then
	d = 15
Else
	h = 1234
End If
""")
</t>
<t tx="pap.120703001453.636">&lt;&lt; Parsing tests &gt;&gt;=

# Simple If/Else
tests.append("""
If a = 10 Then
	b = 20
ElseIf a &lt; 10 Then
	b = 10
End If
If c &lt; 1 Then
	d = 15
ElseIf c = 1 Then
	d = -12
End If
""")


# Simple If with And/Or
tests.append("""
If a = 10 And k = "test" Then
	b = 20
ElseIf b = -102 Then
	b = 1234
End If
If c &lt; 1 Or d Then
	d = 15
ElseIf e = Myfunction Then
	e = "hello"
End If
""")

# Simple If with compount And/Or expression
tests.append("""
If (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	b = 20
ElseIf (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	g = 12
End If
If (c &lt; 1) Or d And e = "hello" Or e &lt; "wow" Then
	d = 15
ElseIf k &lt; 43 Then
	h = 1234
End If
""")

</t>
<t tx="pap.120703001453.637">&lt;&lt; Parsing tests &gt;&gt;=

# Simple If/Else
tests.append("""
If a = 10 Then
	b = 20
ElseIf a &lt; 10 Then
	b = 10
Else
	b = 1111
End If
If c &lt; 1 Then
	d = 15
ElseIf c = 1 Then
	d = -12
Else
	d = "wow"
End If
""")


# Simple If with And/Or
tests.append("""
If a = 10 And k = "test" Then
	b = 20
ElseIf b = -102 Then
	b = 1234
Else
	b = 4321
End If
If c &lt; 1 Or d Then
	d = 15
ElseIf e = Myfunction Then
	e = "hello"
Else
	g = 1
End If
""")

# Simple If with compount And/Or expression
tests.append("""
If (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	b = 20
ElseIf (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	g = 12
Else
	k = 3234
End If
If (c &lt; 1) Or d And e = "hello" Or e &lt; "wow" Then
	d = 15
ElseIf k &lt; 43 Then
	h = 1234
Else
	doIt
End If
""")
</t>
<t tx="pap.120703001453.638">&lt;&lt; Parsing tests &gt;&gt;=

# Simple Nested If
tests.append("""
If a = 10 Then
	b = 20
	If c &lt; 1 Then
		d = 15
	End If
End If
""")


# Complex nested If
tests.append("""
If (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	b = 20
ElseIf (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	If (c &lt; 1) Or d And e = "hello" Or e &lt; "wow" Then
		d = 15
	ElseIf k &lt; 43 Then
		h = 1234
	Else
		If (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
			b = 20
		End If
		If (c &lt; 1) Or d And e = "hello" Or e &lt; "wow" Then
			d = 15
		End If
	End If
Else
	k = 3234
End If
""")

</t>
<t tx="pap.120703001453.639">&lt;&lt; Parsing tests &gt;&gt;=

# Inline ifs
tests.extend([
		"If a = 10 Then b = 20",
		"If a = 20 And b = 5 Then d = 123",
		"If a = 12 Then d = 1 Else g = 5",
		"If a = 10 Then doit",
		"If a = 10 Then doit 10, 20, 30",
		"If a = 10 Then doit Else dont",
		"If a = 10 Then doit 10, 20, 30 Else dont",
		"If a = 10 Then doit 10, 20, 30 Else dont 5, 10, 15",
		"If a = 10 Then Exit Function",
		"If a = 10 Then Exit Function Else DoIt",
		"If a = 10 Then Exit Function Else DoIt=1",
		"If a = 10 Then Exit Function Else DoIt 1, 2, 3",
		"If a = 10 Then DoIt Else Exit Function",
		"If a = 10 Then DoIt=1 Else Exit Function",
		"If a = 10 Then DoIt 1,2,34 Else Exit Function",
])

# Weird inline if followed by assignment that failed once
tests.extend([
		"If a = 10 Then b a\nc=1",
])</t>
<t tx="pap.120703001453.640">&lt;&lt; Parsing tests &gt;&gt;=

# #If
tests.append("""
#If a = 10 Then
	b = 20
#Else
	c=2
#End If
#If c &lt; 1 Then
	d = 15
#Else
	c=2
#End If
""")

# Empty #If
tests.append("""
#If a = 10 Then
#Else
	c=2
#End If
""")

# Empty #If with comments
tests.append("""
#If a = 10 Then ' comment here
#Else
	c=2
#End If
""")

# Simple #If with And/Or
tests.append("""
#If a = 10 And k = "test" Then
	b = 20
#Else
	c=2
#End If
#If c &lt; 1 Or d Then
	d = 15
#Else
	c=2
#End If
""")

# Simple #If with compount And/Or expression
tests.append("""
#If (a = 10 And k = "test") And (c Or b Or e = 43.23) Then
	b = 20
#Else
	c=2
#End If
#If (c &lt; 1) Or d And e = "hello" Or e &lt; "wow" Then
	d = 15
#Else
	c=2
#End If
""")

#  #If Not
tests.append("""
#If Not a = 10 Then
	b=2
#Else
	c=2
#End If
""")

</t>
<t tx="pap.120703001453.641"></t>
<t tx="pap.120703001453.642">&lt;&lt; Parsing tests &gt;&gt;=

# simple sub
tests.append("""
Sub MySub()
a=10
n=20
c="hello"
End Sub
""")


# simple sub with exit
tests.append("""
Sub MySub()
a=10
n=20
Exit Sub
c="hello"
End Sub
""")


# simple sub with scope
tests.extend(["""
Private Sub MySub()
a=10
n=20
c="hello"
End Sub""",
"""
Public Sub MySub()
a=10
n=20
c="hello"
End Sub
""",
"""
Friend Sub MySub()
a=10
n=20
c="hello"
End Sub
""",
"""
Private Static Sub MySub()
a=10
n=20
c="hello"
End Sub
""",
])

# simple sub with gap in ()
tests.append("""
Sub MySub(   )
a=10
n=20
c="hello"
End Sub
""")
</t>
<t tx="pap.120703001453.643">&lt;&lt; Parsing tests &gt;&gt;=

# simple sub
tests.append("""
Sub MySub(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Sub
""")


# simple sub with exit
tests.append("""
Sub MySub(x, y, z, a, b, c)
a=10
n=20
Exit Sub
c="hello"
End Sub
""")


# simple sub with scope
tests.append("""
Private Sub MySub(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Sub
Public Sub MySub(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Sub
""")

</t>
<t tx="pap.120703001453.644">&lt;&lt; Parsing tests &gt;&gt;=

# simple sub
tests.append("""
Sub MySub(x As Single, y, z As Boolean, a, b As Variant, c)
a=10
n=20
c="hello"
End Sub
""")


# simple sub with exit
tests.append("""
Sub MySub(x As Single, y, z As Object, a, b As MyThing.Object, c)
a=10
n=20
Exit Sub
c="hello"
End Sub
""")


# simple sub with scope
tests.append("""
Private Sub MySub(x, y As Variant, z, a As Boolena, b, c As Long)
a=10
n=20
c="hello"
End Sub
Public Sub MySub(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Sub
""")
</t>
<t tx="pap.120703001453.645">&lt;&lt; Parsing tests &gt;&gt;=

# simple sub
tests.append("""
Sub MySub(x As Single, y, z As Boolean, a, Optional b As Variant, c)
a=10
n=20
c="hello"
End Sub
""")


# simple sub with exit
tests.append("""
Sub MySub(x() As Single, y, z As Object, Optional a, b As MyThing.Object, Optional c)
a=10
n=20
Exit Sub
c="hello"
End Sub
""")


# simple sub with scope
tests.append("""
Private Sub MySub(x, Optional y As Variant, Optional z, a As Boolena, b, c As Long)
a=10
n=20
c="hello"
End Sub
Public Sub MySub(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Sub
""")

# simple sub with optional arguments and defaults
tests.append("""
Sub MySub(x As Single, y, z As Boolean, a, Optional b = 10, Optional c="hello")
a=10
n=20
c="hello"
End Sub
""")

# simple sub with optional arguments and defaults
tests.append("""
Sub MySub(x As Single, y, z As Boolean, a, Optional b = 10, Optional c As String = "hello")
a=10
n=20
c="hello"
End Sub
""")
</t>
<t tx="pap.120703001453.646">&lt;&lt; Parsing tests &gt;&gt;=

# ByVal, ByRef args
tests.append("""
Sub MySub(ByVal a, ByRef y)
a=10
n=20
c="hello"
End Sub
""")

tests.append("""
Sub MySub(a, ByRef y)
a=10
n=20
c="hello"
End Sub
""")

tests.append("""
Sub MySub(ByVal a, y)
a=10
n=20
c="hello"
End Sub
""")

tests.append("""
Sub MySub(ByVal a As Single, y)
a=10
n=20
c="hello"
End Sub
""")

</t>
<t tx="pap.120703001453.647"></t>
<t tx="pap.120703001453.648">&lt;&lt; Parsing tests &gt;&gt;=

# simple fn
tests.append("""
Function MyFn()
a=10
n=20
c="hello"
MyFn = 20
End Function
""")


# simple fn with exit
tests.append("""
Function MyFn()
a=10
n=20
MyFn = 20
Exit Function
c="hello"
End Function
""")


# simple sub with scope
tests.extend(["""
Private Function MyFn()
a=10
n=20
c="hello"
MyFn = 20
End Function""",
"""
Public Function MyFn()
a=10
n=20
c="hello"
MyFn = 20
End Function
""",
"""
Friend Function MyFn()
a=10
n=20
c="hello"
MyFn = 20
End Function
""",
])

# simple fn with gap in ()
tests.append("""
Function MyFn(  )
a=10
n=20
c="hello"
MyFn = 20
End Function
""")
</t>
<t tx="pap.120703001453.649">&lt;&lt; Parsing tests &gt;&gt;=

# simple sub
tests.append("""
Function MySub(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Function
""")


# simple sub with exit
tests.append("""
Function MySub(x, y, z, a, b, c)
a=10
n=20
Exit Sub
c="hello"
End Function
""")


# simple sub with scope
tests.append("""
Private Function MySub(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Function
Public Function fn(x, y, z, a, b, c)
a=10
n=20
c="hello"
End Function
""")
</t>
<t tx="pap.120703001453.650">&lt;&lt; Parsing tests &gt;&gt;=

# simple sub
tests.append("""
Function fn(x As Single, y, z As Boolean, a, b As Variant, c) As Single
a=10
n=20
c="hello"
End Function
""")


# simple sub with exit
tests.append("""
Function fc(x As Single, y, z As Object, a, b As MyThing.Object, c) As Object.Obj
a=10
n=20
Exit Function
c="hello"
End Function
""")


# simple sub with scope
tests.append("""
Private Function MySub(x, y As Variant, z, a As Boolena, b, c As Long) As Variant
a=10
n=20
c="hello"
End Function
Public Function MySub(x, y, z, a, b, c) As String
a=10
n=20
c="hello"
End Function
""")

# function returning an array
tests.append("""
Function fn(x As Single, y, z As Boolean, a, b As Variant, c) As Single()
a=10
n=20
c="hello"
End Function
""")
</t>
<t tx="pap.120703001453.651">&lt;&lt; Parsing tests &gt;&gt;=

# simple sub
tests.append("""
Function fn(x As Single, y, z As Boolean, a, Optional b As Variant, c) As Single
a=10
n=20
c="hello"
End Function
""")


# simple sub with exit
tests.append("""
Function MySub(x() As Single, y, z As Object, Optional a, b As MyThing.Object, Optional c) As Integer
a=10
n=20
Exit Function
c="hello"
End Function
""")


# simple sub with scope
tests.append("""
Private Function MySub(x, Optional y As Variant, Optional z, a As Boolena, b, c As Long) As Long
a=10
n=20
c="hello"
End Function
Public Function MySub(x, y, z, a, b, c) As Control.Buttons.BigButtons.ThisOne
a=10
n=20
c="hello"
End Function
""")

# simple fn with optional arguments and defaults
tests.append("""
Function MySub(x As Single, y, z As Boolean, a, Optional b = 10, Optional c="hello")
a=10
n=20
c="hello"
End Function
""")

# simple fn with optional arguments and defaults
tests.append("""
Function MySub(x As Single, y, z As Boolean, a, Optional b = 10, Optional c As String = "hello")
a=10
n=20
c="hello"
End Function
""")
</t>
<t tx="pap.120703001453.652">&lt;&lt; Parsing tests &gt;&gt;=

# ByVal, ByRef args
tests.append("""
Function MySub(ByVal a, ByRef y)
a=10
n=20
c="hello"
End Function
""")

tests.append("""
Function MySub(a, ByRef y)
a=10
n=20
c="hello"
End Function
""")

tests.append("""
Function MySub(ByVal a, y)
a=10
n=20
c="hello"
End Function
""")

tests.append("""
Function MySub(ByVal a As Single, y)
a=10
n=20
c="hello"
End Function
""")

</t>
<t tx="pap.120703001453.653">&lt;&lt; Parsing tests &gt;&gt;=

# Simple property let/get/set
tests.extend(["""
Property Let MyProp(NewVal As String)
 a = NewVal
 Exit Property
End Property
""",
"""
Property Get MyProp() As Long
 MyProp = NewVal
 Exit Property
End Property
""",
"""
Property Set MyProp(NewObject As Object) 
 Set MyProp = NewVal
 Exit Property
End Property
"""
"""
Public Property Let MyProp(NewVal As String)
 a = NewVal
End Property
""",
"""
Public Property Get MyProp() As Long
 MyProp = NewVal
End Property
""",
"""
Public Property Set MyProp(NewObject As Object) 
 Set MyProp = NewVal
End Property
""",
"""
Public Property Get MyProp(   ) As Long
 MyProp = NewVal
End Property
""",
])

# Simple property let/get/set with labels
tests.extend(["""
1: Property Let MyProp(NewVal As String)
1:  a = NewVal
1: End Property
""",
"""
1: Property Get MyProp() As Long
1:  MyProp = NewVal
1: End Property
""",
"""
1: Property Set MyProp(NewObject As Object) 
1:  Set MyProp = NewVal
1: End Property
"""
])

# Simple property let/get/set with labels and comment
tests.extend(["""
1: Property Let MyProp(NewVal As String) ' comment
1:  a = NewVal  ' comment
1: End Property  ' comment
""",
"""
1: Property Get MyProp() As Long  ' comment
1:  MyProp = NewVal  ' comment
1: End Property  ' comment
""",
"""
1: Property Set MyProp(NewObject As Object)   ' comment
1:  Set MyProp = NewVal  ' comment
1: End Property  ' comment
"""
])</t>
<t tx="pap.120703001453.654">&lt;&lt; Parsing tests &gt;&gt;=

# Simple case
tests.append("""
Select Case x
Case "one"
    y = 1
Case "two"
    y = 2
Case "three"
    z = 3
End Select
""")

# Simple case with else
tests.append("""
Select Case x
Case "one"
    y = 1
Case "two"
    y = 2
Case "three"
    z = 3
Case Else
    z = -1
End Select
""")

# Simple case with else and trailing colons
tests.append("""
Select Case x
Case "one":
    y = 1
Case "two":
    y = 2
Case "three":
    z = 3
Case Else:
    z = -1
End Select
""")

# Multiple case with else
tests.append("""
Select Case x
Case "one"
    y = 1
Case "two"
    y = 2
Case "three", "four", "five"
    z = 3
Case Else
    z = -1
End Select
""")

# Single line case with else
tests.append("""
Select Case x
Case "one": y = 1
Case "two": y = 2
Case "three", "four", "five": z = 3
Case Else: z = -1
End Select
""")


# Range case 
tests.append("""
Select Case x
Case "a" To "m"
	z = 1
Case "n" To "z"
    z = 20
End Select
""")

# Range case with Is and Like
tests.append("""
Select Case x
Case Is &lt; "?", "a" To "m"
	z = 1
Case "n" To "z", Is &gt; 10, Is Like "*blah"
    z = 20
End Select
""")

# Multiple Range case 
tests.append("""
Select Case x
Case "a" To "m", "A" To "G", "K" To "P"
	z = 1
Case "n" To "z", 10 To this.that(10,20)
    z = 20
End Select
""")

# Empty case
tests.append("""
	Select Case a
	Case 10
	Case 20
	End Select
""")

# Case with comments
tests.append("""
Select Case x
' Here is a nasty comment

Case "one"
    y = 1
Case "two"
    y = 2
Case "three"
    z = 3
End Select
""")
</t>
<t tx="pap.120703001453.655"></t>
<t tx="pap.120703001453.656">&lt;&lt; Parsing tests &gt;&gt;=

# Simple for
tests.append("""
For i = 0 To 1000
  a = a + 1
Next i
""")

# Simple for
tests.append("""
For i=0 To 1000
  a = a + 1
Next i
""")

# Empty for
tests.append("""
For i = 0 To 1000
Next i
""")

# Simple for with unnamed Next
tests.append("""
For i = 0 To 1000
  a = a + 1
Next
""")

# For with step
tests.append("""
For i = 0 To 1000 Step 2
  a = a + 1
Next i
""")

# For with exit
tests.append("""
For i = 0 To 1000
  a = a + 1
  Exit For
Next i
""")

# Nested for
tests.append("""
For i = 0 To 1000
  a = a + 1
  For j = 1 To i
     b = b + j
  Next j
Next i
""")

# Dotted names - what does this even mean?
tests.append("""
For me.you = 0 To 1000 Step 2
  a = a + 1
Next me.you
""")</t>
<t tx="pap.120703001453.657">&lt;&lt; Parsing tests &gt;&gt;=

# Simple for
tests.append("""
For Each i In coll
  a = a + 1
Next i
""")

# Empty for
tests.append("""
For Each i In coll
Next i
""")

# Simple for with unnamed Next
tests.append("""
For Each i In coll
  a = a + 1
Next
""")


# For with exit
tests.append("""
For Each i In coll
  a = a + 1
  Exit For
Next i
""")

# Nested for
tests.append("""
For Each i In coll
  a = a + 1
  For Each j In coll
     b = b + j
  Next j
Next i
""")
</t>
<t tx="pap.120703001453.658"></t>
<t tx="pap.120703001453.659">&lt;&lt; Parsing tests &gt;&gt;=

# Simple while wend
tests.append("""
		a = 0
		While a &lt; 10
			g = 10
			a = a + 1
		Wend
""")

# Nested while wend
tests.append("""
		a = 0
		While a &lt; 10
			g = 10
			a = a + 1
			While b &lt; 40
				doit
			Wend
		Wend
""")

# Simple while wend with line numbers
tests.append("""
1:		a = 0
2:		While a &lt; 10
3:			g = 10
4:			a = a + 1
5:		Wend
""")
</t>
<t tx="pap.120703001453.660">&lt;&lt; Parsing tests &gt;&gt;=

# Simple do while loop
tests.append("""
		a = 0
		Do While a &lt; 10
			g = 10
			a = a + 1
		Loop
""")

# Simple do while with exit
tests.append("""
		a = 0
		Do While a &lt; 10
			g = 10
			a = a + 1
			Exit Do
		Loop
""")

# Nested do while loop
tests.append("""
		a = 0
		Do While a &lt; 10
			g = 10
			a = a + 1
			Do While b &lt; 40
				doit
			Loop
		Loop
""")</t>
<t tx="pap.120703001453.661">&lt;&lt; Parsing tests &gt;&gt;=

# Simple do  loop
tests.append("""
		a = 0
		Do  
			g = 10
			a = a + 1
		Loop
""")

# Simple do  with exit
tests.append("""
		a = 0
		Do 
			g = 10
			a = a + 1
			Exit Do
		Loop
""")

# Nested do  loop
tests.append("""
		a = 0
		Do 
			g = 10
			a = a + 1
			Do 
				doit
			Loop
		Loop
""")</t>
<t tx="pap.120703001453.662">&lt;&lt; Parsing tests &gt;&gt;=

# Simple do  loop
tests.append("""
		a = 0
		Do  
			g = 10
			a = a + 1
		Loop While a &lt; 10
""")

# Simple do  with exit
tests.append("""
		a = 0
		Do 
			g = 10
			a = a + 1
			Exit Do
		Loop While a &lt;10
""")

# Nested do  loop
tests.append("""
		a = 0
		Do 
			g = 10
			a = a + 1
			Do 
				doit
			Loop While a &lt;10
		Loop While a&lt; 10
""")</t>
<t tx="pap.120703001453.663">&lt;&lt; Parsing tests &gt;&gt;=

# Simple do  loop
tests.append("""
		a = 0
		Do  
			g = 10
			a = a + 1
		Loop Until a &lt; 10
""")

# Simple do  with exit
tests.append("""
		a = 0
		Do 
			g = 10
			a = a + 1
			Exit Do
		Loop Until a &lt;10
""")

# Nested do  loop
tests.append("""
		a = 0
		Do 
			g = 10
			a = a + 1
			Do 
				doit
			Loop While a &lt;10
		Loop Until a&lt; 10
""")</t>
<t tx="pap.120703001453.664">&lt;&lt; Parsing tests &gt;&gt;=

# Simple do  loop
tests.append("""
		a = 0
		Do Until a &lt; 10
			g = 10
			a = a + 1
		Loop 
""")

# Simple do  with exit
tests.append("""
		a = 0
		Do Until a &lt;10
			g = 10
			a = a + 1
			Exit Do
		Loop 
""")

# Nested do  loop
tests.append("""
		a = 0
		Do Until a&lt; 10
			g = 10
			a = a + 1
			Do While a &lt;10
				doit
			Loop 
		Loop 
""")</t>
<t tx="pap.120703001453.665">&lt;&lt; Parsing tests &gt;&gt;=

# simple type
tests.append("""
Type myType
	A As Integer
	B As String
	C As MyClass.MyType
End Type
""")

# simple type with scope
tests.append("""
Public Type myType
	A As Integer
	B As String
	C As MyClass.MyType
End Type
""")

tests.append("""
Private Type myType
	A As Integer
	B As String
	C As MyClass.MyType
End Type
""")

# With a comment inside
tests.append("""
Private Type myType
	A As Integer
	B As String
	' Here is a comment
	C As MyClass.MyType
End Type
""")</t>
<t tx="pap.120703001453.666">&lt;&lt; Parsing Tests &gt;&gt;=

# General with with just the structure
tests.append("""
With MyObject
	a = 10
End With
""")

# General with with some assignments
tests.append("""
With MyObject
	.value = 10
	.other = "Hello"
End With
""")

# General with with some assignments and expressions
tests.append("""
With MyObject
	.value = .other + 10
	.other = "Hello" &amp; .name
End With
""")

# Nested With
tests.append("""
With MyObject
	a = 10
	With .OtherObject
		b = 20
	End With
End With
""")

# General with with just the structure and labels
tests.append("""
1: With MyObject
2: 	a = 10
3: End With
""")

# Empty with
tests.append("""
With MyObject
End With
""")

</t>
<t tx="pap.120703001453.667">&lt;&lt; Parsing tests &gt;&gt;=

# Simple header found at the top of most class files
tests.append("""
VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
  Persistable = 0  'NotPersistable
  DataBindingBehavior = 0  'vbNone
  DataSourceBehavior  = 0  'vbNone
  MTSTransactionMode  = 0  'NotAnMTSObject
END
""")</t>
<t tx="pap.120703001453.668">&lt;&lt; Parsing tests &gt;&gt;=

# Simple enumeration
tests.append("""
Enum MyEnum
	one
	two
	three
	four
	five
End Enum
""")


# Scoped enumeration
tests.append("""
Public Enum MyEnum
	one
	two
	three
	four
	five
End Enum
""")

tests.append("""
Private Enum MyEnum
	one
	two
	three
	four
	five
End Enum
""")

# Simple enumeration with comments
tests.append("""
Enum MyEnum ' yeah
	one ' this 
	two ' is 
	three
	four ' neat
	five
End Enum
""")
</t>
<t tx="pap.120703001453.669">These tests fail but we accept this for v0.2 - we remove them to here so that they do not hide other (real) failures when doing the testall.py

&lt;&lt; Parsing tests &gt;&gt;=


failures = [
		"If a = 10 Then d = 1 Else If k = 12 Then b = 12",
		"If a = 10 Then d = 1 Else If k = 12 Then b = 12 Else g=123",
]
</t>
<t tx="pap.120703001453.670"></t>
<t tx="pap.120703001453.671">@root test\testframework.py

#
# Turn off logging in extensions (too loud!)
import vb2py.extensions
vb2py.extensions.disableLogging()

from unittest import *
from vb2py.vbparser import convertVBtoPython
import vb2py.vbfunctions as vbfunctions
import vb2py.vbfunctions

#
# Import script testing
try:
	import scripttest
except ImportError:
	scripttest = None
	
#
# Private data hiding may obscure some of the testing so we turn it off
import vb2py.config
Config = vb2py.config.VB2PYConfig()
Config.setLocalOveride("General", "RespectPrivateStatus", "No")
Config.setLocalOveride("General", "ReportPartialConversion", "No")

tests = []

def BasicTest():
	"""Return a new class - we do it this way to allow this to work properly for multiple tests"""
	class _BasicTest(TestCase):
		"""Holder class which gets built into a whole test case"""
	return _BasicTest
	
&lt;&lt; Test functions &gt;&gt;
	
#
# Add tests to main test class
def addTestsTo(TestClassFactory, tests):
	"""Add all the tests to the test class"""
	TestClass = TestClassFactory()
	for idx in range(len(tests)):
		setattr(TestClass, "test%d" % idx, getTestMethod(*tests[idx]))
	return TestClass

#
# Add tests to main test class using script testing
def addScriptTestsTo(TestClassFactory, tests):
	"""Add all the tests to the test class"""
	TestClass = TestClassFactory()
	for idx in range(len(tests)):
		setattr(TestClass, "test%d" % idx, getScriptTestMethod(tests[idx]))
	return TestClass
</t>
<t tx="pap.120703001453.672">@c

try:					  
	python = convertVBtoPython(vb.replace("\r\n", "\n"))
except Exception, err:
	self.fail("Error while parsing (%s)\n%s" % (err, vb))
</t>
<t tx="pap.120703001453.673">@c

try:
	exec "from vb2py.vbfunctions import *" in local_dict
	exec python in local_dict
except Exception, err:
	if not result.has_key("FAIL"):
		self.fail("Error (%s):\n%s\n....\n%s" % (err, vb, python))
else:
	if result.has_key("FAIL"):
		self.fail("Should have failed:%s\n\n%s" % (vb, python))
</t>
<t tx="pap.120703001453.674">@c

expected = {}
exec "" in expected
expected.update(result)
expected["convertVBtoPython"] = convertVBtoPython
expected["vbfunctions"] = vbfunctions

# Variables which we don't worry about
skip_variables = ["vbclasses", "logging", "logger"]</t>
<t tx="pap.120703001453.675">@c

reason = ""
for key in local_dict:
	if not (key.startswith("_") or hasattr(vb2py.vbfunctions, key)):
		try:
			if expected[key] &lt;&gt; local_dict[key]:
				reason += "%s (exp, act): '%s' &lt;&gt; '%s'\n" % (key, expected[key], local_dict[key])
		except KeyError:
			if key not in skip_variables:
				reason += "Variable didn't exist: '%s'\n" % key
</t>
<t tx="pap.120703001453.676">@root test\testassignment.py

from unittest import *
from testframework import *

&lt;&lt; Assignment tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.677">&lt;&lt; Assignment tests &gt;&gt;=

numeric = [
	('a=10', 				{'a' : 10}),
	('b=10.34', 				{'b' : 10.34}),
	('c=10e5',      {'c' : 10e5}),
	('d=-1',        {'d' :-1}),
	('e=-10.765', 		{'e' : -10.765}),
	('f=-12.4e4', 		{'f' : -12.4e4}),
	('g=1.0e-45',   {'g' : 1.0e-45}),
	('h=-1e-8',     {'h' :-1e-8}),
	('i=&amp;HFF',      {'i' :255}),
	('j=&amp;HFF&amp;',     {'j' :255}),
]

strings = [
	('a="a"',       {'a' : "a"}),	
	('b="abcdef"',  {'b' : "abcdef"}),	
	("""c="'" """,  {'c' : "'"}),	
	('d="g\"\"h\"\"j"""', {'d' : 'g"h"j"'}),	
	(r'd="\"', {'d' : '\\'}),	# Trailing single \ is tough
	(r'd="hello\not"', {'d' : r'hello\not'}),
]

tests.extend(numeric)
tests.extend(strings)
</t>
<t tx="pap.120703001453.678">&lt;&lt; Assignment tests &gt;&gt;=

numeric = [
	('Let a=10', 				{'a' : 10}),
	('Let b=10.34', 				{'b' : 10.34}),
	('Let c=10e5',      {'c' : 10e5}),
	('Let d=-1',        {'d' :-1}),
	('Let e=-10.765', 		{'e' : -10.765}),
	('Let f=-12.4e4', 		{'f' : -12.4e4}),
	('Let g=1.0e-45',   {'g' : 1.0e-45}),
	('Let h=-1e-8',     {'h' :-1e-8}),
	('Let i=&amp;HFF',      {'i' :255}),
	('Let j=&amp;HFF&amp;',     {'j' :255}),
]

strings = [
	('Let a="a"',       {'a' : "a"}),	
	('Let b="abcdef"',  {'b' : "abcdef"}),	
	("""Let c="'" """,  {'c' : "'"}),	
	('Let d="g\"\"h\"\"j"""', {'d' : 'g"h"j"'}),	
	(r'Let d="\"', {'d' : '\\'}),	# Trailing single \ is tough
	(r'Let d="hello\not"', {'d' : r'hello\not'}),
]

tests.extend(numeric)
tests.extend(strings)
</t>
<t tx="pap.120703001453.679">&lt;&lt; Assignment tests &gt;&gt;=

numeric_exp = [
	('a=10+20', 				   {'a' : 30}),
	('b=10.5+20.5',    {'b' : 31}),
	('c=(10+20)/6+2', 	{'c' : 7}),
	('d=(((4*5)/2+10)-10)', 				{'d' : 10}),
	('e=-(10*10)',     {'e' : -100}),
	('f=-10*10', 				  {'f' : -100}),
	('g=&amp;HFF', 				  {'g' : 255}),
	('h=5^2', 				  {'h' : 25}),
	('i=10 Mod 2', 			{'i' : 0}),
	('i=10 Mod 3', 			{'i' : 1}),
    ('i=10 ^ - 1',    {'i' : 0.1}),
]

string_exp = [
	('a="hello" &amp; "world"', {'a' : "helloworld"}),	
]

tests.extend(numeric_exp)
tests.extend(string_exp)
</t>
<t tx="pap.120703001453.680">&lt;&lt; Assignment tests &gt;&gt;=

# Tough to test this one - just create a collection and check it has no length
tests.append(("""
Set _a = New Collection
l = len(_a)
""", {"l" : 0}))

tests.append(("""
Set _a = New Collection
Set _b = _a
l1 = len(_a)
l2 = len(_b)
""", {"l1" : 0, "l2" : 0}))</t>
<t tx="pap.120703001453.681">&lt;&lt; Assignment tests &gt;&gt;=

tests.extend([
	('a%=10', 				{'a' : 10}),
	('a&amp;=10', 				{'a' : 10}),
	('a#=10', 				{'a' : 10}),
	('a$="10"', 				{'a' : "10"}),
])

tests.extend([
	('a=10%', 				{'a' : 10}),
	('a=10#', 				{'a' : 10}),
	('a=10&amp;', 				{'a' : 10}),
])
</t>
<t tx="pap.120703001453.682">&lt;&lt; Assignment tests &gt;&gt;=

tests.extend([
	('a=0 Or 0', 				{'a' : 0}),
	('a=1 Or 0', 				{'a' : 1}),
	('a=0 Or 1', 				{'a' : 1}),
	('a=1 Or 1', 				{'a' : 1}),
	('a=0 And 0', 				{'a' : 0}),
	('a=1 And 0', 				{'a' : 0}),
	('a=0 And 1', 				{'a' : 0}),
	('a=1 And 1', 				{'a' : 1}),

	('a=0 Or Not 0', 				{'a' : 1}),
	('a=1 Or Not 0', 				{'a' : 1}),
	('a=0 Or Not 1', 				{'a' : 0}),
	('a=1 Or Not 1', 				{'a' : 1}),
	('a=0 And Not 0', 				{'a' : 0}),
	('a=1 And Not 0', 				{'a' : 1}),
	('a=0 And Not 1', 				{'a' : 0}),
	('a=1 And Not 1', 				{'a' : 0}),

	('a=Not 0 Or 0', 				{'a' : 1}),
	('a=Not 1 Or 0', 				{'a' : 0}),
	('a=Not 0 Or 1', 				{'a' : 1}),
	('a=Not 1 Or 1', 				{'a' : 1}),
	('a=Not 0 And 0', 				{'a' : 0}),
	('a=Not 1 And 0', 				{'a' : 0}),
	('a=Not 0 And 1', 				{'a' : 1}),
	('a=Not 1 And 1', 				{'a' : 0}),

	('a=Not 0 Or Not 0', 				{'a' : 1}),
	('a=Not 1 Or Not 0', 				{'a' : 1}),
	('a=Not 0 Or Not 1', 				{'a' : 1}),
	('a=Not 1 Or Not 1', 				{'a' : 0}),
	('a=Not 0 And Not 0', 				{'a' : 1}),
	('a=Not 1 And Not 0', 				{'a' : 0}),
	('a=Not 0 And Not 1', 				{'a' : 0}),
	('a=Not 1 And Not 1', 				{'a' : 0}),
])

tests.extend([
("""
Dim _a As Object
If _a Is Nothing Then
	b = 1
Else
	b = 2
End If
""", {"b" : 1}),

("""
Dim _a As Object
Set _a = New Collection
If _a Is Nothing Then
	b = 1
Else
	b = 2
End If
""", {"b" : 2}),

("""
Dim _a As Object
Set _a = New Collection
Set _a = Nothing
If _a Is Nothing Then
	b = 1
Else
	b = 2
End If
""", {"b" : 1}),
])</t>
<t tx="pap.120703001453.683">&lt;&lt; Assignment tests &gt;&gt;=

# Lset tests
tests.append(("""
a = "1234"
LSet a = "abcdefgh"
""", {"a" : "abcd"}))

tests.append(("""
a = "1234"
LSet a = "ab"
""", {"a" : "ab  "}))

tests.append(("""
a = "1234"
LSet a = "abcd"
""", {"a" : "abcd"}))

tests.append(("""
a = ""
LSet a = "abcd"
""", {"a" : ""}))

tests.append(("""
a = "1234"
LSet a = ""
""", {"a" : "    "}))

tests.append(("""
a = ""
LSet a = ""
""", {"a" : ""}))</t>
<t tx="pap.120703001453.684">&lt;&lt; Assignment tests &gt;&gt;=

# Lset tests
tests.append(("""
a = "1234"
RSet a = "abcdefgh"
""", {"a" : "abcd"}))

tests.append(("""
a = "1234"
RSet a = "ab"
""", {"a" : "  ab"}))

tests.append(("""
a = "1234"
RSet a = "abcd"
""", {"a" : "abcd"}))

tests.append(("""
a = ""
RSet a = "abcd"
""", {"a" : ""}))

tests.append(("""
a = "1234"
RSet a = ""
""", {"a" : "    "}))

tests.append(("""
a = ""
RSet a = ""
""", {"a" : ""}))</t>
<t tx="pap.120703001453.685">@root test\testifs.py

from unittest import *
from testframework import *

&lt;&lt; If tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.686"></t>
<t tx="pap.120703001453.687">&lt;&lt; If tests &gt;&gt;=

# Test main branch of If
tests.append(
	("""a = 10
	    b = 0
		If a = 10 Then
			b = 1
		End If
	 """,
	 {"a" : 10, "b" : 1}
	))
	
# Test else branch of If
tests.append(
	("""a = 20
	    b = 0
		If a = 10 Then
			b = 1
		End If
	 """,
	 {"a" : 20, "b" : 0}
	))	
	
# Test main branch of If with not
tests.append(
	("""a = 10
	    b = 0
		If Not a = 10 Then
			b = 1
		End If
	 """,
	 {"a" : 10, "b" : 0}
	))
tests.append(
	("""a = 11
	    b = 0
		If Not a = 10 Then
			b = 1
		End If
	 """,
	 {"a" : 11, "b" : 1}
	))

# This test with the redundant parenthesis used to fail
tests.append(
	("""a = 11
	    b = 0
		If (Not a = 10) Then
			b = 1
		End If
	 """,
	 {"a" : 11, "b" : 1}
	))
</t>
<t tx="pap.120703001453.688">&lt;&lt; If tests &gt;&gt;=

# Test main branch of If
tests.append(
	("""a = 10
		If a = 10 Then
			b = 1
		Else
			b = 0
		End If
	 """,
	 {"a" : 10, "b" : 1}
	))
	
# Test else branch of If
tests.append(
	("""a = 20
		If a = 10 Then
			b = 1
		Else
			b = 0
		End If
	 """,
	 {"a" : 20, "b" : 0}
	))	</t>
<t tx="pap.120703001453.689">&lt;&lt; If tests &gt;&gt;=

# Test main branch of If
tests.append(
	("""a = 10
		If a = 10 Then
			b = 1
		ElseIf a = 20 Then
		    b = 2
		Else
			b = 0
		End If
	 """,
	 {"a" : 10, "b" : 1}
	))
	
# Test elseif branch of If
tests.append(
	("""a = 20
		If a = 10 Then
			b = 1
		ElseIf a = 20 Then
		    b = 2
		Else
			b = 0
		End If
	 """,
	 {"a" : 20, "b" : 2}
	))	

# Test else branch of If
tests.append(
	("""a = 30
		If a = 10 Then
			b = 1
		ElseIf a = 20 Then
		    b = 2
		Else
			b = 0
		End If
	 """,
	 {"a" : 30, "b" : 0}
	))	
</t>
<t tx="pap.120703001453.690"></t>
<t tx="pap.120703001453.691">&lt;&lt; If tests &gt;&gt;=

# Test main branch of If
tests.append(
	("""a = 10
	    b = 0
		c = 20
		If a = 10 Then
		    If c = 20 Then
				b = 1
			End If
		End If
	 """,
	 {"a" : 10, "b" : 1, "c" : 20}
	))
	
# Test else branch of If
tests.append(
	("""a = 10
	    b = 0
		c = 20
		If a = 10 Then
		    If c = 30 Then
				b = 1
			End If
		End If
	 """,
	 {"a" : 10, "b" : 0, "c" : 20}
	))	</t>
<t tx="pap.120703001453.692">&lt;&lt; If tests &gt;&gt;=

# Test main branch of If
tests.append(
	("""a = 10
	    b = 0
		c = 20
		If a = 10 Then
		    If c = 20 Then
				b = 1
			Else
				b = 2
			End If
		Else
			b = 3
		End If
	 """,
	 {"a" : 10, "b" : 1, "c" : 20}
	))
	
# Test else branch of If
tests.append(
	("""a = 10
	    b = 0
		c = 20
		If a = 10 Then
		    If c = 25 Then
				b = 1
			Else
				b = 2
			End If
		Else
			b = 3
		End If
	 """,
	 {"a" : 10, "b" : 2, "c" : 20}
	))	
	
tests.append(
	("""a = 10
	    b = 0
		c = 20
		If a = 15 Then
		    If c = 25 Then
				b = 1
			Else
				b = 2
			End If
		Else
			b = 3
		End If
	 """,
	 {"a" : 10, "b" : 3, "c" : 20}
	))		</t>
<t tx="pap.120703001453.693">&lt;&lt; If tests &gt;&gt;=

# Test main branch of If
tests.append(
	("""a = 10
	    b = 0
		c = 20
		If a = 10 Then
		    If c = 20 Then
				b = 1
			ElseIf c = 30 Then
				b = 4
			Else
				b = 2
			End If
		ElseIf a = 15 Then
			b = 5
		Else
			b = 3
		End If
	 """,
	 {"a" : 10, "b" : 1, "c" : 20}
	))
	
# Test else branch of If
tests.append(
	("""a = 10
	    b = 0
		c = 30
		If a = 10 Then
		    If c = 20 Then
				b = 1
			ElseIf c = 30 Then
				b = 4
			Else
				b = 2
			End If
		ElseIf a = 15 Then
			b = 5
		Else
			b = 3
		End If
	 """,
	 {"a" : 10, "b" : 4, "c" : 30}
	))

# Test else branch of If
tests.append(
	("""a = 15
	    b = 0
		c = 30
		If a = 10 Then
		    If c = 20 Then
				b = 1
			ElseIf c = 30 Then
				b = 4
			Else
				b = 2
			End If
		ElseIf a = 15 Then
			b = 5
		Else
			b = 3
		End If
	 """,
	 {"a" : 15, "b" : 5, "c" : 30}
	))

</t>
<t tx="pap.120703001453.694">&lt;&lt; If tests &gt;&gt;=

# Lots of inline ifs
tests.extend([
	("a = 0\nIf 1 &lt; 2 Then a = 10", {"a" : 10,}),	
	("a = 0\nIf 2 &lt; 1 Then a = 10", {"a" : 0,}),
	("If 1 &lt; 2 Then a = 10 Else a = 20", {"a" : 10,}),	
	("If 1 &gt; 2 Then a = 10 Else a = 20", {"a" : 20,}),	
])

# Bug #810401 python if statements may be missing a body 
tests.append((
"""
a = 0
If 1 &lt; 2 Then Resume Next
a = 10
""", {"a" : 10,}))

</t>
<t tx="pap.120703001453.695">@root test\testselect.py

from unittest import *
from testframework import *

&lt;&lt; Select tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.696">&lt;&lt; Select tests &gt;&gt;=

test_string = """
		a = %d
		Select Case a
		Case 1
			b = 10
		Case 2
			b = 20
		Case 3
			b = 30
		Case Else
			b = 40
		End Select
"""

for aval, result in ((1,10), (2,20), (3,30), (4, 40)):
	tests.append((test_string % aval,
		 		 {"a" : aval, "b" : result}))

tests.append(("""
    a = 10
	Select Case a
	Case 10
	Case 20
	End Select
	""", {"a":10}))
</t>
<t tx="pap.120703001453.697">&lt;&lt; Select tests &gt;&gt;=

# These three tests are subtly different and try to catch errors in dealing with inline Case's
test_string = """
		a = %d
		Select Case a
		Case 1 To 9
			b = 0
		Case 10 To 19
			b = 1
		Case 20 To 29
			b = 2
		Case Else
			b = 3
		End Select
"""

for aval in range(1, 40):
	result = aval // 10
	tests.append((test_string % aval,
		 		 {"a" : aval, "b" : result}))

test_string = """
		a = %d
		Select Case a
		Case 1 To 9:
			b = 0
		Case 10 To 19:
			b = 1
		Case 20 To 29:
			b = 2
		Case Else:
			b = 3
		End Select
"""

for aval in range(1, 40):
	result = aval // 10
	tests.append((test_string % aval,
		 		 {"a" : aval, "b" : result}))

test_string = """
		a = %d
		Select Case a
		Case 1 To 9: c=0
			b = 0
		Case 10 To 19: c=1
			b = 1
		Case 20 To 29: c=2
			b = 2
		Case Else: c=3
			b = 3
		End Select
"""

for aval in range(1, 40):
	result = aval // 10
	tests.append((test_string % aval,
		 		 {"a" : aval, "b" : result, "c" : result}))
</t>
<t tx="pap.120703001453.698">&lt;&lt; Select tests &gt;&gt;=

test_string = """
		a = %d
		Select Case a
		Case 1, 5, 10
			b = 10
		Case 2, 20 To 30, 15
			b = 20
		Case 3
			b = 30
		Case Else
			b = 40
		End Select
"""

for aval, result in ((1, 10), (5, 10), (10, 10),
                     (2, 20), (20, 20), (25, 20), (30, 20), (15, 20),
                     (3, 30),
                     (4, 40), (-20, 40), (1000, 40)):
	tests.append((test_string % aval,
		 		 {"a" : aval, "b" : result}))</t>
<t tx="pap.120703001453.699">&lt;&lt; Select tests &gt;&gt;=

test_string = """
		a = %d
		Select Case a
		Case 1, 5, 10
			b = 10
		Case 2, 20 To 30, 15
            Select Case a
            			Case -10 To 25
                  b = 21
               Case Else
                  b = 22
            End Select
		Case 3
			b = 30
		Case Else
			b = 40
		End Select
"""

for aval, result in ((1, 10), (5, 10), (10, 10),
                     (2, 21), (20, 21), (25, 21), (30, 22), (15, 21),
                     (3, 30),
                     (4, 40), (-20, 40), (1000, 40)):
	tests.append((test_string % aval,
		 		 {"a" : aval, "b" : result}))</t>
<t tx="pap.120703001453.700">@root test\testfor.py

from unittest import *
from testframework import *

&lt;&lt; For tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.701">&lt;&lt; For tests &gt;&gt;=

# Simple test - note we are not interested in the value of the loop variable at the end of the loop
# hence the _var name
tests.append(("""
j = 0
For _var = 1 To 10
	j = j + _var
Next _var
""", {"j" : 55}))

# Simple test with step
tests.append(("""
j = 0
For _var = 1 To 10 Step 2
	j = j + _var
Next _var
""", {"j" : 25}))

# Simple test with reverse step
tests.append(("""
j = 0
For _var = 10 To 1 Step -1
	j = j + _var
Next _var
""", {"j" : 55}))

# Empty loop
tests.append(("""
j = 0
For _var = 10 To 1
	j = j + _var
Next _var
""", {"j" : 0}))

# Breaking out of the loop
tests.append(("""
j = 0
For _var = 1 To 10
	j = j + _var
	Exit For
Next _var
""", {"j" : 1}))

# Bizarre dotted name
tests.append(("""
Dim _me As Object
j = 0
For _me.you = 1 To 10
	j = j + _me.you
Next _me.you
""", {"j" : 55}))</t>
<t tx="pap.120703001453.702">&lt;&lt; For tests &gt;&gt;=

# Nested loop
tests.append(("""
j = 0
k = 0
For _var = 1 To 10
	j = j + _var
	For _other = 1 To 10
		k = k + 1
	Next _other
Next _var
""", {"j" : 55, "k" : 100}))

# Nested loop - break from inner
tests.append(("""
j = 0
k = 0
For _var = 1 To 10
	j = j + _var
	For _other = 1 To 10
		k = k + 1
		Exit For
	Next _other
Next _var
""", {"j" : 55, "k" : 10}))

# Nested loop - break from outer
tests.append(("""
j = 0
k = 0
For _var = 1 To 10
	j = j + _var
	For _other = 1 To 10
		k = k + 1
	Next _other
	Exit For
Next _var
""", {"j" : 1, "k" : 10}))
</t>
<t tx="pap.120703001453.703">&lt;&lt; For tests &gt;&gt;=

# Simple for each with collection
tests.append(("""
Dim _c As New Collection
_c.Add 10
_c.Add 20
_c.Add 30
t = 0
For Each _v In _c
	t = t + _v
Next _v
""", {"t" : 60}))

# Nested for each with collection
tests.append(("""
Dim _c As New Collection
_c.Add 10
_c.Add 20
_c.Add 30
Dim _d As New Collection
_d.Add 1
_d.Add 2
_d.Add 3
t = 0
For Each _v In _c
	t = t + _v
	For Each _x In _d
		t = t + _x
	Next _x
Next _v
""", {"t" : 78}))

# Simple for each with variant
tests.append(("""
Dim _c(10)
For _i = 1 To 10
	_c(_i) = _i
Next _i
t = 0
For Each _v In _c
	t = t + _v
Next _v
""", {"t" : 55}))
</t>
<t tx="pap.120703001453.704">&lt;&lt; For tests &gt;&gt;=

# Simple test - note we are not interested in the value of the loop variable at the end of the loop
# hence the _var name
tests.append(("""
j = 0
For _var = 0.1 To 1.0
	j = j + _var
Next _var
""", {"j" : 0.1}))

# Simple test with step
tests.append(("""
j = 0
For _var = .1 To 1.0 Step .2
	j = j + _var
Next _var
""", {"j" : 2.5}))

# Simple test with reverse step
tests.append(("""
j = 0
For _var = 1.0 To .1 Step -.1
	j = j + _var
Next _var
j = int(j*10)
""", {"j" : 55}))

# Empty loop
tests.append(("""
j = 0
For _var = 1.0 To .1
	j = j + _var
Next _var
""", {"j" : 0}))

# Breaking out of the loop
tests.append(("""
j = 0
For _var = .1 To 1.0
	j = j + _var
	Exit For
Next _var
""", {"j" : .1}))
</t>
<t tx="pap.120703001453.705">@root test\testwhile.py

from unittest import *
from testframework import *

&lt;&lt; While tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.706">&lt;&lt; While tests &gt;&gt;=

# Simple while / wend
tests.append(("""
a = 0
b = 0
While a&lt;=10
	b = b + a
	a = a + 1
Wend
""", {"a" : 11, "b" : 55}))

# Nested While
tests.append(("""
a = 0
b = 0
While a&lt;=10
	c = 0
	While c &lt; 10
		c = c + 1
		b = b + 1
	Wend
	b = b + a
	a = a + 1
Wend
""", {"a" : 11, "b" : 165, "c" : 10}))</t>
<t tx="pap.120703001453.707">&lt;&lt; While tests &gt;&gt;=

# Simple do while loop
tests.append(("""
a = 0
b = 0
Do While a&lt;=10
	b = b + a
	a = a + 1
Loop
""", {"a" : 11, "b" : 55}))

# Simple do while loop with exit
tests.append(("""
a = 1
b = 0
Do While a&lt;=10
	b = b + a
	a = a + 1
	Exit Do
Loop
""", {"a" : 2, "b" : 1}))

# Nested Do While Loop
tests.append(("""
a = 0
b = 0
Do While a&lt;=10
	c = 0
	Do While c &lt; 10
		c = c + 1
		b = b + 1
	Loop
	b = b + a
	a = a + 1
Loop
""", {"a" : 11, "b" : 165, "c" : 10}))

# Nested Do While Loop With inner exit
tests.append(("""
a = 0
b = 0
Do While a&lt;=10
	c = 0
	Do While c &lt; 10
		c = c + 1
		b = b + 1
		Exit Do
	Loop
	b = b + a
	a = a + 1
Loop
""", {"a" : 11, "b" : 66, "c" : 1}))

# Nested Do While Loop With outer exit
tests.append(("""
a = 0
b = 0
Do While a&lt;=10
	c = 0
	Do While c &lt; 10
		c = c + 1
		b = b + 1
	Loop
	b = b + a
	a = a + 1
	Exit Do
Loop
""", {"a" : 1, "b" : 10, "c" : 10}))</t>
<t tx="pap.120703001453.708">&lt;&lt; While tests &gt;&gt;=


# Simple do while loop with exit
tests.append(("""
a = 1
b = 0
Do
	b = b + a
	a = a + 1
	Exit Do
Loop
""", {"a" : 2, "b" : 1}))


# Nested Do While Loop With inner exit
tests.append(("""
a = 0
b = 0
Do
	c = 0
	Do While c &lt; 10
		c = c + 1
		b = b + 1
		Exit Do
	Loop
	b = b + a
	a = a + 1
	Exit Do
Loop
""", {"a" : 1, "b" : 1, "c" : 1}))

# Nested Do While Loop With outer exit
tests.append(("""
a = 0
b = 0
Do
	c = 0
	Do While c &lt; 10
		c = c + 1
		b = b + 1
	Loop
	b = b + a
	a = a + 1
	Exit Do
Loop
""", {"a" : 1, "b" : 10, "c" : 10}))</t>
<t tx="pap.120703001453.709">&lt;&lt; While tests &gt;&gt;=


# Simple do until
tests.append(("""
a = 1
b = 0
Do
	b = b + a
	a = a + 1
Loop Until a &gt; 10
""", {"a" : 11, "b" : 55}))


# Nested Do Until
tests.append(("""
a = 0
b = 0
Do
	c = 0
	Do 
		c = c + 1
		b = b + 1
	Loop Until c &gt; 10
	b = b + a
	a = a + 1
Loop Until a &gt; 10
""", {"a" : 11, "b" : 176, "c" : 11}))

</t>
<t tx="pap.120703001453.710">&lt;&lt; While tests &gt;&gt;=


# Simple do until
tests.append(("""
a = 1
b = 0
Do Until a &gt; 10
	b = b + a
	a = a + 1
Loop 
""", {"a" : 11, "b" : 55}))


# Nested Do Until
tests.append(("""
a = 0
b = 0
Do Until a &gt; 10
	c = 0
	Do Until c &gt; 10
		c = c + 1
		b = b + 1
	Loop 
	b = b + a
	a = a + 1
Loop 
""", {"a" : 11, "b" : 176, "c" : 11}))

</t>
<t tx="pap.120703001453.711">@root test\testfns.py

from unittest import *
from testframework import *

&lt;&lt; Fn tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.712">&lt;&lt; Fn tests &gt;&gt;=

# Simple function
tests.append(("""
Function _square(x)
	_square = x*x
End Function
a = _square(10)
""", {"a" : 100}))

# Simple function with a type
tests.append(("""
Function _square(x) As Single
	_square = x*x
End Function
a = _square(10)
""", {"a" : 100}))

# Accidental non-return
tests.append(("""
Function _square(x)
End Function
a = _square(10)
""", {"a" : None}))

# Function calling a function
tests.append(("""
Function _double(x)
	_double = 2*x
End Function

Function _squaredouble(x)
	_squaredouble = _double(x) * _double(x)
End Function

a = _squaredouble(10)
""", {"a" : 400}))

# Function with exit
tests.append(("""
Function _square(x)
	If x &gt; 0 Then
		_square = x*x
		Exit Function
	End If
	_square = -(x*x)
End Function
a = _square(10)
b = _square(-10)
""", {"a" : 100, "b" : -100}))

# Simple function with no arguments, must detect that it is a function call
tests.append(("""
Function _square()
	_square = 100
End Function
a = _square
""", {"a" : 100}))
</t>
<t tx="pap.120703001453.713">&lt;&lt; Fn tests &gt;&gt;=

# Recursive function
tests.append(("""
Function _factorial(x)
	If x = 0 Then
		_factorial = 1
	Else
		_factorial = _factorial(x-1) * x
	End If
End Function
a = _factorial(10)
""", {"a" : 3628800}))
</t>
<t tx="pap.120703001453.714">&lt;&lt; Fn tests &gt;&gt;=

# Lots of arguments
tests.append(("""
Function _sum(a,b,c,d,e,f,g,h,i)
	_sum = a+b+c+d+e+f+g+h+i
End Function
a = _sum(1,2,3,4,5,6,7,8,9)
""", {"a" : 45}))

# Lots of arguments with types
tests.append(("""
Function _sum(a As Integer,b As Single,c,d As String,e,f,g As Single,h,i)
	_sum = a+b+c+d+e+f+g+h+i
End Function
a = _sum(1,2,3,4,5,6,7,8,9)
""", {"a" : 45}))

# Some arguments with options
tests.append(("""
Function _sum(a, b, Optional c)
	If IsMissing(c) Then c = 10
	_sum = a+b+c
End Function
a = _sum(1,2,3)
b = _sum(1,2)
""", {"a" : 6, "b" : 13}))

# Some arguments with options and defaults
tests.append(("""
Function _sum(a, b, Optional c=10)
	_sum = a+b+c
End Function
a = _sum(1,2,3)
b = _sum(1,2)
""", {"a" : 6, "b" : 13}))

</t>
<t tx="pap.120703001453.715">&lt;&lt; Fn tests &gt;&gt;=

# Function with named arguments
tests.append(("""
Function _sum(Optional x=1, Optional y=2, Optional z=3)
	_sum = x + y + z
End Function
a = _sum(10, 20, 30)
b = _sum(x:=10)
c = _sum(z:=10)
d = _sum()
f = _sum(x:=10, y:=20, z:=30)
""", {"a" : 60, "b" : 15, "c" : 13, "d" : 6, "f" : 60}))
</t>
<t tx="pap.120703001453.716">@root test\testsubs.py

from unittest import *
from testframework import *

&lt;&lt; Sub tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.717">&lt;&lt; Sub tests &gt;&gt;=

# Simple subroutine - use "global" to see results of the subroutine
tests.append(("""
Dim _lst(10) As Single
Sub _SetValue(Index As Integer, Value As String)
	_lst(Index) = Value
End Sub

_SetValue 5, "hello"
a = _lst(5)
""", {"a" : "hello"}))

# Simple subroutine with an exit
tests.append(("""
Dim _lst(10) As Single
Sub _SetValue(Index As Integer, Value1 As String, Value2 As String)
	_lst(Index) = Value1
	Exit Sub
	_lst(Index) = Value2
End Sub

_SetValue 5, "hello", "bye"
a = _lst(5)
""", {"a" : "hello"}))

# Simple sub calling a sub
tests.append(("""
Dim _lst(10) As Single
Sub _SetValue(Index As Integer, Value As String)
	_lst(Index) = Value
End Sub

Sub _SetFive(Value)
	_SetValue 5, Value
End Sub

_SetFive "hello"
a = _lst(5)
""", {"a" : "hello"}))

# Subroutine empty but for a comment - this can be a syntax error in Python
tests.append(("""
Sub _SetValue()
	' Nothing to see here
End Sub
""", {}))
</t>
<t tx="pap.120703001453.718">&lt;&lt; Sub tests &gt;&gt;=

# Recursive sub
tests.append(("""
Dim _lst(10) As Single
Sub _SetValue(Index As Integer, Value)
	_lst(Index) = Value
	If Index &lt; 10 Then 
		_SetValue Index+1, Value+1
	End If
End Sub

_SetValue 1, 1
a = _lst(5)
""", {"a" : 5}))</t>
<t tx="pap.120703001453.719">&lt;&lt; Sub tests &gt;&gt;=

# Optional arguments
tests.append(("""
Dim _lst(10) As Single
Sub _SetValue(Index As Integer, Optional Value=10)
	_lst(Index) = Value
End Sub

_SetValue 5, "hello"
_SetValue 6
a = _lst(5)
b = _lst(6)
""", {"a" : "hello", "b" : 10}))

# Optional arguments
tests.append(("""
Dim _lst(10) As Single
Sub _SetValue(Index As Integer, Optional Value)
    If IsMissing(Value) Then Value = 10
	_lst(Index) = Value
End Sub

_SetValue 5, "hello"
_SetValue 6
a = _lst(5)
b = _lst(6)
""", {"a" : "hello", "b" : 10}))

# Optional arguments with hex numbers
tests.append(("""
Dim _lst(10) As Single
Sub _SetValue(Index As Integer, Optional Value=&amp;HA)
	_lst(Index) = Value
End Sub

_SetValue 5, "hello"
_SetValue 6
a = _lst(5)
b = _lst(6)
""", {"a" : "hello", "b" : 10}))
</t>
<t tx="pap.120703001453.720">&lt;&lt; Sub tests &gt;&gt;=

# Sub with named arguments
tests.append(("""
Dim _vals(10)
Sub _sum(Optional x=1, Optional y=2, Optional z=3)
	_vals(1) = x + y + z
End Sub

_sum 10, 20, 30
a = _vals(1)
_sum x:=10
b = _vals(1)
_sum z:=10 
c = _vals(1)
_sum
d = _vals(1)
_sum x:=10, y:=20, z:=30
f = _vals(1)
""", {"a" : 60, "b" : 15, "c" : 13, "d" : 6, "f" : 60}))
</t>
<t tx="pap.120703001453.721">@root test\testdims.py

from unittest import *
from testframework import *

&lt;&lt; Dim tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.722">&lt;&lt; Dim tests &gt;&gt;=

# Untyped
tests.append(("""
Dim a, b, c
a = 10
b = "hello"
c = 123.5
""", {"a" : 10, "b" : "hello", "c" : 123.5}
))

# Typed
tests.append(("""
Dim a As Integer, b As String, c As Single
a = 10
b = "hello"
c = 123.5
""", {"a" : 10, "b" : "hello", "c" : 123.5}
))

# Array of integers
tests.append(("""
Dim a(3) As Integer
a(0) = 1
a(1) = 2
a(2) = 3
a(3) = 4
""", {"a" : [1,2,3,4]}
))

# Array of integers with non-zero offset
tests.append(("""
Dim a(1 To 3) As Integer
a(1) = 2
a(2) = 3
a(3) = 4
""", {"a" : [2,3,4]}
))

# String size indicator
tests.append(("""
Dim _a As String * 20
b = Len(_a)
""", {"b" : 20}
))</t>
<t tx="pap.120703001453.723">&lt;&lt; Dim tests &gt;&gt;=

# Redims
tests.append(("""
Dim _a() As Single
ReDim _a(10)
b = len(_a)
""", {"b" : 11}))

# Redims without preserving
tests.append(("""
Dim _a(10) As Single
_a(5) = 10
ReDim _a(10)
b = 0 + _a(5)
""", {"b" : 0}))

# Redims with preserving
tests.append(("""
Dim _a(10) As Single
_a(5) = 10
ReDim Preserve _a(10)
b = 0 + _a(5)
""", {"b" : 10}))

# Redims with preserving
tests.append(("""
Dim _a(10, 5) As Single
_a(5, 1) = 10
_a(8, 4) = 20
ReDim Preserve _a(20, 10)
b = _a(5, 1)
c = _a(8, 4)
""", {"b" : 10, "c" : 20}))

# Redims with preserving
tests.append(("""
Dim _a(10) As Single
_a(5) = 10
_a(8) = 10
ReDim Preserve _a(5)
b = _a(5)
""", {"b" : 10}))
</t>
<t tx="pap.120703001453.724">&lt;&lt; Dim tests &gt;&gt;=

# Double dim!
tests.append(("""
Dim _a(10), _b(10)
for _i = 1 To 10
   _a(_i) = _i+1
   _b(_i) = _i*10
Next _i
'
c = _b(_a(1))
d = _b(_a(2))
""", {"c" : 20, "d" : 30}
))

# Double dim set 
tests.append(("""
Dim _a(10), _b(10)
for _i = 1 To 10
   _a(_i) = _i+1
   _b(_i) = _i*10
Next _i
'
_b(_a(1)) = 101
_b(_a(2)) = 202
'
c = _b(2)
d = _b(3)
""", {"c" : 101, "d" : 202}
))

# Get Dim Fn!
tests.append(("""
Dim  _b(10)
for _i = 1 To 10
   _b(_i) = _i*10
Next _i
'
Function _a(x)
   _a = x+1
End Function
'
c = _b(_a(1))
d = _b(_a(2))
""", {"c" : 20, "d" : 30}
))

# Set Dim Fn
tests.append(("""
Dim  _b(10)
for _i = 1 To 10
   _b(_i) = _i*10
Next _i
'
Function _a(x)
   _a = x+1
End Function
'
_b(_a(1)) = 101
_b(_a(2)) = 202
'
c = _b(2)
d = _b(3)
""", {"c" : 101, "d" : 202}
))</t>
<t tx="pap.120703001453.725">&lt;&lt; Dim tests &gt;&gt;=

# Bug #810403  - Empty Dim should still create an array
tests.append(("""
Global _a() As String
b = (_a="") ' Check we got an array not a string
ReDim _a(10)
_a(1) = "hello"
_a(10) = "bye"
c = _a(1)
d = _a(10)
""", {"b" : 0, "c" : "hello", "d" : "bye"}
))
</t>
<t tx="pap.120703001453.726">@root test\testintrinsic.py

from unittest import *
from testframework import *

&lt;&lt; Intrinsic tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.727">&lt;&lt; Intrinsic tests &gt;&gt;=

# Concatenation
tests.append(("""
a = "hello"
b = "there"
c = a &amp; b
""", {"a" : "hello", "b" : "there", "c" : "hellothere"}))

# Lots of Concatenation
tests.append(("""
a = "hello"
b = "there"
c = a &amp; a &amp; a &amp; b &amp; b &amp; b
""", {"a" : "hello", "b" : "there", "c" : "hellohellohellotheretherethere"}))

# Left
tests.append(("""
a = "hello"
b = Left(a, 1)
c = Left(a, 2)
d = Left(a, 10)
""", {"a" : "hello", "b" : "h", "c" : "he", "d" : "hello"}))

# Right
tests.append(("""
a = "hello"
b = Right(a, 1)
c = Right(a, 2)
d = Right(a, 10)
""", {"a" : "hello", "b" : "o", "c" : "lo", "d" : "hello"}))

# Mid with one parameter
tests.append(("""
a = "hellothere"
b = Mid(a, 1)
c = Mid(a, 2)
d = Mid(a, 5)
""", {"a" : "hellothere", "b" : "hellothere", "c" : "ellothere", "d" : "othere"}))

# Mid with two parameters
tests.append(("""
a = "hellothere"
b = Mid(a, 1, 3)
c = Mid(a, 2, 4)
d = Mid(a, 5, 20)
""", {"a" : "hellothere", "b" : "hel", "c" : "ello", "d" : "othere"}))
</t>
<t tx="pap.120703001453.728">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
	('a = InStr("hello", "ll")', {"a" : 3}),
	('a = InStr("hello", "lll")', {"a" : 0}),
	('a = InStr(4, "hellollo", "ll")', {"a" : 6}),
	('a = InStr(4, "hellollo", "lll")', {"a" : 0}),

# InstrB ??

	('a = Len("hello")', {"a" : 5}),
	('a = Len("")', {"a" : 0}),

	('a = LCase("hello")', {"a" : "hello"}),
	('a = LCase("HELlo")', {"a" : "hello"}),
	('a = LCase("HELLO")', {"a" : "hello"}),

	('a = UCase("hello")', {"a" : "HELLO"}),
	('a = UCase("HELlo")', {"a" : "HELLO"}),
	('a = UCase("HELLO")', {"a" : "HELLO"}),
	
	('a = Space(4)', {"a" : "    "}),
	('a = Space("4")', {"a" : "    "}),
	('a = Space("0")', {"a" : ""}),
	
	('a = StrComp("one", "two")', {"a" : -1}),
	('a = StrComp("two", "two")', {"a" : 0}),
	('a = StrComp("two", "one")', {"a" : 1}),

	('a = String(4, "a")', {"a" : "aaaa"}),
	('a = String(0, "a")', {"a" : ""}),
	('a = String(4, "abc")', {"a" : "aaaa"}),

	('a = LTrim("  hello there   ")', {"a" : "hello there   "}),
	('a = LTrim("hello there   ")', {"a" : "hello there   "}),

	('a = RTrim("  hello there   ")', {"a" : "  hello there"}),
	('a = RTrim("  hello there")', {"a" : "  hello there"}),

	('a = Trim("  hello there   ")', {"a" : "hello there"}),
	('a = Trim("hello there")', {"a" : "hello there"}),

	('a = Trim(1234)', {"a" : "1234"}),
	('a = LTrim(1234)', {"a" : "1234"}),
	('a = RTrim(1234)', {"a" : "1234"}),
	
	('a = IsNumeric("nope")', {"a" : 0}),
	('a = IsNumeric("123nope")', {"a" : 0}),
	('a = IsNumeric("123.0nope")', {"a" : 0}),
	('a = IsNumeric("123.0ne10 ope")', {"a" : 0}),
	('a = IsNumeric("1")', {"a" : 1}),
	('a = IsNumeric("-1")', {"a" : 1}),
	('a = IsNumeric("-12.45")', {"a" : 1}),
	('a = IsNumeric("-12.45e5")', {"a" : 1}),
	('a = IsNumeric("-12.45e-5")', {"a" : 1}),
	('a = IsNumeric("12.45")', {"a" : 1}),
	('a = IsNumeric("12.45e5")', {"a" : 1}),
	('a = IsNumeric("12.45e-5")', {"a" : 1}),
	('a = IsNumeric("+12.45")', {"a" : 1}),
	('a = IsNumeric("+12.45e5")', {"a" : 1}),
	('a = IsNumeric("+12.45e-5")', {"a" : 1}),
])</t>
<t tx="pap.120703001453.729">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
	('a = Asc("a")', {"a" : 97}),
	('a = AscB("a")', {"a" : 97}),
	('a = AscW("a")', {"a" : 97}),
	
	('a = Abs(101)', {"a" : 101}),
	('a = Abs(-101)', {"a" : 101}),
	
	('a = Chr(97)', {"a" : "a"}),
	('a = ChrB(97)', {"a" : "a"}),
	('a = ChrW(97)', {"a" : "a"}),

# CDATE?

])
	
</t>
<t tx="pap.120703001453.730">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
	('a = CBool(-1)', {"a" : 1}),
	('a = CBool(0)', {"a" : 0}),
	('a = CBool(-1)', {"a" : 1}),

	('a = CByte(-1)', {"FAIL" : 1}),
	('a = CByte(67.4)', {"a" : 67}),
	('a = CByte("123.8")', {"a" : 124}),
	('a = CByte("1023")', {"FAIL" : 1}),
	('a = CByte("1ggg023")', {"FAIL" : 1}),
	
	('a = CDbl(-1)', {"a" : -1}),
	('a = CDbl(67.3)', {"a" : 67.3}),
	('a = CDbl("123")', {"a" : 123}),
	('a = CDbl("1023.1")', {"a" : 1023.1}),
	('a = CDbl("1023.8")', {"a" : 1023.8}),
	('a = CDbl("1ggg023")', {"FAIL" : 1}),
	
	('a = CInt(-1)', {"a" : -1}),
	('a = CInt(67.1)', {"a" : 67}),
	('a = CInt("123.3")', {"a" : 123}),
	('a = CInt("1023.8")', {"a" : 1024}),
	('a = CInt("-331023")', {"FAIL" : 1}),
	('a = CInt("331023")', {"FAIL" : 1}),
	('a = CInt("1ggg023")', {"FAIL" : 1}),

	('a = CLng(-1)', {"a" : -1}),
	('a = CLng(67.2)', {"a" : 67}),
	('a = CLng("123")', {"a" : 123}),
	('a = CLng("1023.1")', {"a" : 1023}),
	('a = CLng("-331023")', {"a" : -331023}),
	('a = CLng("331023.8")', {"a" : 331024}),
	('a = CLng("1ggg023")', {"FAIL" : 1}),

	('a = CSng(-1)', {"a" : -1}),
	('a = CSng(67.3)', {"a" : 67.3}),
	('a = CSng("123")', {"a" : 123}),
	('a = CSng("1023.1")', {"a" : 1023.1}),
	('a = CSng("1023.8")', {"a" : 1023.8}),
	('a = CSng("1ggg023")', {"FAIL" : 1}),

	('a = CStr(-1)', {"a" : "-1"}),
	('a = CStr("hello")', {"a" : "hello"}),

])	</t>
<t tx="pap.120703001453.731">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
	('a = Hex(255)', {"a" : "FF"}),
	('a = Hex("255")', {"a" : "FF"}),
	('a = Hex(0)', {"a" : "0"}),
	('a = Hex(12345)', {"a" : "3039"}),

	('a = Oct(255)', {"a" : "377"}),
	('a = Oct("255")', {"a" : "377"}),
	('a = Oct(0)', {"a" : "0"}),
	('a = Oct(12345)', {"a" : "30071"}),
	
	('a = Fix(-1)', {"a" : -1}),
	('a = Fix(67.1)', {"a" : 67}),
	('a = Fix("123.3")', {"a" : 123}),
	('a = Fix("1023.8")', {"a" : 1023}),
	
	('a = Int(-1)', {"a" : -1}),
	('a = Int(67.1)', {"a" : 67}),
	('a = Int("123.3")', {"a" : 123}),
	('a = Int("1023.8")', {"a" : 1023}),

	('a = Sgn(-1)', {"a" : -1}),
	('a = Sgn(0)', {"a" : 0}),
	('a = Sgn(1)', {"a" : 1}),
	('a = Sgn("-10")', {"a" : -1}),
	('a = Sgn("10")', {"a" : 1}),
])

</t>
<t tx="pap.120703001453.732">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
	('a = Sin(0)', {"a" : 0}),
	('a = Sin("0")', {"a" : 0}),

	('a = Cos(0)', {"a" : 1}),
	('a = Cos("0")', {"a" : 1}),

	('a = Tan(0)', {"a" : 0}),
	('a = Tan("0")', {"a" : 0}),

	('a = Int(10*Atn(10))', {"a" : 14}),
	('a = Int(10*Atn("10"))', {"a" : 14}),

	('a = Exp(0)', {"a" : 1}),
	('a = Exp("0")', {"a" : 1}),
	
	('a = Int(Log(10))', {"a" : 2}),
	('a = Int(Log("10"))', {"a" : 2}),
	
	('a = Sqr(16)', {"a" : 4}),
	('a = Sqr("16")', {"a" : 4}),

	('a = Round(1.1)', {"a" : 1}),
	('a = Round(1.6)', {"a" : 2}),
	
	('a = Round(1.1, 0)', {"a" : 1}),
	('a = Round(1.6, 0)', {"a" : 2}),

	('a = Round(1.11, 1)', {"a" : 1.1}),
	('a = Round(1.16, 1)', {"a" : 1.2}),

	('a = Round(-1.1)', {"a" : -1}),
	('a = Round(-1.6)', {"a" : -2}),
	
	('a = Round(-1.1, 0)', {"a" : -1}),
	('a = Round(-1.6, 0)', {"a" : -2}),

	('a = Round(-1.11, 1)', {"a" : -1.1}),
	('a = Round(-1.16, 1)', {"a" : -1.2}),
])

</t>
<t tx="pap.120703001453.733"></t>
<t tx="pap.120703001453.734">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
Dim _A
b = UBound(_A)
""", {"FAIL" : 1}),

("""
Dim _A(10)
b = UBound(_A)
""", {"b" : 10}),

("""
Dim _A(10, 20)
b = UBound(_A)
c = UBound(_A, 1)
d = UBound(_A, 2)
""", {"b" : 10, "c" : 10, "d" : 20}),

("""
Dim _A(10, 20, 30)
b = UBound(_A)
c = UBound(_A, 1)
d = UBound(_A, 2)
e = UBound(_A, 3)
""", {"b" : 10, "c" : 10, "d" : 20, "e" : 30}),

("""
Dim _A(5 To 10, 10 To 20, 30)
b = UBound(_A)
c = UBound(_A, 1)
d = UBound(_A, 2)
e = UBound(_A, 3)
""", {"b" : 10, "c" : 10, "d" : 20, "e" : 30}),
])</t>
<t tx="pap.120703001453.735">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
Dim _A
b = LBound(_A)
""", {"FAIL" : 1}),

("""
Dim _A(10)
b = LBound(_A)
""", {"b" : 0}),

("""
Dim _A(10, 20)
b = LBound(_A)
c = LBound(_A, 1)
d = LBound(_A, 2)
""", {"b" : 0, "c" : 0, "d" : 0}),

("""
Dim _A(10, 20, 30)
b = LBound(_A)
c = LBound(_A, 1)
d = LBound(_A, 2)
e = LBound(_A, 3)
""", {"b" : 0, "c" : 0, "d" : 0, "e" : 0}),

("""
Dim _A(5 To 10, 10 To 20, 30)
b = LBound(_A)
c = LBound(_A, 1)
d = LBound(_A, 2)
e = LBound(_A, 3)
""", {"b" : 5, "c" : 5, "d" : 10, "e" : 0}),
])</t>
<t tx="pap.120703001453.736">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
	('a = Val("12")', {"a" : 12}),
	('a = Val("12.")', {"a" : 12}),
	('a = Val("-12.")', {"a" : -12}),
	('a = Val("-12")', {"a" : -12}),
	('a = Val("-12.5")', {"a" : -12.5}),
	('a = Val("12.5")', {"a" : 12.5}),
	('a = Val("12.5e5")', {"a" : 12.5e5}),
	('a = Val("-12.5e5")', {"a" : -12.5e5}),
	('a = Val("-12.5e-5")', {"a" : -12.5e-5}),
	('a = Val("12.5e-5")', {"a" : 12.5e-5}),
	('a = Val("12.5e-5 mdmdmf")', {"a" : 12.5e-5}),
	('a = Val("12 mdmdmf")', {"a" : 12}),
	('a = Val("12+mdmdmf")', {"a" : 12}),
	('a = Val("12-mdmdmf")', {"a" : 12}),
	('a = Val(" 12-mdmdmf")', {"a" : 12}),
	('a = Val("ccc 12-mdmdmf")', {"a" : 0}),
])
</t>
<t tx="pap.120703001453.737">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
_a = Array(1,2,3,4)
l = UBound(_a)
a1 = _a(0)
a3 = _a(3)
""", {
   "l" : 3,
   "a1" : 1,
   "a3" : 4,
}),

("""
_a = Array("1","2","3","4")
l = UBound(_a)
a1 = _a(0)
a3 = _a(3)
""", {
   "l" : 3,
   "a1" : "1",
   "a3" : "4",
}),

("""
_a = Array(Array(10,20,30),"2","3","4")
l = UBound(_a)
a1 = _a(0)(0)
a3 = _a(3)
""", {
   "l" : 3,
   "a1" : 10,
   "a3" : "4",
}),

("""
_a = Array()
l = UBound(_a)
""", {
   "l" : -1,
}),

])
</t>
<t tx="pap.120703001453.738">@root test\testintrinsic2.py

from unittest import *
from testframework import *

&lt;&lt; Intrinsic tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.739">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
_a = Array(1,2,3,4)
t = IsArray(_a)
f = IsArray(t)
""", {
   "t" : 1,
   "f" : 0,
}),
])
</t>
<t tx="pap.120703001453.740">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
t = IIf(10&lt;20, "true", "false")
f = IIf(10&gt;20, "true", "false")
""", {
   "t" : "true",
   "f" : "false",
}),
])
</t>
<t tx="pap.120703001453.741">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""a = StrReverse("")""", { "a" : "",}),
("""a = StrReverse("1")""", { "a" : "1",}),
("""a = StrReverse("1234")""", { "a" : "4321",}),
("""a = StrReverse(1234)""", { "a" : "4321",}),
])
</t>
<t tx="pap.120703001453.742">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("a = Choose(1)", { "a" : None,}),
("a = Choose(1, 10)", { "a" : 10,}),
("a = Choose(1, 10, 20, 30)", { "a" : 10,}),
("a = Choose(2, 10, 20, 30)", { "a" : 20,}),
("a = Choose(3, 10, 20, 30)", { "a" : 30,}),
("a = Choose(-1, 10, 20, 30)", { "a" : None}),
("a = Choose(20, 10, 20, 30)", { "a" : None}),
])
</t>
<t tx="pap.120703001453.743">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
('a = Join(Array(1,2,3))', { "a" : "1 2 3",}),
('a = Join(Array(1,2,3), ",")', { "a" : "1,2,3",}),
('a = Join(Array(1,2,3), "")', { "a" : "123",}),
('a = Join(Array("1","2","3"))', { "a" : "1 2 3",}),
('a = Join(Array("1","2","3"), ",")', { "a" : "1,2,3",}),
('a = Join(Array("1","2","3"), "")', { "a" : "123",}),
('a = Join(Array("1","2","3"), "  ")', { "a" : "1  2  3",}),
])
</t>
<t tx="pap.120703001453.744">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
('a = Switch()', { "a" : None,}),
('a = Switch(1,0)', { "a" : 0,}),
('a = Switch(0,0,1,10)', { "a" : 10,}),
('a = Switch(0,0,1,10,1,20)', { "a" : 10,}),
('a = Switch(0,0,0,10,1,20)', { "a" : 20,}),
('a = Switch(0,0,0,10,0,20)', { "a" : None,}),
('a = Switch(1&gt;0,0,1&gt;0,10,1&gt;0,20)', { "a" : 0,}),
('a = Switch(1&lt;0,0,1&gt;0,10,1&gt;0,20)', { "a" : 10,}),
('a = Switch(1&lt;0,0,1&lt;0,10,1&gt;0,20)', { "a" : 20,}),
('a = Switch(1&lt;0,0,1&lt;0,10,1&lt;0,20)', { "a" : None,}),
])
</t>
<t tx="pap.120703001453.745">&lt;&lt; Intrinsic tests &gt;&gt;=

tests.extend([
("""
_a = Split("ab cd efg hijk")
l = UBound(_a)
a1 = _a(0)
a3 = _a(3)
""", { "l" : 3,
	   "a1" : "ab",
	   "a3" : "hijk"}),

("""
_a = Split("ab cd efg hijk", " ")
l = UBound(_a)
a1 = _a(0)
a3 = _a(3)
""", { "l" : 3,
	   "a1" : "ab",
	   "a3" : "hijk"}),

("""
_a = Split("ab cd efg hijk", ",")
l = UBound(_a)
a1 = _a(0)
""", { "l" : 0,
	   "a1" : "ab cd efg hijk",}),

("""
_a = Split("ab,cd,efg,hijk", ",")
l = UBound(_a)
a1 = _a(0)
a3 = _a(3)
""", { "l" : 3,
	   "a1" : "ab",
	   "a3" : "hijk"}),
	   
("""
_a = Split("ab,cd,efg,hijk", ",", 1)
l = UBound(_a)
a1 = _a(0)
""", { "l" : 0,
	   "a1" : "ab,cd,efg,hijk",}),
	   
("""
_a = Split("ab,cd,efg,hijk", ",",2)
l = UBound(_a)
a1 = _a(0)
a2 = _a(1)
""", { "l" : 1,
	   "a1" : "ab",
	   "a2" : "cd,efg,hijk"}),

("""
_a = Split("ab,cd,efg,hijk", ",", 10)
l = UBound(_a)
a1 = _a(0)
a3 = _a(3)
""", { "l" : 3,
	   "a1" : "ab",
	   "a3" : "hijk"}),

])
</t>
<t tx="pap.120703001453.746">@root test\testoperators.py

from unittest import *
from testframework import *

&lt;&lt; Operators tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.747">&lt;&lt; Operators tests &gt;&gt;=

tests.extend([
	('a = "the dog" Like "*dog"', {"a" : 1}),
	('a = "the big dog" Like "*dog"', {"a" : 1}),
	('a = "the big dooog" Like "*dog"', {"a" : 0}),
	('a = "the big dooog" Like "the*"', {"a" : 1}),
	('a = "   the big dooog" Like "the*"', {"a" : 0}),
	('a = "   the big dooog" Like "*the*"', {"a" : 1}),
	('a = "the doggy" Like "*dog??"', {"a" : 1}),
	('a = "the doggy" Like "*dog???"', {"a" : 0}),
	('a = "the doggy" Like "*dog?"', {"a" : 0}),
	('a = "the dogs" Like "*dog?"', {"a" : 1}),
	('a = "the dogs" Like "??? dog?"', {"a" : 1}),
	('a = "them dogs" Like "??? dog?"', {"a" : 0}),
	
	('a = "the" &amp; "dog" Like "???dog"', {"a" : 1}),
	('a = "one" &amp; "the" &amp; "dog" Like "???dog"', {"a" : 0}),
	
])
</t>
<t tx="pap.120703001453.748">&lt;&lt; Operators tests &gt;&gt;=

tests.extend([
	('a = 0 Xor 0', {"a" : 0}),
	('a = 1 Xor 0', {"a" : 1}),
	('a = 0 Xor 1', {"a" : 1}),
	('a = 1 Xor 1', {"a" : 0}),

	('a = 10 Xor 2', {"a" : 8}),
	('a = 100 Xor 254', {"a" : 154}),

])
</t>
<t tx="pap.120703001453.749">@root test\testtypes.py

from unittest import *
from testframework import *

&lt;&lt; Type tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.750">&lt;&lt; Type Tests &gt;&gt;=

# Simple test
tests.append(("""
Type _Point
	X As Single
	Y As Single
End Type
Dim _a As _Point
_a.X = 10
_a.Y = 20
b = _a.X + _a.Y
""", {"b" : 30}))

# Nested Types
tests.append(("""
Type _Point
	X As Single
	Y As Single
End Type
Type _Line
	P1 As _Point
	P2 As _Point
End Type
Dim _a As _Line
_a.P1.X = 10
_a.P2.X = 20
_a.P1.Y = 1
_a.P2.Y = 2
b = _a.P1.X + _a.P1.Y
c = _a.P2.X + _a.P2.Y
""", {"b" : 11, "c" : 22}))

# Empty type
tests.append(("""
Type _Point
End Type
Dim _a As _Point
""", {}))
</t>
<t tx="pap.120703001453.751">&lt;&lt; Type Tests &gt;&gt;=

# Arrays of a type
tests.append(("""
Type _Point
	X As Single
	Y As Single
End Type

Dim _p(5) As _Point

tx = 0
ty = 0
For _i = 1 To 5
	_p(_i).X = _i
	_p(_i).Y = 2*_i
	tx = tx + _p(_i).X
	ty = ty + _p(_i).Y
Next _i
""", {"tx" : 15, "ty" : 30}))
</t>
<t tx="pap.120703001453.752">@root test\testfiles.py

from unittest import *
from testframework import *
import os 
import vb2py.utils
PATH = vb2py.utils.rootPath()

&lt;&lt; File tests &gt;&gt;


import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)


if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.753">It is hard to test opening and closing files without reading so we do things all at once

&lt;&lt; File tests &gt;&gt;=

# Open with Input
tests.append((r"""
Open "%s" For Input As #3
Input #3, a
Input #3, b
Input #3, c, d, e
Input #3, f, g
Close #3
""" % vb2py.utils.relativePath("test\\testread.txt"), {'a' : 'Can you hear me now?',
      'b' : 'Can you still hear me now?',
	  'c' : 10, 'd' : 20, 'e' : 30,
	  'f' : 5, 'g' : "hello",
}))

# Open with Line Input
tests.append((r"""
Open "%s\\test\\testread.txt" For Input As #3
Line Input #3, a
Line Input #3, b
Line Input #3, c
Line Input #3, d
Close #3
""" % PATH, {'a' : 'Can you hear me now?',
      'b' : 'Can you still hear me now?',
	  'c' : '10, 20, 30',
	  'd' : '5, "hello"',
}))


# Open and using Input() to get numbers of characters
tests.append((r"""
Open "%s\\test\\testread.txt" For Input As #3
a = Input(3, #3)
b = Input(1, #3)
c = Input(3, #3)
Close #3
""" % PATH, {'a' : 'Can',
      'b' : ' ',
	  'c' : 'you',
}))

# Bug #810964 Input with indexed variable fails 
tests.append((r"""
Open "%s\\test\\testread.txt" For Input As #3
Dim _a(3) As String
Input #3, _a(1), _a(2), _a(3)
Close #3
a = _a(1)
b = _a(2)
c = _a(3)
""" % PATH, {'a' : 'Can you hear me now?',
      'b' : 'Can you still hear me now?',
	  'c' : 10,
}))
</t>
<t tx="pap.120703001453.754">It is hard to test opening and closing files without reading so we do things all at once

&lt;&lt; File tests &gt;&gt;=

# Open with print
tests.append((r"""
Open "%s/test/testwrite.txt" For Output As #3
Print #3, 10
Print #3, 20, 30
Print #3, 40, 50
Print #3, "hello"
Close #3
Open "%s/test/testwrite.txt" For Input As #3
Input #3, a, b, c, d, f
Line Input #3, e
""" % (PATH, PATH), {'a' : 10, 'b' : 20,
	  'c' : 30, 'd' : 40, 'e' : 'hello',
	  'f' : 50,
}))


# Open with print but no cr
tests.append((r"""
Open "%s/test/testwrite.txt" For Output As #3
Print #3, 10;
Print #3, 20, 30;
Print #3, 40, "hello", 50;
Close #3
Open "%s/test/testwrite.txt" For Input As #3
Line Input #3, a
""" % (PATH, PATH), {'a' : "1020\t3040\thello\t50"}
))


# Bare print with no channel number (Bug #805866 - used to fail during render)
tests.append(("Print 10", {}))
</t>
<t tx="pap.120703001453.755">Open a couple of files and then use a bare close to close them and check we close ok

&lt;&lt; File tests &gt;&gt;=

# Open with Input
tests.append((r"""
Close
_a = FreeFile
Open "%s" For Input As FreeFile
Open "%s" For Output As FreeFile
_b = FreeFile
Close
_c = FreeFile
a = _a = _b
b = _a = _c
c = _b = _c
d = CStr(_a) &amp; CStr(_b) &amp; CStr(_c) 
""" % (vb2py.utils.relativePath("test\\testread.txt"), 
	   vb2py.utils.relativePath("test\\testwrite.txt")),
{'a':0, 'b':1, 'c':0, 'd': '131',
}))

# Using Reset instead of Close
tests.append((r"""
Reset
_a = FreeFile
Open "%s" For Input As FreeFile
Open "%s" For Output As FreeFile
_b = FreeFile
Reset
_c = FreeFile
a = _a = _b
b = _a = _c
c = _b = _c
d = CStr(_a) &amp; CStr(_b) &amp; CStr(_c) 
""" % (vb2py.utils.relativePath("test\\testread.txt"), 
	   vb2py.utils.relativePath("test\\testwrite.txt")),
{'a':0, 'b':1, 'c':0, 'd': '131',
}))


# Bug #810968 Close #1, #2 ' fails to parse 
tests.append((r"""
Open "%s" For Input As #3
Open "%s" For Output As #4
Close #3, #4
Input #3, a
""" % (vb2py.utils.relativePath("test\\testread.txt"), 
	   vb2py.utils.relativePath("test\\testwrite.txt")),
{'FAIL' : 'yes',
}))

</t>
<t tx="pap.120703001453.756">Seek in a file

&lt;&lt; File tests &gt;&gt;=

# Seek as a way of moving around in a file
tests.append((r"""
Open "%s" For Input As #3
Input #3, a
Seek #3, 1
Input #3, b
Seek #3, 5
Input #3, c
""" % vb2py.utils.relativePath("test\\testread.txt"),
{
'a' : 'Can you hear me now?',
'b' : 'Can you hear me now?',
'c' : 'you hear me now?',
}))


# Seek as a property of the file
tests.append((r"""
Open "%s" For Input As #3
a = Seek(3)
Input #3, _a
b = Seek(3)
Seek #3, 5
c = Seek(3)
""" % vb2py.utils.relativePath("test\\testread.txt"),
{
'a' : 1,
'b' : 23,
'c' : 5,
}))</t>
<t tx="pap.120703001453.757">Return the directory of file matches - this is a weird function

&lt;&lt; File tests &gt;&gt;=

# Dir
tests.append((r"""
a = Dir("test\\test*.txt")
b = Dir()
c = Dir()
""",
{
'a' : 'testread.txt',
'b' : 'testwrite.txt',
'c' : '',
}))


# Dir$
tests.append((r"""
a = Dir$("test\\test*.txt")
b = Dir$()
c = Dir$()
""",
{
'a' : 'testread.txt',
'b' : 'testwrite.txt',
'c' : '',
}))

# Dir no parenthesis
tests.append((r"""
a = Dir("test\\test*.txt")
b = Dir
c = Dir
""",
{
'a' : 'testread.txt',
'b' : 'testwrite.txt',
'c' : '',
}))

# Dir$ no parenthesis
tests.append((r"""
a = Dir$("test\\test*.txt")
b = Dir$
c = Dir$
""",
{
'a' : 'testread.txt',
'b' : 'testwrite.txt',
'c' : '',
}))</t>
<t tx="pap.120703001453.758">Returns a new file 'handle'

&lt;&lt; File tests &gt;&gt;=

# Dir
tests.append((r"""
_a = FreeFile
Open "__f1.txt" For Output As #_a
_b = FreeFile
Open "__f2.txt" For Output As #_b
Close #_b
_c = FreeFile
Close #_a
_d = FreeFile
da = _b-_a
db = _c-_a
dd = _d-_a
""",
{
'da' : 1,
'db' : 1,
'dd' : 0,
}))


</t>
<t tx="pap.120703001453.759">Change the current directory

&lt;&lt; File tests &gt;&gt;=

# Dir
tests.append((r"""
ChDir "%s"
Open "_test1.txt" For Output As #3
Print #3, "in testdir"
Close #3
ChDir "%s"
Open "_test1.txt" For Output As #3
Print #3, "not in testdir"
Close #3
ChDir "%s"
Open "_test1.txt" For Input As #3
Input #3, a
Close #3
ChDir "%s"
Open "_test1.txt" For Input As #3
Input #3, b
Close #3
""" % (vb2py.utils.relativePath("test\\testdir"),
       vb2py.utils.relativePath("test"),
	   vb2py.utils.relativePath("test\\testdir"),
       vb2py.utils.relativePath("test")),
{
'a' : 'in testdir',
'b' : 'not in testdir',
}))


</t>
<t tx="pap.120703001453.760">Remove a file

&lt;&lt; File tests &gt;&gt;=

# Dir
tests.append((r"""
Open "_test1.txt" For Output As #3
Print #3, "made file"
Close #3
Kill "_test1.txt"
a = Dir("_test1.txt")
""",
{
'a' : '',
}))


</t>
<t tx="pap.120703001453.761">Make a directory

&lt;&lt; File tests &gt;&gt;=

try:
	for name in os.listdir(vb2py.utils.relativePath("test\\mytest2")):
		os.remove(os.path.join(vb2py.utils.relativePath("test\\mytest2"), name))
except OSError:
	pass

try:
	os.rmdir(vb2py.utils.relativePath("test\\mytest2"))
except OSError, err:
	pass

# Dir
tests.append((r"""
MkDir "%s"
Open "%s\test1.txt" For Output As #3
Print #3, "made file"
Close #3
a = 1
""" % (vb2py.utils.relativePath("test\\mytest2"),
       vb2py.utils.relativePath("test\\mytest2")),
{
'a' : 1,
}))


</t>
<t tx="pap.120703001453.762">Remove a directory

&lt;&lt; File tests &gt;&gt;=

try:
	for name in os.listdir(vb2py.utils.relativePath("test\\mytestdir")):
		os.remove(os.path.join(vb2py.utils.relativePath("test\\mytestdir"), name))
except OSError:
	pass

try:
	os.rmdir(vb2py.utils.relativePath("test\\mytestdir"))
except OSError:
	pass

# Dir
tests.append((r"""
MkDir "%s"
RmDir "%s"
a = 0
""" % (vb2py.utils.relativePath("test\\mytestdir"),
       vb2py.utils.relativePath("test\\mytestdir")),
{
'a' : os.path.isdir(vb2py.utils.relativePath("test\\mytestdir")),
}))


</t>
<t tx="pap.120703001453.763">Rename a file

&lt;&lt; File tests &gt;&gt;=

try:
	os.remove(os.path.join(vb2py.utils.relativePath("test"), "knewname.txt"))
except OSError:
	pass
	
# Dir
tests.append((r"""
_path = "%s"
Open _path &amp; "\origname.txt" For Output As #3
Close #3
a = Dir(_path &amp; "\origname.txt")
Name _path &amp; "\origname.txt" As _path &amp; "\knewname.txt"
b = Dir(_path &amp; "\origname.txt")
c = Dir(_path &amp; "\knewname.txt")
""" % (vb2py.utils.relativePath("test")),
{
'a' : "origname.txt",
'b' : "",
'c' : "knewname.txt",
}))



</t>
<t tx="pap.120703001453.764">Copy a file

&lt;&lt; File tests &gt;&gt;=

try:
	os.remove(os.path.join(vb2py.utils.relativePath("test"), "finalcopy.txt"))
except OSError:
	pass
	
# Dir
tests.append((r"""
_path = "%s"
Open _path &amp; "\origcopy.txt" For Output As #3
Print #3, "original"
Close #3
a = Dir(_path &amp; "\origcopy.txt")
b = Dir(_path &amp; "\finalcopy.txt")
FileCopy _path &amp; "\origcopy.txt", _path &amp; "\finalcopy.txt"
c = Dir(_path &amp; "\origcopy.txt")
d = Dir(_path &amp; "\finalcopy.txt")
""" % (vb2py.utils.relativePath("test")),
{
'a' : "origcopy.txt",
'b' : "",
'c' : "origcopy.txt",
'd' : "finalcopy.txt",
}))



</t>
<t tx="pap.120703001453.765">@root test\testwith.py

from unittest import *
from testframework import *

&lt;&lt; With tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.766">&lt;&lt; With tests &gt;&gt;=

# Simple test
tests.append(("""
Set _a = New Collection
With _a
	b = .Count()
End With
""", {"b" : 0}))

# Nested test
tests.append(("""
Dim _a As New Collection, _b As New Collection
_a.Add 24
_a.Add 25
_b.Add 1
With _a
	aa = .Count()
	With _b
		bb = .Count()
	End With
End With
""", {"aa" : 2, "bb" : 1}))

# Nested test with LHS implicit objects
tests.append(("""
Dim _a As New Collection, _b As New Collection
With _a
	.Add 24
	.Add 25
	aa = .Count()
	With _b
		.Add 1
		bb = .Count()
	End With
End With
""", {"aa" : 2, "bb" : 1}))

# Nested test with LHS implicit objects 2
tests.append(("""
Dim _a As New Collection, _b As New Collection
With _a
	.Add 24
	.Add 25
	With _b
		.Add 1
		bb = .Count()
	End With
	aa = .Count()
End With
""", {"aa" : 2, "bb" : 1}))</t>
<t tx="pap.120703001453.767">&lt;&lt; With tests &gt;&gt;=

# Tricky little nesting problem
tests.append(("""
Type _Container3
   Value As Integer
End Type

Type _Container2
   Value As Integer
   Obj As _Container3
End Type

Type _Container1
   Value As Integer
   Obj As _Container2
End Type


Dim _a As _Container1
Dim _b As _Container2
Dim _c As _Container3

Set _a.Obj = _b
Set _b.Obj = _c
_c.Value = 10

With _a
	With .Obj ' ie _b
	   With .Obj ' ie _c
	   	    val = .Value
	   End With 
	End With
End With
""", {"val" : 10}))
</t>
<t tx="pap.120703001453.768">@root test\testenum.py

from unittest import *
from testframework import *

&lt;&lt; Enum tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.769">&lt;&lt; Enum tests &gt;&gt;=

# Simple test
tests.append(("""
Enum thing
    _one
    _two
    _three
    _four
End Enum

a = _one
b = _two
c = _three
d = _four
""", {"a":0, "b":1, "c":2, "d":3}))


# Simple test with values
tests.append(("""
Enum thing
    _one = 1
    _two = 2
    _three = 3
    _four = 4
End Enum

a = _one
b = _two
c = _three
d = _four
""", {"a":1, "b":2, "c":3, "d":4}))

</t>
<t tx="pap.120703001453.770">@root test\testrandom.py

from unittest import *
from testframework import *

&lt;&lt; Random tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.771">&lt;&lt; Random tests &gt;&gt;=

# Rnd produces different numbers
tests.append(("""
_a = Rnd
_b = Rnd
_c = Rnd
a = _a = _b
b = _b = _c
""", {"a":0, "b":0}))


# Rnd with 0 produces the last value
tests.append(("""
_a = Rnd
_b = Rnd(0)
_c = Rnd
a = _a = _b
b = _b = _c
""", {"a":1, "b":0}))

# Rnd with -ve produces consistent sequence
tests.append(("""
_a1 = Rnd(-100)
_b1 = Rnd
_c1 = Rnd
_a2 = Rnd(-100)
_b2 = Rnd
_c2 = Rnd
a = _a1 = _a1
b = _b1 = _b1
c = _c1 = _c1
""", {"a":1, "b":1, "c":1}))


# Randomize breaks a sequence
tests.append(("""
_a1 = Rnd(-100)
_b1 = Rnd
_c1 = Rnd
_a2 = Rnd(-100)
Randomize
_b2 = Rnd
_c2 = Rnd
a = _a1 = _a2
b = _b1 = _b2
c = _c1 = _c2
""", {"a":1, "b":0, "c":0}))

# Randomize breaks a sequence
tests.append(("""
_a1 = Rnd(-100)
_b1 = Rnd
_c1 = Rnd
_a2 = Rnd(-100)
Randomize 25
_b2 = Rnd
_c2 = Rnd
a = _a1 = _a2
b = _b1 = _b2
c = _c1 = _c2
""", {"a":1, "b":0, "c":0}))
</t>
<t tx="pap.120703001453.772">@root test\testconst.py

from unittest import *
from testframework import *

&lt;&lt; Const tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.773">&lt;&lt; Const tests &gt;&gt;=

# Simple test
tests.append(("""
Const a = 10
Const b = 20
Const c = "hello"
""", {"a":10, "b":20, "c":"hello"}))

# Simple test woth scope
tests.append(("""
Private Const a = 10
Private Const b = 20
Private Const c = "hello"
""", {"a":10, "b":20, "c":"hello"}))

tests.append(("""
Public Const a = 10
Public Const b = 20
Public Const c = "hello"
""", {"a":10, "b":20, "c":"hello"}))

# Simple test with hex numbers
tests.append(("""
Const a = &amp;HFF
Const b = &amp;HA
""", {"a":255, "b":10, }))

# Three on a line
tests.append(("""
Const _a = "one", _b = "two", _c = "three"
d = _a &amp; _b &amp; _c
""", {"d" : "onetwothree"}))
</t>
<t tx="pap.120703001453.774">@root test\testsettings.py

from unittest import *
from testframework import *

&lt;&lt; Settings tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.775">&lt;&lt; Settings tests &gt;&gt;=

# Simple test of get with default
tests.append(("""
a = GetSetting("vbtest", "main", "key", "&lt;default&gt;")
""", {"a":"&lt;default&gt;"}))
tests.append(("""
a = GetSetting("vbtestother", "main", "key", "&lt;default&gt;")
""", {"a":"&lt;default&gt;"}))

# Simple test of set then get 
tests.append(("""
SaveSetting "vbtest", "main", "real", 10.5
SaveSetting "vbtest", "main", "int", 1
SaveSetting "vbtest", "main", "string", "hello"
a = GetSetting("vbtest", "main", "real")
b = GetSetting("vbtest", "main", "int")
c = GetSetting("vbtest", "main", "string")
""", {"a":"10.5", "b":"1", "c":"hello"})) # always returned as a string

# Simple test of set then get with default
tests.append(("""
SaveSetting "vbtest", "main", "real", 10.5
SaveSetting "vbtest", "main", "int", 1
SaveSetting "vbtest", "main", "string", "hello"
a = GetSetting("vbtest", "main", "real", "mmm")
b = GetSetting("vbtest", "main", "int", "mmm")
c = GetSetting("vbtest", "main", "string", "mmm")
""", {"a":"10.5", "b":"1", "c":"hello"})) # always returned as a string

</t>
<t tx="pap.120703001453.776">&lt;&lt; Settings tests &gt;&gt;=


# Simple test of set then getall 
tests.append(("""
SaveSetting "vbtest", "main", "real", 10.5
SaveSetting "vbtest", "main", "int", 1
SaveSetting "vbtest", "main", "string", "hello"
Dim _Setting, _Settings
a=""
_Settings = GetAllSettings("vbtest", "main")
For _Setting = 0 To UBound(_Settings)
    a = a &amp; _Settings(_Setting, 0) &amp; " = " &amp; _Settings(_Setting, 1) &amp; ":"
Next _Setting

""", {"a":"real = 10.5:string = hello:int = 1:"})) # always returned as a string

</t>
<t tx="pap.120703001453.777">&lt;&lt; Settings tests &gt;&gt;=

# Simple test of delete
tests.append(("""
a = GetSetting("vbtest", "second", "key", "&lt;default&gt;")
SaveSetting "vbtest", "second", "key", "hello"
b = GetSetting("vbtest", "second", "key", "&lt;default&gt;")
DeleteSetting "vbtest", "second", "key"
c = GetSetting("vbtest", "second", "key", "&lt;default&gt;")
""", {"a":"&lt;default&gt;", "b":"hello", "c":"&lt;default&gt;"}))

</t>
<t tx="pap.120703001453.778">@root test\testerase.py

from unittest import *
from testframework import *

&lt;&lt; Erase tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.779">&lt;&lt; Erase tests &gt;&gt;=

# Simple test of erase
tests.append(("""
Function _GetArrayRepr(Arr)
total = 0
For i = 1 To UBound(Arr, 1)
    For j = 1 To UBound(Arr, 2)
       total = total + Arr(i, j)
    Next j
Next i
_GetArrayRepr = total
End Function

Dim _a(10, 2) As Integer
For _i = 1 To 10
    For _j = 1 To 2
        _a(_i, _j) = _i + _j
    Next _j
Next _i
t1 = _GetArrayRepr(_a)
Erase _a
t2 = _GetArrayRepr(_a)
""", {"t1" : 140, "t2" : 0}))

# Simple test of erase with two arrays
tests.append(("""
Function _GetArrayRepr(Arr)
total = 0
For i = 1 To UBound(Arr, 1)
    For j = 1 To UBound(Arr, 2)
       total = total + Arr(i, j)
    Next j
Next i
_GetArrayRepr = total
End Function

Dim _a(10, 2) As Integer
Dim _b(10, 2) As Integer
For _i = 1 To 10
    For _j = 1 To 2
        _a(_i, _j) = _i + _j
        _b(_i, _j) = _i + _j
    Next _j
Next _i
t1a = _GetArrayRepr(_a)
t1b = _GetArrayRepr(_b)
Erase _a, _b
t2a = _GetArrayRepr(_a)
t2b = _GetArrayRepr(_b)
""", {"t1a" : 140, "t2a" : 0, "t1b" : 140, "t2b" : 0}))
</t>
<t tx="pap.120703001453.780">@root test\testexternal.py

from unittest import *
from testframework import *

&lt;&lt; External tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.781">&lt;&lt; External tests &gt;&gt;=

# Simple test
tests.append(("""
Dim _a As Object
Set _a = CreateObject("Excel.Application")
b = _a.Name
""", {"b":"Microsoft Excel"}))

</t>
<t tx="pap.120703001453.782">@root test\testfailures.py

"""Tests that we know fail but are not within the scope of v0.2"""


from unittest import *
from testframework import *

&lt;&lt; Failing tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.783">&lt;&lt; Failing tests &gt;&gt;=

# Simple function with ByRef argument which is changed
tests.append(("""
Function _square(x, y)
	_square = x*x
	y = y + 1
End Function
b = 0
a = _square(10, b)
""", {"a" : 100, "b" : 1}))
</t>
<t tx="pap.120703001453.784">&lt;&lt; Failing tests &gt;&gt;=

# Optional arguments
tests.append(("""
Sub _Change(ByVal x, ByRef y)
	x = x + 1
	y = y + 1
End Sub
a = 0
b = 0
_Change a, b
""", {"a" : 0, "b" : 1}))
</t>
<t tx="pap.120703001453.785"></t>
<t tx="pap.120703001453.786">@root test\complexframework.py

#
# Turn off logging in extensions (too loud!)
import vb2py.extensions
vb2py.extensions.disableLogging()

from unittest import *
from vb2py.vbparser import convertVBtoPython, VBClassModule, VBModule, VBFormModule, VBCodeModule
import vb2py.vbfunctions as vbfunctions
import vb2py.vbfunctions

tests = []

def BasicTest():
	"""Return a new class - we do it this way to allow this to work properly for multiple tests"""
	class _BasicTest(TestCase):
		"""Holder class which gets built into a whole test case"""
	return _BasicTest
	
	
def getTestMethod(container, vb, assertions):
	"""Create a test method"""
	def testMethod(self):
		local_dict = {"convertVBtoPython" : convertVBtoPython,
					  "vbfunctions" : vbfunctions}
		&lt;&lt; Parse VB &gt;&gt;
		&lt;&lt; Execute the Python code &gt;&gt;
		&lt;&lt; Check assertions &gt;&gt;
        #print vb, "\n\n", python, "\n\n--------------------------------"
		#
		self.assert_(reason == "", "Failed: %s\n%s\n\n%s" % (reason, vb, python))
		
	return testMethod
	
#
# Add tests to main test class
def addTestsTo(TestClassFactory, tests):
	"""Add all the tests to the test class"""
	TestClass = TestClassFactory()
	for idx in range(len(tests)):
		setattr(TestClass, "test%d" % idx, getTestMethod(*tests[idx]))
	return TestClass
</t>
<t tx="pap.120703001453.787">@c

try:					  
	python = convertVBtoPython(vb, container=container)
except Exception, err:
	self.fail("Error while parsing (%s)\n%s" % (err, vb))
</t>
<t tx="pap.120703001453.788">@c

try:
	exec "from vb2py.vbfunctions import *" in local_dict
	exec python in local_dict
except Exception, err:
    self.fail("Error (%s):\n%s\n....\n%s" % (err, vb, python))
</t>
<t tx="pap.120703001453.789">@doc
Go through each assertion (a Python statement) to see if it holds
@c

reason = ""

internal_dict = {"python" : python, "vb" : vb}

for assertion in assertions:
    if assertion.startswith("$"):
        dct = internal_dict
        assertion = assertion[1:]
    else:
        dct = local_dict
    try:
	    exec assertion in dct
    except Exception, err:
        reason += "%s (%s)\n" % (Exception, err)

</t>
<t tx="pap.120703001453.790">@root test\testclassmethods.py

from unittest import *
from complexframework import *


&lt;&lt; ClassMethod tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.791">&lt;&lt; ClassMethod tests &gt;&gt;=

#
# Simple public method
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        """,
        ("A = MyClass()\n"
         "A.SetA('hello')\n"
         "assert A.my_a == 'hello', 'A.my_a was (%s)' % (A.my_a,)\n",)
))         

#
# Simple public method with a local variable shadowing a class variable
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public my_b As String
        
        Public Sub SetA(Value As Integer)
            Dim my_b
            my_b = "other"
            my_a = Value + my_b
        End Sub
        
        Public Sub SetB(Value As Integer)
            my_b = Value
        End Sub
        """,
        ("A = MyClass()\n"
         "A.SetB('thisisb')\n"
         "A.SetA('thisisa')\n"
         "assert A.my_a == 'thisisaother', 'A.my_a was (%s)' % (A.my_a,)\n"
         "assert A.my_b == 'thisisb', 'A.my_b was (%s)' % (A.my_b,)\n",)
))         

#
# Simple public method calling another method
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public my_b As String
        
        Public Sub SetA(Value As Integer)
            SetB Value
            my_a = my_b
        End Sub
        
        Public Sub SetB(Value As Integer)
            my_b = Value
        End Sub
        """,
        ("A = MyClass()\n"
         "A.SetA('thisisa')\n"
         "assert A.my_a == 'thisisa', 'A.my_a was (%s)' % (A.my_a,)\n"
         "assert A.my_b == 'thisisa', 'A.my_b was (%s)' % (A.my_b,)\n",)
))         


#
# Simple public method with a parameter shadowing a class variable
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public my_b As String
        
        Public Sub SetA(my_b As Integer)
            my_a = my_b
        End Sub
        
        Public Sub SetB(Value As Integer)
            my_b = Value
        End Sub
        """,
        ("A = MyClass()\n"
         "A.SetB('thisisb')\n"
         "A.SetA('thisisa')\n"
         "assert A.my_a == 'thisisa', 'A.my_a was (%s)' % (A.my_a,)\n"
         "assert A.my_b == 'thisisb', 'A.my_b was (%s)' % (A.my_b,)\n",)
))         
</t>
<t tx="pap.120703001453.792">&lt;&lt; ClassMethod tests &gt;&gt;=

#
# Simple public function
tests.append((
        VBClassModule(),
        """
        Public lower_bound As Integer
        
        Public Sub setLowerBound(Value As Integer)
            lower_bound = Value
        End Sub
        
        Public Function Factorial(Value As Integer)
            If Value = lower_bound Then
                Factorial = 1
            Else
                Factorial = Value * Factorial(Value-1)
            End If
        End Function
        """,
        ("A = MyClass()\n"
         "A.setLowerBound(1)\n"
         "assert A.Factorial(6) == 720, 'A.Factorial(6) was (%s)' % (A.Factorial(6),)\n",)
))         
</t>
<t tx="pap.120703001453.793">&lt;&lt; ClassMethod tests &gt;&gt;=

#
# Simple private method
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Private Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        """,
        ("A = MyClass()\n"
         "try:\n"
         "  A.SetA('hello')\n"
         "except AttributeError:\n"
         "  pass\n"
         "else:\n"
         "  assert 0, 'Method should be private'\n",)
))         

</t>
<t tx="pap.120703001453.794">&lt;&lt; ClassMethod tests &gt;&gt;=

#
# Simple init method called automatically
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Public Sub Class_Initialize()
            my_a = "hello"
        End Sub
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        """,
        ("A = MyClass()\n"
         "assert A.my_a == 'hello', 'A.my_a was (%s)' % (A.my_a,)\n"
         "A.SetA('bye')\n"
         "assert A.my_a == 'bye', 'A.my_a was (%s)' % (A.my_a,)\n",)
))         


#
# Explicitely calling the init method
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Public Sub Class_Initialize()
            my_a = "hello"
        End Sub
        
        Public Sub ReInit()
            Class_Initialize
        End Sub
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        
        """,
        ("A = MyClass()\n"
         "A.SetA('bye')\n"
         "A.ReInit()\n"
         "assert A.my_a == 'hello', 'A.my_a was (%s)' % (A.my_a,)\n",)
))         

#
# Explicitely calling the terminate method
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Public Sub Class_Terminate()
            my_a = "hello"
        End Sub
        
        Public Sub Reset()
            Class_Terminate
        End Sub
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        
        """,
        ("A = MyClass()\n"
         "A.SetA('bye')\n"
         "A.Reset()\n"
         "assert A.my_a == 'hello', 'A.my_a was (%s)' % (A.my_a,)\n",)
))         


#
# init method is private
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Sub Class_Initialize()
            my_a = "hello"
        End Sub
        
        Public Sub ReInit()
            Class_Initialize
        End Sub
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        
        """,
        ("A = MyClass()\n"
         "A.SetA('bye')\n"
         "A.ReInit()\n"
         "assert A.my_a == 'hello', 'A.my_a was (%s)' % (A.my_a,)\n",)
))         


#
# Terminate method is private
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Sub Class_Terminate()
            my_a = "hello"
        End Sub
        
        Public Sub Reset()
            Class_Terminate
        End Sub
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        
        """,
        ("A = MyClass()\n"
         "A.SetA('bye')\n"
         "A.Reset()\n"
         "assert A.my_a == 'hello', 'A.my_a was (%s)' % (A.my_a,)\n",)
))         

tests.append((
        VBClassModule(),
        """
        Public my_a As String
        
        Sub Class_Terminate()
            'my_a = 1/0
        End Sub
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        
        """,
        ("$assert python.find('def __del__(self') &lt;&gt; -1, '__del__ method not created'", )
))         </t>
<t tx="pap.120703001453.795">&lt;&lt; ClassMethod tests &gt;&gt;=

#
# Class properties
tests.append((
        VBClassModule(),
        """
        Public arr()
        
        Public Sub DoIt(Value As Integer)
            ReDim arr(Value)
        End Sub
        """,
        ("A = MyClass()\n"
		 "B = MyClass()\n"
		 "A.DoIt(10)\n"
		 "B.DoIt(20)\n"
         "assert len(A.arr) == 11, 'len(A.arr) was (%s)' % (len(A.arr),)\n"
		 "assert len(B.arr) == 21, 'len(B.arr) was (%s)' % (len(B.arr),)\n",)
))         

#
# Make sure class properties are not shared
tests.append((
        VBClassModule(),
        """
        Public arr(20)
        
        Public Sub DoIt(Value As Integer)
            arr(10) = Value
        End Sub
        """,
        ("A = MyClass()\n"
		 "B = MyClass()\n"
		 "A.DoIt(10)\n"
		 "B.DoIt(20)\n"
         "assert A.arr[10] == 10, 'A.arr[10] was (%s)' % (A.arr[10],)\n"
		 "assert B.arr[10] == 20, 'B.arr[10] was (%s)' % (B.arr[10],)\n",)
))         
</t>
<t tx="pap.120703001453.796">&lt;&lt; ClassMethod tests &gt;&gt;=

#
# Me in an expression
tests.append((
        VBClassModule(),
        """
        Public Val
        
        Public Sub DoIt(Value As Integer)
            Me.Val = Value
        End Sub
        """,
        ("A = MyClass()\n"
		 "A.DoIt(10)\n"
		 "assert A.Val==10, 'A.Val was (%s)' % (A.Val,)\n",)
))         


#
# Me in a call
tests.append((
        VBClassModule(),
        """
        Public Val
        
        Public Sub DoIt(Value As Integer)
            Val = Value
			Me.AddOne
        End Sub
		
		Public Sub AddOne()
		    Val = Val + 1
		End Sub
		
        """,
        ("A = MyClass()\n"
		 "A.DoIt(10)\n"
		 "assert A.Val==11, 'A.Val was (%s)' % (A.Val,)\n",)
))         

</t>
<t tx="pap.120703001453.797">@root test\testcodemodules.py

from unittest import *
from complexframework import *


&lt;&lt; CodeModule tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.798">&lt;&lt; CodeModule tests &gt;&gt;=

#
# Module level variables should be global (in the Python sense of the word)
tests.append((
        VBCodeModule(),
        """
        Public my_a As String
        
        Public Sub SetA(Value As Integer)
            my_a = Value
        End Sub
        Public Function GetA()
            GetA = my_a
        End Function
        """,
        ("SetA('hello')\n"
         "assert GetA() == 'hello', 'GetA was (%s)' % (GetA(),)\n",)
))         </t>
<t tx="pap.120703001453.799">@root test\testproperties.py

from unittest import *
from complexframework import *

&lt;&lt; Property tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.800">&lt;&lt; Property tests &gt;&gt;=

#
# Simple property Let and Get
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public Property Let a(newval As Variant)
            my_a = newval &amp; "_ending"
        End Property
        
        Public Property Get a() As Variant
            a = my_a
        End Property
        """,
        ("A = MyClass()\n"
         "A.a = 'hello'\n"
         "assert A.a == 'hello_ending', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Simple property Get and Set
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public Property Set a(newval As Variant)
            my_a = newval &amp; "_ending"
        End Property
        
        Public Property Get a() As Variant
            a = my_a
        End Property
        """,
        ("A = MyClass()\n"
         "A.a = 'hello'\n"
         "assert A.a == 'hello_ending', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Simple property Get
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public Property Get a()
            a = "itworks"
        End Property
        """,
        ("A = MyClass()\n"
         "assert A.a == 'itworks', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Simple property Let
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public Property Let a(newval)
            my_a = newval
        End Property
        """,
        ("A = MyClass()\n"
         "A.a = 'hello'\n"
         "assert A.my_a == 'hello', 'A.my_a was (%s)' % (A.my_a,)\n",)
))         </t>
<t tx="pap.120703001453.801">&lt;&lt; Property tests &gt;&gt;=

#
# Multiple properties with internal access
tests.append((
        VBClassModule(),
        """
        Public my_a As String, my_b As String

        Public Property Let a(newval As Variant)
            my_a = newval &amp; "_a"
        End Property
        
        Public Property Get a() As Variant
            a = my_a
        End Property


        Public Property Let b(newval As Variant)
            my_b = newval &amp; a
        End Property
        
        Public Property Get b() As Variant
            b = my_b
        End Property
        """,
        ("A = MyClass()\n"
         "A.a = 'hello'\n"
         "A.b = 'there'\n"
         "assert A.a == 'hello_a', 'A.a was (%s)' % (A.a,)\n"
         "assert A.b == 'therehello_a', 'A.b was (%s)' % (A.b,)\n",)
))         
</t>
<t tx="pap.120703001453.802">&lt;&lt; Property tests &gt;&gt;=

#
# Property set with an exit (this failed once)
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public Property Let a(newval As Variant)
            my_a = newval &amp; "_ending"
			Exit Property
        End Property
        
        Public Property Get a() As Variant
            a = my_a
        End Property
        """,
        ("A = MyClass()\n"
         "A.a = 'hello'\n"
         "assert A.a == 'hello_ending', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Property get with an exit (this failed once)
tests.append((
        VBClassModule(),
        """
        Public my_a As String
        Public Property Set a(newval As Variant)
            my_a = newval &amp; "_ending"
        End Property
        
        Public Property Get a() As Variant
            a = my_a
			Exit Property
        End Property
        """,
        ("A = MyClass()\n"
         "A.a = 'hello'\n"
         "assert A.a == 'hello_ending', 'A.a was (%s)' % (A.a,)\n",)
))         
</t>
<t tx="pap.120703001453.803">@root test\testprivate.py

from unittest import *
from complexframework import *

&lt;&lt; Private tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff
TestClass = addTestsTo(BasicTest, tests)

if __name__ == "__main__":
	main()
</t>
<t tx="pap.120703001453.804">&lt;&lt; Private tests &gt;&gt;=

#
# Simple private data is available from inside class
tests.append((
        VBClassModule(),
        """
        Private a As String
        
        Public Sub SetA(Value)
            a = Value
        End Sub
        
        Public Function GetA()
           GetA = a
        End Function
        
        """,
        ("A = MyClass()\n"
         "A.SetA('hello')\n"
         "assert A.GetA() == 'hello', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Simple private data is not available from outside class
tests.append((
        VBClassModule(),
        """
        Private a As String
        
        Public Sub SetA(Value)
            a = Value
        End Sub
        
        Public Function GetA()
           GetA = a
        End Function
        
        """,
        ("A = MyClass()\n"
         "A.SetA('hello')\n"
         "assert hasattr(A, 'a') == 0, 'Could see attribute a'\n",)
))         

#
# Simple private constant data
tests.append((
        VBClassModule(),
        """
        Private Const b = 10
        Private a
		
        Public Sub SetA()
            a = b
        End Sub
        
        Public Function GetA()
           GetA = a
        End Function
        
        """,
        ("A = MyClass()\n"
         "A.SetA()\n"
         "assert hasattr(A, 'a') == 0, 'Could see attribute a'\n"
		 "assert A.GetA() == 10",)
)) 
</t>
<t tx="pap.120703001453.805">&lt;&lt; Private tests &gt;&gt;=

#
# Private sub is available from inside class
tests.append((
        VBClassModule(),
        """
        Private a As String
        
        Public Sub SetA(Value)
            DoIt Value
        End Sub
        
        Private Sub DoIt(Value)
            a = Value
        End Sub
        
        Public Function GetA()
           GetA = a
        End Function
        
        """,
        ("A = MyClass()\n"
         "A.SetA('hello')\n"
         "assert A.GetA() == 'hello', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Simple private sub is not available from outside class
tests.append((
        VBClassModule(),
        """
        Private a As String
        
        Private Sub DoIt(Value)
            a = Value
        End Sub
        
        """,
        ("A = MyClass()\n"
         "assert hasattr(A, 'DoIt') == 0, 'Could see attribute DoIt'\n",)
))         


</t>
<t tx="pap.120703001453.806">&lt;&lt; Private tests &gt;&gt;=

#
# Private fn is available from inside class
tests.append((
        VBClassModule(),
        """
        Private a As String
        
        Public Sub SetA(Value)
            a = Value
        End Sub
        
        Private Function GetIt()
            GetIt = a
        End Function
        
        Public Function GetA()
           GetA = GetIt()
        End Function
        
        """,
        ("A = MyClass()\n"
         "A.SetA('hello')\n"
         "assert A.GetA() == 'hello', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Simple private fn is not available from outside class
tests.append((
        VBClassModule(),
        """
        Private a As String
        
        Private Function GetIt()
            GetIt = a
        End Function
        
        """,
        ("A = MyClass()\n"
         "assert hasattr(A, 'GetIt') == 0, 'Could see attribute GetIt'\n",)
))         

</t>
<t tx="pap.120703001453.807">&lt;&lt; Private tests &gt;&gt;=

#
# Private property is available from inside class
tests.append((
        VBClassModule(),
        """
        Private ma As String
        
        Private Property Let a(Value)
            ma = Value
        End Property
        
        Private Property Get a()
            a = ma
        End Property
        
        Public Function GetA()
           GetA = a
        End Function
        
        Public Sub SetA(Value)
          a = Value
        End Sub
        
        """,
        ("A = MyClass()\n"
         "A.SetA('hello')\n"
         "assert A.GetA() == 'hello', 'A.a was (%s)' % (A.a,)\n",)
))         

#
# Simple private fn is not available from outside class
tests.append((
        VBClassModule(),
        """
        Private ma As String
        
        Private Property Let a(Value)
            ma = Value
        End Property
        
        Private Property Get a()
            a = ma
        End Property
        
        """,
        ("A = MyClass()\n"
         "assert hasattr(A, 'a') == 0, 'Could see attribute a'\n",)
))         

</t>
<t tx="pap.120703001453.808">@root test\testglobals.py

from unittest import *
import vb2py.vbparser

class TestGlobals(TestCase):
    &lt;&lt; Globals tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff

if __name__ == "__main__":
	main()</t>
<t tx="pap.120703001453.809">&lt;&lt; Globals tests &gt;&gt;=

def setUp(self):
    """Set up our tests"""
    self.proj = vb2py.vbparser.VBProject()
    self.utils = vb2py.vbparser.VBCodeModule(modulename="utils")
    self.base = vb2py.vbparser.VBCodeModule(modulename="base")
    self.cls = vb2py.vbparser.VBClassModule(modulename="cls", classname="Cls")
    #
    self.utils.parent = self.base.parent = self.cls.parent = self.proj        
    #
    self.utils = vb2py.vbparser.parseVB("""
    Public x, y, z
    Private one, two, three
    
    Public Function Fact(x)
        Fact=1
    End Function
    """, container=self.utils)
    #
    self.base = vb2py.vbparser.parseVB("""
    Public a, b, c
    Private four, five, six
    
    Public Sub DoIt(a, b, x, y, h)
        x = 1
        y = 1
    End Sub
    """, container=self.base)
    #

</t>
<t tx="pap.120703001453.810">&lt;&lt; Globals tests &gt;&gt;=

def testSimpleOneLookup(self):
    """testSimpleOneLookup: simple lookup of globals from one location"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        m = x
        n = y
        o = z
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.x", "utils.y", "utils.z"):
        self.assertNotEqual(python.find(converted), -1, python)

def testSimpleTwoLookups(self):
    """testSimpleTwoLookups: simple lookup of globals from two locations"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        a = x
        b = y
        c = z
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.x", "utils.y", "utils.z",
                      "base.a", "base.b", "base.c"):
        self.assertNotEqual(python.find(converted), -1, python)        </t>
<t tx="pap.120703001453.811">&lt;&lt; Globals tests &gt;&gt;=

def testSimpleNoLookup(self):
    """testSimpleNoLookup: don't lookup private variables"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        one = two
        three = four
        five = six
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in (".one", ".two", ".three", ".four", ".five", ".six"):
        self.assertEqual(python.find(converted), -1, python)

</t>
<t tx="pap.120703001453.812">&lt;&lt; Globals tests &gt;&gt;=

def testLocalsShadowGlobals(self):
    """testLocalsShadowGlobals: locals will shadow globals"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        Dim a, b, x, y
        a = x
        b = y
        c = z
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.z", "base.c"):
        self.assertNotEqual(python.find(converted), -1, python)
    for converted in ("utils.x", "utils.y", "base.a", "base.b"):
        self.assertEqual(python.find(converted), -1, python)

def testModuleLocalsShadowGlobals(self):
    """testModuleLocalsShadowGlobals: module locals will shadow globals"""
    py = vb2py.vbparser.parseVB("""
    Dim a, b, x, y

    Sub Run()
        a = x
        b = y
        c = z
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.z", "base.c"):
        self.assertNotEqual(python.find(converted), -1, python)
    for converted in ("utils.x", "utils.y", "base.a", "base.b"):
        self.assertEqual(python.find(converted), -1, python)

def testModuleDefsShadowGlobals(self):
    """testModuleDefsShadowGlobals: module definitions will shadow globals"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        a = x
        b = y
        c = z
    End Sub
    
    Function a()
    End Function
    Function b()
    End Function
    Function x()
    End Function
    Function y()
    End Function
    
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.z", "base.c"):
        self.assertNotEqual(python.find(converted), -1, python)
    for converted in ("utils.x", "utils.y", "base.a", "base.b"):
        self.assertEqual(python.find(converted), -1, python)

</t>
<t tx="pap.120703001453.813">&lt;&lt; Globals tests &gt;&gt;=

def testParametersShadowGlobals(self):
    """testParametersShadowGlobals: parameters will shadow globals"""
    py = vb2py.vbparser.parseVB("""
    Sub Run(a, b, x, y)
        a = x
        b = y
        c = z
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.z", "base.c"):
        self.assertNotEqual(python.find(converted), -1, python)
    for converted in ("utils.x", "utils.y", "base.a", "base.b"):
        self.assertEqual(python.find(converted), -1, python)

</t>
<t tx="pap.120703001453.814">&lt;&lt; Globals tests &gt;&gt;=

def testPropertyShadowGlobals(self):
    """testPropertyShadowGlobals: properties will shadow globals"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        a = x
        b = y
        c = z
    End Sub
    
    Property Get a()
    End Property
    Property Get b()
    End Property
    Property Get x()
    End Property
    Property Get y()
    End Property
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.z", "base.c"):
        self.assertNotEqual(python.find(converted), -1, python)
    for converted in ("utils.x", "utils.y", "base.a", "base.b"):
        self.assertEqual(python.find(converted), -1, python)

</t>
<t tx="pap.120703001453.815">&lt;&lt; Globals tests &gt;&gt;=

def testSubGlobals(self):
    """testSubGlobals: lookup of a global subroutine"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        DoIt
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("base.DoIt()",):
        self.assertNotEqual(python.find(converted), -1, python)

def testFnGlobals(self):
    """testFnGlobals: lookup of a global function"""
    py = vb2py.vbparser.parseVB("""
    Sub Run()
        a = Fact(10)
    End Sub
    """, container=self.cls)
    #
    python = py.renderAsCode()
    #
    for converted in ("utils.Fact(10)",):
        self.assertNotEqual(python.find(converted), -1, python)
</t>
<t tx="pap.120703001453.816">&lt;&lt; Globals tests &gt;&gt;=

def testGlobalButLocalHere(self):
    """testGlobalButLocalHere: lookup of a global which happens to be local here"""
    mymod = vb2py.vbparser.VBCodeModule(modulename="this")
    mymod.parent = self.proj
    py = vb2py.vbparser.parseVB("""
    Public myval
    Sub Run()
        a=myval
    End Sub
    """, container=mymod)
    #
    python = py.renderAsCode()
    #
    for converted in ("this.myval",):
        self.assertEqual(python.find(converted), -1, python)
		
def testGlobalButLocalHereNoNeedForGlobal(self):
    """testGlobalButLocalHereNoNeedForGlobal: lookup of a global which happens to be local here"""
    mymod = vb2py.vbparser.VBCodeModule(modulename="this")
    mymod.parent = self.proj
    py = vb2py.vbparser.parseVB("""
    Dim myval
    Public Function MyRun()
        MyRun=myval
    End Function
    """, container=mymod)
    #
    python = py.renderAsCode()
    #
    for converted in ("this.MyRun", "global MyRun"):
        self.assertEqual(python.find(converted), -1, python)		
		
def testNeedAGlobalButOnlyUseOne(self):
    """testNeedAGlobalButOnlyUseOne: need to use a global statement but should just use one"""
    mymod = vb2py.vbparser.VBCodeModule(modulename="this")
    mymod.parent = self.proj
    py = vb2py.vbparser.parseVB("""
    Dim myval
    Public Function MyRun()
        myval = 10
		myval = 20
		myval = 30
    End Function
    """, container=mymod)
    #
    python = py.renderAsCode()
    #
    for converted in ("global myval, myval",):
        self.assertEqual(python.find(converted), -1, python)				</t>
<t tx="pap.120703001453.817"></t>
<t tx="pap.120703001453.818">@root test\testcollection.py


from unittest import *
from vb2py.vbclasses import Collection

class TestCollection(TestCase):
    
    def setUp(self):
        """Set up the test"""
		self.c = Collection()
		       
    &lt;&lt; Collection tests &gt;&gt;


if __name__ == "__main__":
    main()		

</t>
<t tx="pap.120703001453.819">&lt;&lt; Collection tests &gt;&gt;=

def testAddNumeric(self):
	"""testAddNumeric: should be able to add with numeric indexes"""
	for i in range(10):
		self.c.Add(i)
	for expect, actual in zip(range(10), self.c):
		self.assertEqual(expect, actual)
	self.assertEqual(self.c.Count(), 10)		</t>
<t tx="pap.120703001453.820">&lt;&lt; Collection tests &gt;&gt;=

def testAddBeforeNumeric(self):
	"""testAddBeforeNumeric: should be able to add something before something else"""
	# Put 1 ... 9 in with 5 missing
	for i in range(1, 10):
		if i &lt;&gt; 5:
			self.c.Add(i)
	self.c.Add(5, Before=5) # ie before the index 5
	for expect, actual in zip(range(1, 10), self.c):
		self.assertEqual(expect, actual)
	self.assertEqual(self.c.Count(), 9)		</t>
<t tx="pap.120703001453.821">&lt;&lt; Collection tests &gt;&gt;=

def testAddAfterNumeric(self):
	"""testAddAfterNumeric: should be able to add something after something else"""
	# Put 1 ... 9 in with 5 missing
	for i in range(1, 10):
		if i &lt;&gt; 5:
			self.c.Add(i)
	self.c.Add(5, After=4)
	for expect, actual in zip(range(1, 10), self.c):
		self.assertEqual(expect, actual)
	self.assertEqual(self.c.Count(), 9)		</t>
<t tx="pap.120703001453.822">&lt;&lt; Collection tests &gt;&gt;=

def testAddText(self):
	"""testAddText: should be able to add with text indexes"""
	for i in range(10):
		self.c.Add(i, "txt%d" % i)
	for expect, actual in zip(range(10), self.c):
		self.assertEqual(expect, actual)
	self.assertEqual(self.c.Count(), 10)	</t>
<t tx="pap.120703001453.823">&lt;&lt; Collection tests &gt;&gt;=

def testAddTextandNumeric(self):
	"""testAddTextandNumeric: should be able to add with text and numeric indexes"""
	for i in range(10):
		self.c.Add(i, "txt%d" % i)
		self.c.Add(i)
	for i in range(10):
		self.assertEqual(self.c.Item("txt%d" % i), i)
		self.assertEqual(self.c.Item(i*2+2), i)
	self.assertEqual(self.c.Count(), 20)	</t>
<t tx="pap.120703001453.824">&lt;&lt; Collection tests &gt;&gt;=

def testItemNumeric(self):
	"""testItemNumeric: should be able to get with numeric indexes"""
	for i in range(10):
		self.c.Add(i)
	for i in range(10):
		self.assertEqual(i, self.c.Item(i+1))
</t>
<t tx="pap.120703001453.825">&lt;&lt; Collection tests &gt;&gt;=

def testItemText(self):
	"""testItemText: should be able to get with text indexes"""
	for i in range(10):
		self.c.Add(i, "txt%d" % i)
	for i in range(10):
		self.assertEqual(i, self.c.Item("txt%d" %  i))
</t>
<t tx="pap.120703001453.826">&lt;&lt; Collection tests &gt;&gt;=

def testRemoveNumeric(self):
	"""testRemoveNumeric: should be able to remove with numeric indexes"""
	for i in range(10):
		self.c.Add(i+1)
	self.c.Remove(5)
	self.assertEqual(self.c.Count(), 9)
	for i in self.c:
		self.assertNotEqual(i, 5)
</t>
<t tx="pap.120703001453.827">&lt;&lt; Collection tests &gt;&gt;=

def testRemoveText(self):
	"""testRemoveText: should be able to remove with text indexes"""
	for i in range(10):
		self.c.Add(i, "txt%d" % i)
	self.c.Remove("txt%d" % 5)
	self.assertEqual(self.c.Count(), 9)
	for i in self.c:
		self.assertNotEqual(i, 5)
</t>
<t tx="pap.120703001453.828">@root test\testobjectdef.py


from unittest import *
from vb2py.vbfunctions import vbObjectInitialize, String, Integer

class TestObjectDef(TestCase):
    
    &lt;&lt; ObjectDef tests &gt;&gt;


if __name__ == "__main__":
    main()		
</t>
<t tx="pap.120703001453.829">&lt;&lt; ObjectDef tests &gt;&gt;=

def test1D(self):
	"""test1D: should be able to create a 1D Array"""
	a = vbObjectInitialize((10,), String)		
	self.assertEqual(len(a), 11)
	for i in range(0, 11):
		self.assertEqual(a(i), "")</t>
<t tx="pap.120703001453.830">&lt;&lt; ObjectDef tests &gt;&gt;=

def test1DOffsetRange(self):
	"""test1DOffsetRange: should be able to create a 1D Array with an offset range"""
	a = vbObjectInitialize(((5,10),), String)		
	self.assertEqual(len(a), 6)
	for i in range(5, 11):
		self.assertEqual(a(i), "")
	self.assertRaises(IndexError, a.__getitem__, 4)	
	self.assertRaises(IndexError, a.__getitem__, 11)</t>
<t tx="pap.120703001453.831">&lt;&lt; ObjectDef tests &gt;&gt;=

def test2D(self):
	"""test2D: should be able to create a 2D Array"""
	a = vbObjectInitialize((10, 5), String)		
	self.assertEqual(len(a), 11)
	self.assertEqual(len(a(0)), 6)
	for i in range(0, 11):
		for j in range(0, 6):
			self.assertEqual(a(i, j), "")</t>
<t tx="pap.120703001453.832">&lt;&lt; ObjectDef tests &gt;&gt;=

def test2DOffsetRange(self):
	"""test2DOffsetRange: should be able to create a 2D Array with offset range"""
	a = vbObjectInitialize(((5, 10), (-5, 5)), String)		
	self.assertEqual(len(a), 6)
	self.assertEqual(len(a(5)), 11)
	for i in range(5, 11):
		for j in range(-5, 6):
			self.assertEqual(a(i, j), "")</t>
<t tx="pap.120703001453.833">&lt;&lt; ObjectDef tests &gt;&gt;=

def test1DIteration(self):
	"""test1DIteration: should be able to iterate over a 1D Array"""
	a = vbObjectInitialize((10,), Integer)		
	for i in range(0, 11):
		a[i] = i
	for i, j in zip(range(11), a):
		self.assertEqual(i, j)</t>
<t tx="pap.120703001453.834">&lt;&lt; ObjectDef tests &gt;&gt;=

def test1DIterationOffsetRange(self):
	"""test1DIterationOffsetRange: should be able to iterate over a 1D Array with offset range"""
	a = vbObjectInitialize(((5, 10),), Integer)		
	for i in range(5, 11):
		a[i] = i
	for i, j in zip(range(5, 11), a):
		self.assertEqual(i, j)</t>
<t tx="pap.120703001453.835">&lt;&lt; ObjectDef tests &gt;&gt;=

def test2DIteration(self):
	"""test2DIteration: should be able to iterate over a 2D Array"""
	a = vbObjectInitialize((10,20), Integer)		
	for i in range(0, 11):
		for j in range(0, 21):
			a[i, j] = i*j
	for i, arr in zip(range(11), a):
		for j, result in zip(range(21), arr):
			self.assertEqual(i*j, result)</t>
<t tx="pap.120703001453.836">&lt;&lt; ObjectDef tests &gt;&gt;=

def test2DIterationOffsetRange(self):
	"""test2DIterationOffsetRange: should be able to iterate over a 2D Array with an offset range"""
	a = vbObjectInitialize(((5, 10),(10, 20)), Integer)		
	for i in range(5, 11):
		for j in range(10, 21):
			a[i, j] = i*j
	for i, arr in zip(range(5, 11), a):
		for j, result in zip(range(10, 21), arr):
			self.assertEqual(i*j, result)</t>
<t tx="pap.120703001453.837">@root test\testconfig.py

#
# Turn off logging in extensions (too loud!)
import vb2py.extensions
vb2py.extensions.disableLogging()
import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff

from unittest import *
import vb2py.config
import ConfigParser
from vb2py.vbparser import convertVBtoPython
import re

class TestConfig(TestCase):
    
    def setUp(self):
        """Set up the test"""
		&lt;&lt; Setup info &gt;&gt;
		       
    &lt;&lt; Config tests &gt;&gt;


if __name__ == "__main__":
    main()		



</t>
<t tx="pap.120703001453.838">@c

self.c = vb2py.config.VB2PYConfig(init=1)

self.code1 =  """
	If a = 10 Then
		b = 1
	Else
		b = 2
	End If
	"""
	
self.code2 = """
	Function f()
	f = 10
	End Function
	"""			

self.code3 = """
	Select Case a
	Case 10
	Case 20
	End Select
	"""	</t>
<t tx="pap.120703001453.839"></t>
<t tx="pap.120703001453.840">&lt;&lt; Config tests &gt;&gt;=

def testGetconfig(self):
    """testGetConfig: should be able to get config items"""
    for section, name in (("General", "LoadUserPlugins"),
                          ("Functions", "ReturnVariableName"),
                          ("Labels", "IgnoreLabels"),
                         ):
        a = self.c[section, name]
        

</t>
<t tx="pap.120703001453.841">&lt;&lt; Config tests &gt;&gt;=

def testGetConfigMissing(self):
    """testGetConfigMissing: should raise an error if no config items"""
    for section, name in (("Generalyy", "LoadUserPlugins"),
                          ("Functionsyy", "ReturnVariableName"),
                          ("Labelsyy", "IgnoreLabels"),
                         ):
        self.assertRaises(ConfigParser.NoSectionError, self.c.__getitem__, (section, name))
        

</t>
<t tx="pap.120703001453.842">&lt;&lt; Config tests &gt;&gt;=

def testSetLocalOveride(self):
    """testSetLocalOveride: should be able to overide config items"""
    for section, name in (("General", "LoadUserPlugins"),
                          ("Functions", "ReturnVariableName"),
                          ("Labels", "IgnoreLabels"),
                         ):
        a = self.c[section, name]
        c = "%s_new" % a
        self.c.setLocalOveride(section, name, c)
        b = self.c[section, name]
        self.assertEqual(b, c)
        self.assertNotEqual(a, b)
</t>
<t tx="pap.120703001453.843">&lt;&lt; Config tests &gt;&gt;=

def testSetLocalOverideDoesntExist(self):
    """testSetLocalOverideDoesntExist: should raise an error if overide non-existant value"""
    for section, name in (("Genekkral", "LoadUserPlugins"),
                          ("Functillons", "ReturnVariableName"),
                          ("Labelkks", "IgnoreLabels"),
                         ):
		self.assertRaises(ConfigParser.NoSectionError, self.c.setLocalOveride, section, name, "ok")

def testRemoveLocalOverideDoesntExist(self):
    """testRemoveLocalOverideDoesntExist: should raise an error if remove overide non-existant value"""
    for section, name in (("Genekkral", "LoadUserPlugins"),
                          ("Functillons", "ReturnVariableName"),
                          ("Labelkks", "IgnoreLabels"),
                         ):
		self.assertRaises(ConfigParser.NoSectionError, self.c.removeLocalOveride, section, name)
</t>
<t tx="pap.120703001453.844">&lt;&lt; Config tests &gt;&gt;=

def testRemoveLocalOveride(self):
    """testRemoveLocalOveride: should be able to remove overide of config items"""
    for section, name in (("General", "LoadUserPlugins"),
                          ("Functions", "ReturnVariableName"),
                          ("Labels", "IgnoreLabels"),
                         ):
        a = self.c[section, name]
        c = "%s_new" % a
        self.c.setLocalOveride(section, name, c)
        self.c.removeLocalOveride(section, name)
        b = self.c[section, name]
        self.assertEqual(a, b)</t>
<t tx="pap.120703001453.845"></t>
<t tx="pap.120703001453.846"></t>
<t tx="pap.120703001453.847">&lt;&lt; Config tests &gt;&gt;=

def testSpaceOrTab(self):
    """testSpaceOrTab: should be change between spaces and tabs"""
	self.c.setLocalOveride("General", "IndentAmount", 4)	
	self.c.setLocalOveride("General", "IndentCharacter", "Space")	
	c_space = convertVBtoPython(self.code1)
	self.c.setLocalOveride("General", "IndentAmount", 1)	
	self.c.setLocalOveride("General", "IndentCharacter", "Tab")	
	c_tabs = convertVBtoPython(self.code1)
	#
	# Should be different
	self.assertNotEqual(c_space, c_tabs)
	#
	# But only tabs and spaces
	self.assertEqual(c_space, c_tabs.replace("\t", "    "))
	
	
	
        

</t>
<t tx="pap.120703001453.848">&lt;&lt; Config tests &gt;&gt;=

def testIndentAmount(self):
    """testSpaceOrTab: should be change between spaces and tabs"""
	self.c.setLocalOveride("General", "IndentAmount", 4)	
	self.c.setLocalOveride("General", "IndentCharacter", "Space")	
	c_four = convertVBtoPython(self.code1)
	self.c.setLocalOveride("General", "IndentAmount", 8)	
	c_eight = convertVBtoPython(self.code1)
	#
	# Should be different
	self.assertNotEqual(c_four, c_eight)
	#
	# But only by number of spaces
	self.assertEqual(c_four, c_eight.replace("        ", "    "))
	
	
	
        

</t>
<t tx="pap.120703001453.849">&lt;&lt; Config tests &gt;&gt;=

def testRespectPrivateStatus(self):
    """testRespectPrivateStatus: should be able to turn off data hiding"""
	self.c.setLocalOveride("General", "RespectPrivateStatus", "Yes")	
	c_on = convertVBtoPython(self.code2, container=vb2py.vbparser.VBClassModule())
	self.c.setLocalOveride("General", "RespectPrivateStatus", "No")	
	c_off = convertVBtoPython(self.code2, container=vb2py.vbparser.VBClassModule())
	#
	# Should be different
	self.assertNotEqual(c_on, c_off, "Option made no difference: '%s'" % c_on)
	#
	# On should have __, off should not
	self.assertNotEqual(-1, c_on.find("__f"), "Yes didn't have __: '%s'" % c_on)
	self.assertEqual(-1, c_off.find("__f"), "No had __: '%s'" % c_off)	
	
	
        

</t>
<t tx="pap.120703001453.850">&lt;&lt; Config tests &gt;&gt;=

def testPrivateDataPrefix(self):
    """testPrivateDataPrefix: should be able to data hiding prefix"""
	self.c.setLocalOveride("General", "RespectPrivateStatus", "Yes")	
	self.c.setLocalOveride("General", "PrivateDataPrefix", "__")	
	c_on = convertVBtoPython(self.code2, container=vb2py.vbparser.VBClassModule())
	self.c.setLocalOveride("General", "PrivateDataPrefix", "m_")	
	c_off = convertVBtoPython(self.code2, container=vb2py.vbparser.VBClassModule())
	#
	# Should be different
	self.assertNotEqual(c_on, c_off, "Option made no difference: '%s'" % c_on)
	#
	# On should have __, off should have m_
	self.assertNotEqual(-1, c_on.find("__f"), "Yes didn't have __: '%s'" % c_on)
	self.assertNotEqual(-1, c_off.find("m_f"), "No didn't have m_: '%s'" % c_off)	
	
	
        
</t>
<t tx="pap.120703001453.851"></t>
<t tx="pap.120703001453.852">&lt;&lt; Config tests &gt;&gt;=

def testFunctionVariable(self):
    """testFunctionVariable: should be able to change function variable"""
	self.c.setLocalOveride("Functions", "ReturnVariableName", "_ret")	
	c_ret = convertVBtoPython(self.code2)
	self.c.setLocalOveride("Functions", "ReturnVariableName", "_other")	
	c_other = convertVBtoPython(self.code2)
	#
	# Should be different
	self.assertNotEqual(c_ret, c_other)
	#
	# But only tabs and spaces
	self.assertEqual(c_ret, c_other.replace("_other", "_ret"))
	
	
	
        

</t>
<t tx="pap.120703001453.853">&lt;&lt; Config tests &gt;&gt;=

def testPreInitVariable(self):
    """testPreInitVariable: should be able to change if variable is pre initialized"""
	self.c.setLocalOveride("Functions", "ReturnVariableName", "_ret")	
	self.c.setLocalOveride("Functions", "PreInitializeReturnVariable", "Yes")	
	c_yes = convertVBtoPython(self.code2)
	self.c.setLocalOveride("Functions", "PreInitializeReturnVariable", "No")	
	c_no = convertVBtoPython(self.code2)
	#
	# Should be different
	self.assertNotEqual(c_yes, c_no)
	#
	# With init should have _ret = None, not without
	self.assertNotEqual(c_yes.find("_ret = None"), -1)
	self.assertEqual(c_no.find("_ret = None"), -1)
	
	
	
        

</t>
<t tx="pap.120703001453.854"></t>
<t tx="pap.120703001453.855">&lt;&lt; Config tests &gt;&gt;=

def testSelectVariable(self):
    """testSelectVariable: should be able to change select variable"""
	self.c.setLocalOveride("Select", "UseNumericIndex", "No")	
	self.c.setLocalOveride("Select", "SelectVariablePrefix", "_ret")	
	c_ret = convertVBtoPython(self.code3)
	self.c.setLocalOveride("Select", "SelectVariablePrefix", "_other")	
	c_other = convertVBtoPython(self.code3)
	#
	# Should be different
	self.assertNotEqual(c_ret, c_other)
	#
	# But only tabs and spaces
	self.assertEqual(c_ret, c_other.replace("_other", "_ret"))
	
	
	
        

</t>
<t tx="pap.120703001453.856">&lt;&lt; Config tests &gt;&gt;=

def testSelectVariableIndex(self):
    """testSelectVariableIndex: should be able to turn off select variable index"""
	self.c.setLocalOveride("Select", "UseNumericIndex", "Yes")	
	self.c.setLocalOveride("Select", "SelectVariablePrefix", "_ret")	
	c_1 = convertVBtoPython(self.code3)
	self.c.setLocalOveride("Select", "UseNumericIndex", "No")	
	c_2 = convertVBtoPython(self.code3)
	#
	# Should be different
	self.assertNotEqual(c_1, c_2)
	
	
	
        

</t>
<t tx="pap.120703001453.857">&lt;&lt; Config tests &gt;&gt;=

def testEvalVariable(self):
    """testEvalVariable: should be able to change whether variable is used once or more than once"""
	self.c.setLocalOveride("Select", "EvaluateVariable", "Once")	
	self.c.setLocalOveride("Select", "SelectVariablePrefix", "_ret")	
	c_1 = convertVBtoPython(self.code3)
	self.c.setLocalOveride("Select", "EvaluateVariable", "EachTime")	
	c_2 = convertVBtoPython(self.code3)
	#
	r = re.compile("_ret")
	self.assert_(len(r.findall(c_1)) &gt; 1)	
	self.assertEqual(len(r.findall(c_2)), 0)	
	
	
        


</t>
<t tx="pap.120703001453.858"></t>
<t tx="pap.120703001453.859">@root test\testattributenames.py

#
# Turn off logging in extensions (too loud!)
import vb2py.extensions
vb2py.extensions.disableLogging()
import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff

from unittest import *

from vb2py.plugins.attributenames import TranslateAttributes

class TestAttributeNames(TestCase):
    
	def setUp(self):
		"""Setup the tests"""
		self.p = TranslateAttributes()

	&lt;&lt; Tests &gt;&gt;
	
if __name__ == "__main__":
    main()		



</t>
<t tx="pap.120703001453.860">&lt;&lt; Tests &gt;&gt;=

def testAll(self):
	"""Do some tests on the attribute"""
	names =(("Text", "text"),
			("Visible", "visible"),)
	for attribute, replaced in names:
		for pattern in ("a.%s=b", ".%s=b", "b=a.%s", "b=.%s",
						"a.%s.b=c", ".%s.c=b", "b=a.%s.c", "b=.%s.c",
						"a.%s.b+10=c", ".%s.c+10=b", "b=a.%s.c+10", "b=.%s.c+10",):
			test = pattern % attribute
			new = self.p.postProcessPythonText(test)
			self.assertEqual(new, pattern % replaced)
	for attribute, replaced in names:
		for pattern in ("a.%slkjlk=b", ".%slkjlk=b", "b=a.%slkjl", "b=.%slkjl",
						"a.%slkj.b=c", ".%slkj.c=b", "b=a.%slkj.c", "b=.%slkj.c",
						"a.%slkj.b+10=c", ".%slkj.c+10=b", "b=a.%slkj.c+10", "b=.%slkj.c+10",):
			test = pattern % attribute
			new = self.p.postProcessPythonText(test)
			self.assertNotEqual(new, pattern % replaced)
</t>
<t tx="pap.120703001453.861">@root test/testall.py

import glob
import os
import unittest
import sys
import re
import time

ok = re.compile(r".*Ran\s(\d+).*", re.DOTALL+re.MULTILINE)
fail = re.compile(r".*Ran\s(\d+).*failures=(\d+)", re.DOTALL+re.MULTILINE)

show_errors = 0
if len(sys.argv) == 2:
    if sys.argv[1] == "-v":
        show_errors = 1

if __name__ == "__main__":
	print "\nStarting testall at %s\n" % time.ctime()
	files = glob.glob(r"test/test*.py")
	total_run = 0
	total_failed = 0
	start = time.time()
	try:
		for file in files:
			if file not in (r"test\testall.py", r"test\testframework.py", "test\testparser.py"):
				print "Running '%s' ... " % file,
				fname = os.path.join(r"c:\development\python24\lib\site-packages\vb2py", file)
				pi, po, pe = os.popen3(fname)
				result = pe.read()
				if result.find("FAILED") &gt; -1:
					try:
						num = int(fail.match(result).groups()[0])
						num_fail = int(fail.match(result).groups()[1])
					except:
						num, num_fail = 0, 0
					total_run += num
					total_failed += num_fail
					if show_errors:
									print "\n%s" % result
					else:
						print "*** %s errors out of %s" % (num_fail, num)
				else:
					num = int(ok.match(result).groups()[0])
					print "Passed %s tests" % num
					total_run += num
				pi.close()
				po.close()
				pe.close()
	except KeyboardInterrupt:
		pass
	print "\nRan %d tests\nFailed %d\nTook %d seconds" % (total_run, total_failed, time.time()-start)</t>
<t tx="pap.120703001453.862"></t>
<t tx="pap.120703001453.863">@root sandbox\__init__.py

pass</t>
<t tx="pap.120703001453.864">@root sandbox\commandline.py

"""A simple module intended to aid interactive testing of the parser

We just import a lot of useful things with short names so they are easy to type!

"""


from vb2py.vbparser import convertVBtoPython, parseVB as p, parseVBFile as f, getAST as t
import vb2py.vbparser

try:
	from win32clipboard import *
	import win32con
	
	def getClipBoardText():
		"""Get text from the clipboard"""
		OpenClipboard()
		try:
			got = GetClipboardData(win32con.CF_UNICODETEXT)
		finally:
			CloseClipboard()
		return str(got)
	v = getClipBoardText
except ImportError:
	print "Clipboard copy not working!"

if __name__ == "__main__":
	def c(*args, **kw):
		print convertVBtoPython(*args, **kw)
</t>
<t tx="pap.120703001453.865">@root sandbox\makedocs.py

import vb2py.vbparser
import re
import glob
import vb2py.utils
import os
import sys

#
# Turn off logging 
import vb2py.extensions
vb2py.extensions.disableLogging()
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff

&lt;&lt; fn doAutomaticVBConversion &gt;&gt;
&lt;&lt; fn addToTemplate &gt;&gt;

if __name__ == "__main__":
	#
	add_to_template = 0
	if len(sys.argv) == 1:
		pattern = "*.htm"
	else:
		pattern = sys.argv[1]
	#
    print "\nvb2Py documentation generator\n"
    for fn in glob.glob(os.path.join(vb2py.utils.rootPath(), "doc", pattern)):
        print "Processing '%s' ... " % fn,
        txt = open(fn, "r").read()
		marked_up_text = doAutomaticVBConversion(txt)
		#
		if add_to_template:
			marked_up_text = addToTemplate(marked_up_text, sys.argv[2], "DOCSGOHERE")
		#
        open(fn+"l", "w").write(marked_up_text)
        print "Done!"</t>
<t tx="pap.120703001453.866">@c

def doAutomaticVBConversion(txt):
	"""Convert VB code in the text to Python"""
	vb = re.compile(r'(.*?)&lt;p&gt;VB(\(.*?\))?:&lt;/p&gt;.*?&lt;pre class="literal-block"&gt;(.*?)&lt;/pre&gt;(.*?)', 
                    re.DOTALL+re.MULTILINE)
	def convertVB(match):
		"""Convert the match"""
        if match.groups()[1]:
            mod = getattr(vb2py.vbparser, match.groups()[1][1:-1])()
        else:
            mod = vb2py.vbparser.VBCodeModule()
        mod.importStatements = lambda x : ""
		m = vb2py.vbparser.parseVB(match.groups()[2], container=mod)
		return '%s&lt;table style="code-table"&gt;' \
               '&lt;tr&gt;&lt;th class="code-header"&gt;VB&lt;/th&gt;&lt;th class="code-header"&gt;Python&lt;/th&gt;&lt;/tr&gt;' \
               '&lt;tr&gt;&lt;td class="vb-code-cell"&gt;&lt;pre&gt;%s&lt;/pre&gt;&lt;/td&gt;' \
               '&lt;td class="python-code-cell"&gt;&lt;pre&gt;%s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;%s' % (
                                           match.groups()[0],
									       match.groups()[2].replace("\n", "&lt;br&gt;"),
									       m.renderAsCode(1).replace("\n", "&lt;br&gt;"),
									       match.groups()[3])
	return vb.sub(convertVB, txt)</t>
<t tx="pap.120703001453.867">@c

def addToTemplate(text, template, token):
	"""Add the text to the template"""
	template_text = open(template, "r").read()
	template_text = template_text.replace(token, text)
	return template_text</t>
<t tx="pap.120703001453.868">@root sandbox\dofile.py

from vb2py.vbparser import convertVBtoPython, parseVB as p
import vb2py.vbparser
import sys

if __name__ == "__main__":
	def c(*args, **kw):
		print convertVBtoPython(*args, **kw)
		
	t = open(sys.argv[1], 'r').read()		</t>
<t tx="pap.120703001453.869"></t>
<t tx="pap.120703001453.870">@root sandbox\experiment_byref.py

from threading import Thread
from time import sleep

def change1(x, y):
	"""Mimic ByRef by rebinding after the fact"""
	x = x + 1
	y = y + 1
	return y
	
def change2(x, y, refs):
	"""Mimic ByRef by manipulating locals"""
	x = x + 1
	refs[y] = refs[y] + 1
	
	
if __name__ == "__main__":
	
	def tryit():
		x = 1
		y = 1
		def doit(n, locs, delay):
			print "Thread %d before x, y = %s, %s" % (n, x, y)
			change2(x, 'y', locs)
			print "Thread %d sleeping for %s" % (n, delay)
			sleep(delay)
			print "Thread %d after x, y = %s, %s" % (n, x, y)
		
		for delay in (0, .00001, 1):	
			t1 = Thread(target=doit, args=(1, locals(), delay))
			t2 = Thread(target=doit, args=(2, locals(), delay))
			
			t1.start()
			t2.start()
			
	tryit()</t>
<t tx="pap.120703001453.871">@root sandbox\makeconstants.py

"""Take a series of text representations of keycodes and generate a Python file

The data comes from the MSDN
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbenlr98/html/vamsctypelibconstants.asp

"""

import vb2py.utils
import os
import re

constants = []

pattern = re.compile("(\w+)\s+(.+?)\s+(.*)")

&lt;&lt; Constants &gt;&gt;

if __name__ == "__main__":
	f = open(vb2py.utils.relativePath("vbconstants.py"), "w")
	f.write('\n"""VB Constants"""\n\n')
	for name, chunk in constants:
		f.write("# %s\n" % name)
		for line in chunk.splitlines():
			match = pattern.match(line.strip())
			if not match:
				print "Unable to match: '%s'" % line
			else:
				f.write("%s = %s # %s\n" % match.groups())
				print "Wrote: '%s'" % match.groups()[0]
		f.write("\n\n")
	f.close()</t>
<t tx="pap.120703001453.872">&lt;&lt; Constants &gt;&gt;=

constants.append(("Key Codes", """
vbKeyLButton 0x1 Left mouse button 
vbKeyRButton 0x2 Right mouse button 
vbKeyCancel 0x3 CANCEL key 
vbKeyMButton 0x4 Middle mouse button 
vbKeyBack 0x8 BACKSPACE key 
vbKeyTab 0x9 TAB key 
vbKeyClear 0xC CLEAR key 
vbKeyReturn 0xD ENTER key 
vbKeyShift 0x10 SHIFT key 
vbKeyControl 0x11 CTRL key 
vbKeyMenu 0x12 MENU key 
vbKeyPause 0x13 PAUSE key 
vbKeyCapital 0x14 CAPS LOCK key 
vbKeyEscape 0x1B ESC key 
vbKeySpace 0x20 SPACEBAR key 
vbKeyPageUp 0x21 PAGE UP key 
vbKeyPageDown 0x22 PAGE DOWN key 
vbKeyEnd 0x23 END key 
vbKeyHome 0x24 HOME key 
vbKeyLeft 0x25 LEFT ARROW key 
vbKeyUp 0x26 UP ARROW key 
vbKeyRight 0x27 RIGHT ARROW key 
vbKeyDown 0x28 DOWN ARROW key 
vbKeySelect 0x29 SELECT key 
vbKeyPrint 0x2A PRINT SCREEN key 
vbKeyExecute 0x2B EXECUTE key 
vbKeySnapshot 0x2C SNAPSHOT key 
vbKeyInsert 0x2D INSERT key 
vbKeyDelete 0x2E DELETE key 
vbKeyHelp 0x2F HELP key 
vbKeyNumlock 0x90 NUM LOCK key 
"""))</t>
<t tx="pap.120703001453.873">&lt;&lt; Constants &gt;&gt;=

constants.append(("Form Codes", """
vbModeless 0 UserForm is modeless. 
vbModal 1 UserForm is modal (default).
"""))

</t>
<t tx="pap.120703001453.874">&lt;&lt; Constants &gt;&gt;=

constants.append(("Colour Codes", """
vbBlack 0x0 Black 
vbRed 0xFF Red 
vbGreen 0xFF00 Green 
vbYellow 0xFFFF Yellow 
vbBlue 0xFF0000 Blue 
vbMagenta 0xFF00FF Magenta 
vbCyan 0xFFFF00 Cyan 
vbWhite 0xFFFFFF White 
"""))
</t>
<t tx="pap.120703001453.875">&lt;&lt; Constants &gt;&gt;=

constants.append(("Dir etc Codes", """
vbNormal 0 Normal (default for Dir and SetAttr) 
vbReadOnly 1 Read-only 
vbHidden 2 Hidden 
vbSystem 4 System file 
vbVolume 8 Volume label 
vbDirectory 16 Directory or folder 
vbArchive 32 File has changed since last backup 
"""))
</t>
<t tx="pap.120703001453.876">&lt;&lt; Constants &gt;&gt;=

constants.append(("File Attribute Codes", """
Normal 0 Normal file. No attributes are set. 
ReadOnly 1 Read-only file. Attribute is read/write. 
Hidden 2 Hidden file. Attribute is read/write. 
System 4 System file. Attribute is read/write. 
Volume 8 Disk drive volume label. Attribute is read-only. 
Directory 16 Folder or directory. Attribute is read-only. 
Archive 32 File has changed since last backup. Attribute is read/write. 
Alias 64 Link or shortcut. Attribute is read-only. 
Compressed 128 Compressed file. Attribute is read-only. 
"""))
</t>
<t tx="pap.120703001453.877">&lt;&lt; Constants &gt;&gt;=

constants.append(("Miscellaneous Codes", """
vbCrLf "\\n" Carriage returnlinefeed combination 
vbCr chr(13) Carriage return character 
vbLf chr(10) Linefeed character 
vbNewLine "\\n"  Platform-specific new line character; whichever is appropriate for current platform 
vbNullChar chr(0) Character having value 0 
vbNullString chr(0) String having value 0 Not the same as a zero-length string (""); used for calling external procedures 
vbObjectError -2147221504 User-defined error numbers should be greater than this value. For example: Err.Raise Number = vbObjectError + 1000 
vbTab chr(9) Tab character 
vbBack chr(8) Backspace character 
vbFormFeed chr(12) Not useful in Microsoft Windows 
vbVerticalTab chr(11) Not useful in Microsoft Windows 
"""))
</t>
<t tx="pap.120703001453.878">&lt;&lt; Constants &gt;&gt;=

constants.append(("MsgBox Codes", """
vbOKOnly 0 OK button only (default) 
vbOKCancel 1 OK and Cancel buttons 
vbAbortRetryIgnore 2 Abort, Retry, and Ignore buttons 
vbYesNoCancel 3 Yes, No, and Cancel buttons 
vbYesNo 4 Yes and No buttons 
vbRetryCancel 5 Retry and Cancel buttons 
vbCritical 16 Critical message 
vbQuestion 32 Warning query 
vbExclamation 48 Warning message 
vbInformation 64 Information message 
vbDefaultButton1 0 First button is default (default) 
vbDefaultButton2 256 Second button is default 
vbDefaultButton3 512 Third button is default 
vbDefaultButton4 768 Fourth button is default 
vbApplicationModal 0 Application modal message box (default) 
vbSystemModal 4096 System modal message box 
vbMsgBoxHelpButton 16384 Adds Help button to the message box 
VbMsgBoxSetForeground 65536 Specifies the message box window as the foreground window 
vbMsgBoxRight 524288 Text is right aligned 
vbMsgBoxRtlReading 1048576 Specifies text should appear as right-to-left reading on Hebrew and Arabic systems 
vbOK 1 OK button pressed 
vbCancel 2 Cancel button pressed 
vbAbort 3 Abort button pressed 
vbRetry 4 Retry button pressed 
vbIgnore 5 Ignore button pressed 
vbYes 6 Yes button pressed 
vbNo 7 No button pressed 
"""))
</t>
<t tx="pap.120703001453.879">&lt;&lt; Constants &gt;&gt;=

constants.append(("Shell Codes", """
vbHide 0 Window is hidden and focus is passed to the hidden window. 
vbNormalFocus 1 Window has focus and is restored to its original size and position. 
vbMinimizedFocus 2 Window is displayed as an icon with focus. 
vbMaximizedFocus 3 Window is maximized with focus. 
vbNormalNoFocus 4 Window is restored to its most recent size and position. The currently active window remains active. 
vbMinimizedNoFocus 6 Window is displayed as an icon. The currently active window remains active. 
"""))
</t>
<t tx="pap.120703001453.880">&lt;&lt; Constants &gt;&gt;=

constants.append(("Special Folder Codes", """
WindowsFolder 0 The Windows folder contains files installed by the Windows operating system. 
SystemFolder 1 The System folder contains libraries, fonts, and device drivers. 
TemporaryFolder 2 The Temp folder is used to store temporary files. Its path is found in the TMP environment variable. 
"""))
</t>
<t tx="pap.120703001453.881">&lt;&lt; Constants &gt;&gt;=

constants.append(("StrConv Codes", """
vbUpperCase 1 Converts the string to uppercase characters. 
vbLowerCase 2 Converts the string to lowercase characters. 
vbProperCase 3 Converts the first letter of every word in string to uppercase. 
vbWide 4 Converts narrow (single-byte) characters in string to wide (double-byte) characters. Applies to Far East locales. 
vbNarrow 8 Converts wide (double-byte) characters in string to narrow (single-byte) characters. Applies to Far East locales. 
vbKatakana 16 Converts Hiragana characters in string to Katakana characters. Applies to Japan only. 
vbHiragana 32 Converts Katakana characters in string to Hiragana characters. Applies to Japan only. 
vbUnicode 64 Converts the string to Unicode using the default code page of the system. 
vbFromUnicode 128 Converts the string from Unicode to the default code page of the system. 
"""))
</t>
<t tx="pap.120703001453.882">&lt;&lt; Constants &gt;&gt;=

constants.append(("System Colour Codes", """
vbScrollBars 0x80000000 Scroll bar color 
vbDesktop 0x80000001 Desktop color 
vbActiveTitleBar 0x80000002 Color of the title bar for the active window 
vbInactiveTitleBar 0x80000003 Color of the title bar for the inactive window 
vbMenuBar 0x80000004 Menu background color 
vbWindowBackground 0x80000005 Window background color 
vbWindowFrame 0x80000006 Window frame color 
vbMenuText 0x80000007 Color of text on menus 
vbWindowText 0x80000008 Color of text in windows 
vbTitleBarText 0x80000009 Color of text in caption, size box, and scroll arrow 
vbActiveBorder 0x8000000A Border color of active window 
vbInactiveBorder 0x8000000B Border color of inactive window 
vbApplicationWorkspace 0x8000000C Background color of multiple-document interface (MDI) applications 
vbHighlight 0x8000000D Background color of items selected in a control 
vbHighlightText 0x8000000E Text color of items selected in a control 
vbButtonFace 0x8000000F Color of shading on the face of command buttons 
vbButtonShadow 0x80000010 Color of shading on the edge of command buttons 
vbGrayText 0x80000011 Grayed (disabled) text 
vbButtonText 0x80000012 Text color on push buttons 
vbInactiveCaptionText 0x80000013 Color of text in an inactive caption 
vb3DHighlight 0x80000014 Highlight color for 3-D display elements 
vb3DDKShadow 0x80000015 Darkest shadow color for 3-D display elements 
vb3DLight 0x80000016 Second lightest 3-D color after vb3DHighlight 
vbInfoText 0x80000017 Color of text in ToolTips 
vbInfoBackground 0x80000018 Background color of ToolTips 
"""))
</t>
<t tx="pap.120703001453.883">&lt;&lt; Constants &gt;&gt;=

constants.append(("Var Type Codes", """
vbEmpty 0 Uninitialized (default) 
vbNull 1 Contains no valid data 
vbInteger 2 Integer 
vbLong 3 Long integer 
vbSingle 4 Single-precision floating-point number 
vbDouble 5 Double-precision floating-point number 
vbCurrency 6 Currency 
vbDate 7 Date 
vbString 8 String 
vbObject 9 Object 
vbError 10 Error 
vbBoolean 11 Boolean 
vbVariant 12 Variant (used only for arrays of variants) 
vbDataObject 13 Data access object 
vbDecimal 14 Decimal 
vbByte 17 Byte 
vbUserDefinedType 36 Variants that contain user-defined types 
vbArray 8192 Array 
"""))
</t>
<t tx="pap.120703001453.884">
@root convertasp.py

&lt;&lt; convertasp declarations &gt;&gt;
&lt;&lt; convertasp methods &gt;&gt;


converter = re.compile(r"\&lt;%(.*?)%\&gt;", re.DOTALL + re.MULTILINE)

print converter.sub(translateScript, test)
</t>
<t tx="pap.120703001453.885">@code

test = """
&lt;html&gt;
&lt;%

function factorial(x)
if x = 0 then
    factorial = 1
else
    factorial = x*factorial(x-1)
end if
end function

%&gt;
&lt;/html&gt;
"""

from vb2py.vbparser import parseVB, VBCodeModule
import re

</t>
<t tx="pap.120703001453.886">&lt;&lt; convertasp methods &gt;&gt;=

def translateScript(match):
    """Translate VBScript fragment to Python"""
    block = parseVB(match.groups()[0], container=VBCodeModule())
    return "&lt;%%\n%s\n%%&gt;" % block.renderAsCode()
</t>
<t tx="pap.120703001453.887">@root sandbox\makeproperties.py

"""Read a type library and generate a list of objects, methods and properties

This is based on code in win32com.client.tlbbrowse

The output is restructured text which is then converted directly to HTML using
docutils.

"""

&lt;&lt; tlbrowse declarations &gt;&gt;
&lt;&lt; tlbrowse methods &gt;&gt;


if __name__=='__main__':
	import sys
	fname = None
	try:
		fname = sys.argv[1]
	except:
		pass
	
	dlg = TypeBrowseDialog(fname)	
	if fname:
		controls = dlg.dumpProperties()
	else:
		dlg.DoModal()
		sys.exit()

	results = []
	l = results.append
	
	l("All VB Controls in %s\n\n" % fname)
	l("\n".join(["* %s_" % control for control in controls]))
	l("\n\n")
	
	for control in controls:
		l("\n%s\n%s\n\n" % (control, "="*len(control)))
		
		properties = controls[control].properties.keys()
		properties.sort()
		l("    *Properties*\n%s" % ("\n\n".join(["        %s" % 
					prop for prop in properties]),)	)						
					
		methods = controls[control].methods.keys()
		methods.sort()					
		l("\n    *Methods*\n%s" % ("\n\n".join(["        %s" % 
					str(controls[control].methods[method]) for method in methods]),))
					
	text = "\n".join(results)
	
	&lt;&lt; Convert to HTML &gt;&gt;</t>
<t tx="pap.120703001453.888">@code

import win32ui
import win32con
import win32api
import string
import commctrl
import pythoncom
from pywin.mfc import dialog

error = "TypeLib browser internal error"

FRAMEDLG_STD = win32con.WS_CAPTION | win32con.WS_SYSMENU
SS_STD = win32con.WS_CHILD | win32con.WS_VISIBLE
BS_STD = SS_STD  | win32con.WS_TABSTOP
ES_STD = BS_STD | win32con.WS_BORDER
LBS_STD = ES_STD | win32con.LBS_NOTIFY | win32con.LBS_NOINTEGRALHEIGHT | win32con.WS_VSCROLL
CBS_STD = ES_STD | win32con.CBS_NOINTEGRALHEIGHT | win32con.WS_VSCROLL

typekindmap = {
	pythoncom.TKIND_ENUM : 'Enumeration',
	pythoncom.TKIND_RECORD : 'Record',
	pythoncom.TKIND_MODULE : 'Module',
	pythoncom.TKIND_INTERFACE : 'Interface',
	pythoncom.TKIND_DISPATCH : 'Dispatch',
	pythoncom.TKIND_COCLASS : 'CoClass',
	pythoncom.TKIND_ALIAS : 'Alias',
	pythoncom.TKIND_UNION : 'Union'
}

TypeBrowseDialog_Parent=dialog.Dialog
</t>
<t tx="pap.120703001453.889">&lt;&lt; tlbrowse methods &gt;&gt;=

class TypeBrowseDialog(TypeBrowseDialog_Parent):
	&lt;&lt; class TypeBrowseDialog declarations &gt;&gt;
	&lt;&lt; class TypeBrowseDialog methods &gt;&gt;


</t>
<t tx="pap.120703001453.890">@code

"Browse a type library"

IDC_TYPELIST = 1000
IDC_MEMBERLIST = 1001
IDC_PARAMLIST = 1002
IDC_LISTVIEW = 1003

</t>
<t tx="pap.120703001453.891"></t>
<t tx="pap.120703001453.892">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def __init__(self, typefile = None):
	TypeBrowseDialog_Parent.__init__(self, self.GetTemplate())
	try:
		if typefile:
			self.tlb = pythoncom.LoadTypeLib(typefile)
		else:
			self.tlb = None
	except pythoncom.ole_error:
		self.MessageBox("The file does not contain type information")
		self.tlb = None
	self.HookCommand(self.CmdTypeListbox, self.IDC_TYPELIST)
	self.HookCommand(self.CmdMemberListbox, self.IDC_MEMBERLIST)

	self.members = []

</t>
<t tx="pap.120703001453.893">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def OnAttachedObjectDeath(self):
	self.tlb = None
	self.typeinfo = None
	self.attr = None
	return TypeBrowseDialog_Parent.OnAttachedObjectDeath(self)
</t>
<t tx="pap.120703001453.894">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def _SetupMenu(self):
	menu = win32ui.CreateMenu()
	flags=win32con.MF_STRING|win32con.MF_ENABLED
	menu.AppendMenu(flags, win32ui.ID_FILE_OPEN, "&amp;Open...")
	menu.AppendMenu(flags, win32con.IDCANCEL, "&amp;Close")
	mainMenu = win32ui.CreateMenu()
	mainMenu.AppendMenu(flags|win32con.MF_POPUP, menu.GetHandle(), "&amp;File")
	self.SetMenu(mainMenu)
	self.HookCommand(self.OnFileOpen,win32ui.ID_FILE_OPEN)
</t>
<t tx="pap.120703001453.895">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def OnFileOpen(self, id, code):
	openFlags = win32con.OFN_OVERWRITEPROMPT | win32con.OFN_FILEMUSTEXIST
	fspec = "Type Libraries (*.tlb, *.olb)|*.tlb;*.olb|OCX Files (*.ocx)|*.ocx|DLL's (*.dll)|*.dll|All Files (*.*)|*.*||"
	dlg = win32ui.CreateFileDialog(1, None, None, openFlags, fspec)
	if dlg.DoModal() == win32con.IDOK:
		try:
			self.tlb = pythoncom.LoadTypeLib(dlg.GetPathName())
		except pythoncom.ole_error:
			self.MessageBox("The file does not contain type information")
			self.tlb = None
		self._SetupTLB()
		self.dumpProperties()
</t>
<t tx="pap.120703001453.896">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def OnInitDialog(self):
	self._SetupMenu()
	self.typelb = self.GetDlgItem(self.IDC_TYPELIST)
	self.memberlb = self.GetDlgItem(self.IDC_MEMBERLIST)
	self.paramlb = self.GetDlgItem(self.IDC_PARAMLIST)
	self.listview = self.GetDlgItem(self.IDC_LISTVIEW)
	
	# Setup the listview columns
	itemDetails = (commctrl.LVCFMT_LEFT, 100, "Item", 0)
	self.listview.InsertColumn(0, itemDetails)
	itemDetails = (commctrl.LVCFMT_LEFT, 1024, "Details", 0)
	self.listview.InsertColumn(1, itemDetails)

	if self.tlb is None:
		self.OnFileOpen(None,None)
	else:
		self._SetupTLB()
	return TypeBrowseDialog_Parent.OnInitDialog(self)
</t>
<t tx="pap.120703001453.897">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def _SetupTLB(self):
	self.typelb.ResetContent()
	self.memberlb.ResetContent()
	self.paramlb.ResetContent()
	self.typeinfo = None
	self.attr = None
	if self.tlb is None: return
	items = self.getAll()
	for item in items:
		self.typelb.AddString(item)
</t>
<t tx="pap.120703001453.898">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def _SetListviewTextItems(self, items):
	self.listview.DeleteAllItems()
	index = -1
	for item in items:
		index = self.listview.InsertItem(index+1,item[0])
		data = item[1]
		if data is None: data = ""
		self.listview.SetItemText(index, 1, data)
</t>
<t tx="pap.120703001453.899">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def SetupAllInfoTypes(self):
	infos = self._GetMainInfoTypes() + self._GetMethodInfoTypes()
	self._SetListviewTextItems(infos)
</t>
<t tx="pap.120703001453.900">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def _GetMainInfoTypes(self):
	pos = self.typelb.GetCurSel()
	if pos&lt;0: return []
	docinfo = self.tlb.GetDocumentation(pos)
	infos = [('GUID', str(self.attr[0]))]
	infos.append(('Help File', docinfo[3]))
	infos.append(('Help Context', str(docinfo[2])))
	try:
		infos.append(('Type Kind', typekindmap[self.tlb.GetTypeInfoType(pos)]))
	except:
		pass
		
	info = self.tlb.GetTypeInfo(pos)
	attr = info.GetTypeAttr()
	infos.append(('Attributes', str(attr)))
		
	for j in range(attr[8]):
		flags = info.GetImplTypeFlags(j)
		refInfo = info.GetRefTypeInfo(info.GetRefTypeOfImplType(j))
		doc = refInfo.GetDocumentation(-1)
		attr = refInfo.GetTypeAttr()
		typeKind = attr[5]
		typeFlags = attr[11]

		desc = doc[0]
		desc = desc + ", Flags=0x%x, typeKind=0x%x, typeFlags=0x%x" % (flags, typeKind, typeFlags)
		if flags &amp; pythoncom.IMPLTYPEFLAG_FSOURCE:
			desc = desc + "(Source)"
		infos.append( 'Implements' + desc)

	return infos
</t>
<t tx="pap.120703001453.901">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def _GetMethodInfoTypes(self):
	pos = self.memberlb.GetCurSel()
	if pos&lt;0: return []

	realPos, isMethod = self._GetRealMemberPos(pos)
	ret = []
	if isMethod:
		funcDesc = self.typeinfo.GetFuncDesc(realPos)
		id = funcDesc[0]
		ret.append(("Func Desc", str(funcDesc)))
	else:
		id = self.typeinfo.GetVarDesc(realPos)[0]
	
	docinfo = self.typeinfo.GetDocumentation(id)
	ret.append(('Help String', docinfo[1]))
	ret.append(('Help Context', str(docinfo[2])))
	return ret
</t>
<t tx="pap.120703001453.902">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def CmdTypeListbox(self, id, code):
	if code == win32con.LBN_SELCHANGE:
		pos = self.typelb.GetCurSel()
		attributes = self.getTypes(pos)
		self.memberlb.ResetContent()
		for attribute in attributes:
			self.memberlb.AddString(attribute)

</t>
<t tx="pap.120703001453.903">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def _GetRealMemberPos(self, pos):
	if pos &gt;= self.attr[7]:
		return pos - self.attr[7], 1
	elif pos &gt;= 0:
		return pos, 0
	else:
		raise error, "The position is not valid"
</t>
<t tx="pap.120703001453.904">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def CmdMemberListbox(self, id, code):
	if code == win32con.LBN_SELCHANGE:
		self.paramlb.ResetContent()
		pos = self.memberlb.GetCurSel()
		names = self.getMembers(pos)
		for i in range(len(names)):
			self.paramlb.AddString(names[i])
	self.SetupAllInfoTypes()
	return 1

</t>
<t tx="pap.120703001453.905">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def GetTemplate(self):
	"Return the template used to create this dialog"

	w = 272  # Dialog width
	h = 192  # Dialog height
	style = FRAMEDLG_STD | win32con.WS_VISIBLE | win32con.DS_SETFONT | win32con.WS_MINIMIZEBOX
	template = [['Type Library Browser', (0, 0, w, h), style, None, (8, 'Helv')], ]
	template.append([130, "&amp;Type", -1, (10, 10, 62, 9), SS_STD | win32con.SS_LEFT])
	template.append([131, None, self.IDC_TYPELIST, (10, 20, 80, 80), LBS_STD])
	template.append([130, "&amp;Members", -1, (100, 10, 62, 9), SS_STD | win32con.SS_LEFT])
	template.append([131, None, self.IDC_MEMBERLIST, (100, 20, 80, 80), LBS_STD])
	template.append([130, "&amp;Parameters", -1, (190, 10, 62, 9), SS_STD | win32con.SS_LEFT])
	template.append([131, None, self.IDC_PARAMLIST, (190, 20, 75, 80), LBS_STD])
	
	lvStyle = SS_STD | commctrl.LVS_REPORT | commctrl.LVS_AUTOARRANGE | commctrl.LVS_ALIGNLEFT | win32con.WS_BORDER | win32con.WS_TABSTOP
	template.append(["SysListView32", "", self.IDC_LISTVIEW, (10, 110, 255, 65), lvStyle])

	return template
</t>
<t tx="pap.120703001453.906"></t>
<t tx="pap.120703001453.907">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def dumpProperties(self):
	"""Dump all objects and properties

		Objects seem to appear as,

			MyControl - an empty reference
			_MyControl - a reference with all the attributes and sometimes some methods
			_MyControlEvents - a reference holding extra methods

		"""
	controls = {}
	for i, item in enumerate(self.getAll()):
		#
		# Create a new control object or get the old one if this is a _Control
		if item.startswith("_"):
			item = item[1:]
		if item.endswith("Events"):
			item = item[:-6]
		try:
			this = controls[item]
		except KeyError:
			this = VBControlObject(item)
			controls[item] = this
		#
		# Find all the types for this object
		types = self.getTypes(i)
		for j, typ in enumerate(types):
			members = self.getMembers(j)
			if members == (None,):
				# This is an attribute
				this.addProperty(typ)
			else:
				# This is a method
				thismethod = VBMethod(typ)
				this.addMethod(thismethod)
				for member in members:
					thismethod.parameters.append(member)
	return controls</t>
<t tx="pap.120703001453.908">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=


def getTypes(self, pos):
	"Process a single type from the library"
	attributes = []
	if pos &gt;= 0:
		self.typeinfo = self.tlb.GetTypeInfo(pos)
		self.attr = self.typeinfo.GetTypeAttr()
		for i in range(self.attr[7]):
			id = self.typeinfo.GetVarDesc(i)[0]
			attributes.append(self.typeinfo.GetNames(id)[0])
		for i in range(self.attr[6]):
			id = self.typeinfo.GetFuncDesc(i)[0]
			attributes.append(self.typeinfo.GetNames(id)[0])
		#self.SetupAllInfoTypes()
	return attributes
</t>
<t tx="pap.120703001453.909">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=


def getMembers(self, pos):
	"Get all the members of this object"	
	try:	
		realPos, isMethod = self._GetRealMemberPos(pos)
	except:
		print "oops!"
		return [None]
	if isMethod:
		id = self.typeinfo.GetFuncDesc(realPos)[0]
		names = self.typeinfo.GetNames(id)
		return names[1:]
	else:
		return [None]

</t>
<t tx="pap.120703001453.910">&lt;&lt; class TypeBrowseDialog methods &gt;&gt;=

def getAll(self):
	"Get all the types"
	all = []
	n = self.tlb.GetTypeInfoCount()
	for i in range(n):
		all.append(self.tlb.GetDocumentation(i)[0])
	return all
</t>
<t tx="pap.120703001453.911">&lt;&lt; tlbrowse methods &gt;&gt;=

class VBControlObject(object):
	"""Represents a VB control object"""
	
	&lt;&lt; VBControlObject methods &gt;&gt;

</t>
<t tx="pap.120703001453.912">&lt;&lt; VBControlObject methods &gt;&gt;=

def __init__(self, name, properties=None, methods=None):
	"""Initialize the control"""
	self.name = name
	self.properties = properties or {}
	self.methods = methods or {}</t>
<t tx="pap.120703001453.913">&lt;&lt; VBControlObject methods &gt;&gt;=

def addProperty(self, name):
	"""Add a property"""
	self.properties[name] = name</t>
<t tx="pap.120703001453.914">&lt;&lt; VBControlObject methods &gt;&gt;=

def addMethod(self, method):
	"""Add a method"""
	self.methods[method.name] = method</t>
<t tx="pap.120703001453.915">&lt;&lt; VBControlObject methods &gt;&gt;=

def __repr__(self):
	"""Representation of this control"""
	return "VBControlObject('%s', %s, %s)" % (self.name, self.properties, self.methods)</t>
<t tx="pap.120703001453.916">&lt;&lt; tlbrowse methods &gt;&gt;=

class VBMethod(object):
	"""Represents a method of a control object"""
	
	&lt;&lt; VBMethod methods &gt;&gt;

</t>
<t tx="pap.120703001453.917">&lt;&lt; VBMethod methods &gt;&gt;=

def __init__(self, name, parameters=None):
	"""Initialize the method"""
	self.name = name
	self.parameters = parameters or []</t>
<t tx="pap.120703001453.918">&lt;&lt; VBMethod methods &gt;&gt;=

def __repr__(self):
	"""Representation of this method"""
	return "VBMethod('%s', %s)" % (self.name, self.parameters)</t>
<t tx="pap.120703001453.919">&lt;&lt; VBMethod methods &gt;&gt;=

def __str__(self):
"""String representation of this method"""
try:
	if self.parameters:
		return "%s(*%s*)" % (self.name, ", ".join([str(item) for item in self.parameters]))
	else:
		return "%s()" % (self.name,)
except:
	print "Failed on ", self.name</t>
<t tx="pap.120703001453.920">&lt;&lt; tlbrowse methods &gt;&gt;=

def enumerate(lst):
	"Mimic 2.3's enumerate function"
	return zip(xrange(sys.maxint), lst)</t>
<t tx="pap.120703001453.921">@c

import StringIO
rstFile = StringIO.StringIO(text)

from docutils.core import Publisher
from docutils.io import StringOutput, StringInput

pub = Publisher()
# Initialize the publisher
pub.source = StringInput(source=text)
pub.destination = StringOutput(encoding="utf-8")
pub.set_reader('standalone', None, 'restructuredtext')
pub.set_writer('html')
output = pub.publish()

print output</t>
<t tx="pap.120703001453.922">
from __future__ import generators

"""Some testing to see if we can clean up the file access"""


class Test(object):
	
	def __init__(self, dataset):
		self.data = dataset
		self._datastream = iter(self.data)
		self.input = self.next
		
	def __getattribute__(self, name):
		print "Get", name
		return super(Test, self).__getattribute__(name)
	
	def __iter__(self):
		print "Getting iterator"
		return self

	def next(self):
		print "In next"
		d = self._datastream[:]
		while d:
			print "Yielding", d[0]
			yield d.pop()

	def __getitem__(self, index):
		print "Getting item", index
		return self._datastream[index]
	
if __name__ == "__main__":
	f = Test(range(20))
	a, b, c = f
	
</t>
<t tx="pap.120703001453.923"></t>
<t tx="pap.120703001453.924"># Paul Rubin from c.l.py	

sign = cmp(0, step)
while cmp(start, stop) == sign:
	yield start
	start += step</t>
<t tx="pap.120703001453.925">On Sun, 27 Jul 2003 04:51:11 GMT, Paul Paterson &lt;paulpaterson@users.sourceforge.net&gt; wrote:

[...]

&gt;To my eye, the [:] or [0] spelling of this makes the code look more 
&gt;complex than necessary, but I think you are on to something because if 
&gt;you spell it,
&gt;
&gt;def change(x, y):
&gt;    x = 'new x'
&gt;    y.update('new y')
&gt;

For a general pointer, ISTM you want to be able to dereference it for both getting and setting.
The [:] or [0] syntax gets you that, and you could do it with p() for getting and p(val) for setting,
or p.getval() and p.update(), but all these get clumsy when you want to use the "pointer" on
both sides of an assignment statement, e.g.,

    p.update(p.getval()+' added text for target')

where you could write more readably (IMO),

    p.value = p.value + 'added text for target'

or
    p.v += 'added text for target'


Below is a class PNS that lets you spell as immediately above, using .value
(and .v for concise use) bound to a property that implements the accessing of
what's pointed/referred to. I gave it a somewhat informative __repr__ method also,
so the test prints better. As you will note, this is now separate from any particular
name space. Any object that supports getattr and/or setattr can be used. I also
threw in a permissions parameter to control read/write/delete. See nsother and math
in examples. Note also that a pointer may point to another pointer, allowing cascaded
dereferencing spelled p.v.v etc.

&gt;with the relevant changes to the Ptr class then it could certainly grow 
&gt;on me. The things I like are,
&gt;
&gt;- no new variable names in the 'change' function so it looks similar to 
&gt;the original code
&gt;- the mechanism for propogating changes to the caller scope is explicit
&gt;- 'y' can be passed on to another function if needed and things are 
&gt;still clear
&gt;
&gt;eg,
&gt;
&gt;def change(x, y):
&gt;     x = 'new x'
&gt;     change2(y)
&gt;
&gt;def change2(y):
&gt;     y.update('deep change in y')
&gt;
If you use PNS, that will be spelled

 def change(x, y):
      x = 'new x'
      change2(y)
 
 def change2(y):
      y.value = 'deep change in y'

See test() code below. I used your original class Namespace: pass as the main namespace.

&gt;
&gt;To do this using the original namespace approach gets a little tricky 
&gt;because you have to merge the namespaces as you go. The pointer idea 
&gt;flattens that structure.
&gt;

====&lt; pns.py &gt;==========================================================
class PNS(object):
    """
    Pointer to Name Space
    PNS instance holds ns ref and vname for access to ns.vname
    Read, write, delete access permitted if r,w,d in perms, respectively.
    Typical: ptr_to_x = PNS(ns, 'x')
    """
    __slots__ = 'ns vname ok_r ok_w ok_d'.split()
    class PNSError(Exception):
        def __init__(self, ptr, msg):
            Exception.__init__(self, '%s for %r' %(msg, ptr))
        
    def __init__(self, ns, vname, perms='rwd'):
        self.ns=ns; self.vname=vname
        self.ok_r = 'r' in perms
        self.ok_w = 'w' in perms
        self.ok_d = 'd' in perms
    def _getv(self):
        """Typical read access: x = ptr.value (x = ptr.v works too)"""
        if self.ok_r: return getattr(self.ns, self.vname)
        raise self.PNSError(self, 'Value read prohibited')
    def _setv(self, v):
        """Typical write access: ptr.value = 'new x' (ptr.v = 'new x' works too)"""
        if self.ok_w: setattr(self.ns, self.vname, v)
        else: raise self.PNSError(self, 'Value write prohibited')
    def _delv(self):
        """Typical del access: del ptr.value (del ptr.v works too)"""
        if self.ok_d: delattr(self.ns, self.vname)
        else: raise self.PNSError(self, 'Value deletion prohibited')
    value = v = property(_getv, _setv, _delv) # .v for short
    def __repr__(self): return '&lt;PNS ptr to %r of %r&gt;'%(self.vname, self.ns)

class Namespace(object): pass

def test():
    ns = Namespace()
    ns.x = 'x value'
    ns.y = 'y value' 
    print 'Before change:'
    print 'ns.x=%r, ns.y=%r' %(ns.x, ns.y)
    print 'Making pointer py point to ns.y ...'
    py = PNS(ns, 'y') # prefixing pointer names with 'p' is not mandatory, just mnemonic
    print 'ptr py=%r' % py
    
    def change(x, y): # prefixing pointer names with 'p' is not mandatory, just mnemonic
        x = 'new x'
        y.value = 'new y'

    print 'Calling change(ns.x, py) ...'
    change(ns.x, py)
    print 'After change:'
    print 'ns.x=%r, ns.y=%r' %(ns.x, ns.y)
    
    def change1(x, y):
        x = 'new x'
        change2(y)
    
    def change2(y):
        y.v = 'deep change in y'

    print 'Before change1/change2:'
    print 'ns.x=%r, ns.y=%r' %(ns.x, ns.y)
    change1(ns.x, py)
    print 'After calling change1(ns.x, py):'
    print 'ns.x=%r, ns.y=%r' %(ns.x, ns.y)
    
    pz = PNS(ns, 'z')
    print '\nNew pointer to non-existent ns.z:\n%r' % pz
    print 'Trying to access as yet nonexistent ns.z ...'
    try: ns.z
    except Exception, e: print '%s: %s'% (e.__class__.__name__,e)
    else: print 'ns.z accessed ok'
   
    print 'Passing pz to change(ns.x, pz)...'
    change(ns.x, pz)
    print 'Result: ns.x=%r, ns.z=%r' %(ns.x, ns.z)
    print '\nBefore deleting ns.y via py.v:'
    print 'ns.y=%r, py.v=%r' %(ns.y, py.v)
   
    print '\nDeleting ns.y by del py.value ...'
    del py.value
    print 'Trying to access ns.y ...'
    try: ns.y
    except Exception, e: print '%s: %s'% (e.__class__.__name__,e)
    else: print 'ns.y accessed ok'
   
    print '\nCreating nsother name space to put pz in as a value ...'
    nsother = type('AnotherNS',(),{})()
    print nsother
    nsother.pz = pz
    print 'Creating pointer ppz pointing to nsother.pz'
    ppz = PNS(nsother,'pz')
    print 'ppz = %r'% ppz
    print 'ppz.value = %r'% ppz.value
    print 'ppz.value.value = %r'% ppz.value.value
    print 'ppz.v.v= %r'% ppz.v.v
   
    print '\nDemo read-only pointer to pi in namespace math (the module) ...'
    import math
    ppi = PNS(math,'pi', 'r') # read only
    print 'math = %r' % math
    print 'ppi = %r' % ppi
    print 'ppi.v = %s' % ppi.v

    print '\nAttempting to set math.pi via ppi.v=3.14 (will work via math.pi, BTW !)'
    try: ppi.v = 3.14
    except Exception, e: print '%s: %s'% (e.__class__.__name__,e)
    else: print 'ppi.v set ok: %r' % ppi.v

if __name__ == '__main__':
    test()
========================================================================

Result of run:

[10:03] C:\pywk\clp&gt;pns.py
Before change:
ns.x='x value', ns.y='y value'
Making pointer py point to ns.y ...
ptr py=&lt;PNS ptr to 'y' of &lt;__main__.Namespace object at 0x007F9EC0&gt;&gt;
Calling change(ns.x, py) ...
After change:
ns.x='x value', ns.y='new y'
Before change1/change2:
ns.x='x value', ns.y='new y'
After calling change1(ns.x, py):
ns.x='x value', ns.y='deep change in y'

New pointer to non-existent ns.z:
&lt;PNS ptr to 'z' of &lt;__main__.Namespace object at 0x007F9EC0&gt;&gt;
Trying to access as yet nonexistent ns.z ...
AttributeError: 'Namespace' object has no attribute 'z'
Passing pz to change(ns.x, pz)...
Result: ns.x='x value', ns.z='new y'

Before deleting ns.y via py.v:
ns.y='deep change in y', py.v='deep change in y'

Deleting ns.y by del py.value ...
Trying to access ns.y ...
AttributeError: 'Namespace' object has no attribute 'y'

Creating nsother name space to put pz in as a value ...
&lt;__main__.AnotherNS object at 0x007F92C0&gt;
Creating pointer ppz pointing to nsother.pz
ppz = &lt;PNS ptr to 'pz' of &lt;__main__.AnotherNS object at 0x007F92C0&gt;&gt;
ppz.value = &lt;PNS ptr to 'z' of &lt;__main__.Namespace object at 0x007F9EC0&gt;&gt;
ppz.value.value = 'new y'
ppz.v.v= 'new y'

Demo read-only pointer to pi in namespace math (the module) ...
math = &lt;module 'math' (built-in)&gt;
ppi = &lt;PNS ptr to 'pi' of &lt;module 'math' (built-in)&gt;&gt;
ppi.v = 3.14159265359

Attempting to set math.pi via ppi.v=3.14 (will work via math.pi, BTW !)
PNSError: Value write prohibited for &lt;PNS ptr to 'pi' of &lt;module 'math' (built-in)&gt;&gt;

[10:03] C:\pywk\clp&gt;

&gt;
&gt;Thanks for these thoughts and the time it took to post them, they really 
&gt;made me think! (I mean that in a good way, of course ;) )
&gt;
You're welcome. Hope this adds another useful angle.

Regards,
Bengt Richter</t>
<t tx="pap.120703001453.926">   
Groups    
 Advanced Groups Search    Preferences    Groups Help  
  
  
Groups search result 12 for    
 
 
 Java Imaging Applets  Snowbound's Java applets to view, zoom, rotate images over the Web.  snowbound.com Sponsored Links 
 
 Customized C# Training  Hands-on, C# training classes delivered on-site for your group.  www.accelebrate.com 
 C# Design Training  Hands On &amp; Real World Training From the experts at TrainingCity  www.TrainingCity.com 
 
 
From: Sean Ross (sross@connectmail.carleton.ca)
Subject: Re: Howto MACRO in python ? 
View: Complete Thread (15 articles)  
Original Format 
Newsgroups: comp.lang.python
Date: 2003-08-12 15:40:26 PST 
 

"Bengt Richter" &lt;bokr@oz.net&gt; wrote in message
news:bhbhsm$2vv$0@216.39.172.122...
&gt; maybe there ought to be a magic __self__ in the local namespace of a
function?

I've played with trying to get something like that, but I haven't got
anything reliable[1]. So far I have a very simple function that retrieves
the calling function object:

import inspect

class ThisResolutionError(Exception): pass

def this():
    fname = inspect.currentframe(1).f_code.co_name
    frameno = 2
    func = None
    while func is None:
        try:
            func = inspect.currentframe(frameno).f_locals.get(fname, None)
            frameno += 1
        except ValueError:
            # reached end of call stack
            raise ThisResolutionError, "could not resolve %s" % fname
    return func


So, when it works (which is not always), you can do things like:

def f():
    "f's doc string"
    __self__ = this()
    print __self__.__name__
    print __self__.__doc__
    print __self__.__dict__

    def g():
         __self__ = this()
         print "called nested function %s" % __self__.__name__
    g()


f.f_attr = "function attribute"
f()

-------------------output ----------------------
f
f's doc string
{'f_attr': 'function attribute'}
called nested function g



I would be interested to see something more general - something that could
be called inside of any namespace (at the module, class, method, or function
level) which you could then (atleast) query and (possibly) modify. Why would
I want to do that? Fun, mostly. I like the idea of being able to query any
object while being inside the object.

+1  __self__

Sean


[1] this() will not work in methods, and there can be issues if you put it
in nested functions

#
# you can do this (if you want)
#
def f():
    __self__ = this()
    def g():
         print "called nested function g"
    __self__.g  = g

f()
f.g()

----------------------
called nested function g

#
# but not this (the reason for which should be obvious)
#
def f():
    __self__ = this()
    def g():
         __self__ = this()
         print "called nested function %s" % __self__.__name__
    __self__.g  = g

f()
f.g()

-------------------------
ThisResolutionError: could not resolve g
Post a follow-up to this message



--------------------------------------------------------------------------------
Google Home - Advertise with Us - Business Solutions - Services &amp; Tools - Jobs, Press, &amp; Help 

2003 Google</t>
<t tx="pap.120703001453.927">From: Robin Munn (rmunn@pobox.com)
Subject: Re: Finding the path to a file 
 
  
View this article only 
Newsgroups: comp.lang.python
Date: 2003-08-12 10:34:03 PST 
 

Todd Johnson &lt;overdrive_ss@yahoo.com&gt; wrote:
&gt; So basically, I want to know how to find the directory
&gt; my script is in, even when it is invoked from another
&gt; directory. Any help would be greatly appreciated.

Basically, you want to use sys.argv[0] -- but make sure to call
os.path.abspath() on it first. Try this:

--- begin sample code ---
#!/usr/bin/python

import os, sys

print "sys.argv[0] is", sys.argv[0]
print "os.path.abspath(sys.argv[0]) is", os.path.abspath(sys.argv[0])

mypath, myname = os.path.split(os.path.abspath(sys.argv[0]))

print "Script name is", myname
print "Script path is", mypath
---- end sample code ----

I can run this in a variety of ways and get the same value for mypath:

--- begin transcript ---
[rmunn@localhost ~/tmp]$ ./test.py
sys.argv[0] is ./test.py
os.path.abspath(sys.argv[0]) is /home/rmunn/tmp/test.py
Script name is test.py
Script path is /home/rmunn/tmp
[rmunn@localhost ~/tmp]$ python test.py
sys.argv[0] is test.py
os.path.abspath(sys.argv[0]) is /home/rmunn/tmp/test.py
Script name is test.py
Script path is /home/rmunn/tmp
[rmunn@localhost ~/tmp]$ cd ..
[rmunn@localhost ~]$ python tmp/test.py
sys.argv[0] is tmp/test.py
os.path.abspath(sys.argv[0]) is /home/rmunn/tmp/test.py
Script name is test.py
Script path is /home/rmunn/tmp
[rmunn@localhost ~]$ python /home/rmunn/tmp/test.py
sys.argv[0] is /home/rmunn/tmp/test.py
os.path.abspath(sys.argv[0]) is /home/rmunn/tmp/test.py
Script name is test.py
Script path is /home/rmunn/tmp
---- end transcript ----

Hope this helps.

-- 
Robin Munn &lt;rmunn@pobox.com&gt; | http://www.rmunn.com/ | PGP key 0x6AFB6838
-----------------------------+-----------------------+----------------------
"Remember, when it comes to commercial TV, the program is not the product.
YOU are the product, and the advertiser is the customer." - Mark W. Schumann
Post a follow-up to this message
</t>
<t tx="pap.120703001453.928">http://www.kode-fu.com/rosetta/string_funcs_main.html
</t>
<t tx="pap.120703001453.929">@ignore
</t>
<t tx="pap.120703001453.930">@root vbparser.py
@ignore
import re
from test import txt2

line = "^(.*)$"
m_line = re.compile(line, re.MULTILINE)


def processLineConcatenation(txt):
	"""Removes line concatenations"""
	line_ends = re.compile("\s_\s*\n", re.MULTILINE)
	return line_ends.sub(" ", txt)
	
</t>
<t tx="pap.120703001453.931">@root spexample.py
@ignore
declaration = r'''# note use of raw string when embedding in python code...
file           :=  [ \t\n]*, section+
section        :=  '[',identifier,']', ts,'\n', body
body           :=  statement*
statement      :=  (ts,';',comment,'\n')/equality/nullline
nullline       :=  ts,'\n'
comment        :=  -'\n'*
equality       :=  ts, identifier,ts,'=',ts,identified,ts,'\n'
identifier     :=  [a-zA-Z], [a-zA-Z0-9_]*
identified     :=  ('"',string,'"')/number/identifier
ts             :=  [ \t]*
char           :=  -[\134"]+
number         :=  [0-9eE+.-]+
string         :=  (char/escapedchar)*
escapedchar    :=  '\134"' / '\134\134'
'''
testdata = '''[test1]
	val=23
	val2="23"
	wherefore="art thou"
	; why not
	log = heavy_wood

[test2]
loose=lips

'''
from simpleparse import generator
try:
	from TextTools import TextTools
except ImportError:
	from mx.TextTools import TextTools
import pprint

parser = generator.buildParser( declaration ).parserbyname( 'file' )
pprint.pprint( TextTools.tag( testdata, parser ))
</t>
<t tx="pap.120703001453.932">@root test/testparser.py
@ignore
import unittest

&lt;&lt; Test classes &gt;&gt;

if __name__ == "__main__":
	unittest.main()</t>
<t tx="pap.120703001453.933">&lt;&lt; Test classes &gt;&gt;=

import vb2py.vbparser

class TestLines(unittest.TestCase):
	"""Test line operations"""
	
	def testLCNoConcat(self):
		"""concatenation with no concats"""
		lines = \
"""
a=1
b=2
c=3
d=4
"""
		
		self.assertEqual(lines, vb2py.vbparser.processLineConcatenation(lines))
		
	def testLCConcat(self):
		"""concatenation with concats"""
		lines = \
"""
a=1
b= _
200
c=3 
d= _
another bit
ksksks
lksks
this is    _    
quite hard _
to do in _     one
go
"""
		properlines = \
"""
a=1
b= 200
c=3 
d= another bit
ksksks
lksks
this is    quite hard to do in _     one
go
"""
		
		self.assertEqual(properlines, vb2py.vbparser.processLineConcatenation(lines))</t>
<t tx="pap.120703001453.934">&lt;&lt; Test classes &gt;&gt;=

class TestSubFnBlock(unittest.TestCase):
	"""Check we can pull out sub and function blocks"""
	
	def testSub(self):
		"""decompose single sub"""
		&lt;&lt; Single sub &gt;&gt;
		self.assertEqual(answer, vb2py.vbparser.splitSubFnBlock(text))
</t>
<t tx="pap.120703001453.935">@c

text = """
blah blah
blah

	Public Sub x(a, b, c)
		This is some
		This is some more
	wow
	a+b
	End Sub x

"""

answer = (
"	Public Sub x(a, b, c)",
""""
		This is some
		This is some more
	wow
	a+b
"""
)</t>
<t tx="pap.120703001453.936">@root vbcode.py
@ignore
&lt;&lt; Documentation &gt;&gt;
&lt;&lt; Declarations &gt;&gt;
&lt;&lt; VBCode classes &gt;&gt;

if __name__ == "__main__":
	text = open("vb\\test1\\test.bas", "r").read()
	m = BaseModule()
	m.initFromText(text)
	for v in m.public_names:
		print "Public ", v.name, v.vartype
	for v in m.private_names:
		print "Private ", v.name, v.vartype		</t>
<t tx="pap.120703001453.937">"""
This module implements a set of classes for describing VB code. The structure is,

- namespace
- module
- function
- block
- line
- variable

- modules, form modules and classes all inherit from BaseModule
- subs and functions all inherit from BaseFunction
- For, While, Do, Select blocks all inherit from BaseBlock

"""</t>
<t tx="pap.120703001453.938">@c

import re
from Plex import *
from StringIO import StringIO</t>
<t tx="pap.120703001453.939">&lt;&lt; VBCode classes &gt;&gt;=

class BaseVariable(object):
	"""A representation of a VB object"""
	
	&lt;&lt; BaseVariable methods &gt;&gt;</t>
<t tx="pap.120703001453.940">&lt;&lt; BaseVariable methods &gt;&gt;=

def __init__(self, name, vartype=""):
	"""Initialize the variable"""
	if vartype == "":
		vartype = "Variant"
	self.name = name
	self.vartype = vartype</t>
<t tx="pap.120703001453.941">&lt;&lt; VBCode classes &gt;&gt;=

class BaseNameSpace(object):
	"""A representation of a VB namespace"""
	
	&lt;&lt; BaseNameSpace declarations &gt;&gt;
	&lt;&lt; BaseNameSpace methods &gt;&gt;</t>
<t tx="pap.120703001453.942">@c

letter = Range("AZaz")
digit = Range("09")
name = letter + Rep(letter | digit)
number = Rep1(digit)
space = Any(" \t\n")
delim = Str(",") + Opt(space)

scope = Str("Dim") | Str("Private") | Str("Public")
const = Str("Const")

array = Str("(") + Rep(name + Rep(delim + name))  + Str(")")	
var_with_type = name + Opt(array) + space + Opt(Str("As") + space + name)
var_with_no_type = name + Opt(array)

var = var_with_type | var_with_no_type	
declare = scope + space + var + Rep(delim + var_with_type) + Eol

lexicon = Lexicon([
	(declare, "declare"),
	(Str("\n"), ""),
])

sub_lex = Lexicon([
	(scope, "scope"),
	(var_with_type, "type"),
	(delim, ""),
	(space, ""),
	(const, "const"),
	(Eol, ""),
])</t>
<t tx="pap.120703001453.943">&lt;&lt; BaseNameSpace methods &gt;&gt;=

def __init__(self, name="Namespace"):
	"""Initialize the module"""
	self.public_names = []
	self.private_names = []
</t>
<t tx="pap.120703001453.944">&lt;&lt; BaseNameSpace methods &gt;&gt;=

def initVariablesFromText(self, text):
	"""Initialize the variables from some text"""
	#
	# Declares
	s = StringIO(text)
	scan = Scanner(self.lexicon, s)
	while 1:
		tok = scan.read()
		print tok
		if tok[0] == "declare":
			v = StringIO(tok[1])
			inner_scan = Scanner(self.sub_lex, v)
			while 1:
				inner_tok = inner_scan.read()
				print inner_tok
				if inner_tok[0] is None:
					break
		if tok[0] is None:
			break
			

</t>
<t tx="pap.120703001453.945">&lt;&lt; VBCode classes &gt;&gt;=

class BaseModule(BaseNameSpace):
	"""A representation of a VB module"""
	
	&lt;&lt; BaseModule methods &gt;&gt;</t>
<t tx="pap.120703001453.946">&lt;&lt; BaseModule methods &gt;&gt;=

def __init__(self, *args, **kw):
	"""Initialize the module"""
	super(BaseModule, self).__init__(*args, **kw)
	self.functions = []</t>
<t tx="pap.120703001453.947">&lt;&lt; BaseModule methods &gt;&gt;=

def initFromText(self, text):
	"""Initialize the structure from some text"""
	self.initVariablesFromText(text)
	self.initFunctionsFromText(text)</t>
<t tx="pap.120703001453.948">&lt;&lt; BaseModule methods &gt;&gt;=

def initFunctionsFromText(self, text):
	"""Initialize the functions from some text"""
</t>
<t tx="pap.120703001453.949">par_expression ::= 
             (l_bracket, par_expression, r_bracket) / base_expression

base_expression ::= 
             simple_expr, (operation, par_expression)?
</t>
<t tx="pap.120703001453.950"></t>
<t tx="pap.120703001453.951">@doc
We have to look for VB events and change their names so that they map on to the PythonCard ones. This is a bit of guesswork really. We have to look for controls we understand and then likely looking candidates!
@c

controls = self.form._getControlList()

name_munger = re.compile(r'(.*)_(.*)')

for sub in self.subs:
	name_match = name_munger.match(sub.name)
	if name_match:
		munged_name = "vbobj_%s" % name_match.groups()[0]
		if munged_name in controls and event_translator.has_key(name_match.groups()[1]):
			print "Looks like", munged_name, name_match.groups()[1]
			sub.name = "on_%s_%s" % (name_match.groups()[0], 
									 event_translator[name_match.groups()[1]])
			sub.args = "event"
	
</t>
<t tx="pap.120703001453.952">&lt;&lt; VBConverter &gt;&gt;=

class VBCodeBlock:
	"""Base class for all VB code blocks (subs and fns)"""
	
	&lt;&lt; VBCodeBlock declarations &gt;&gt;
	&lt;&lt; class VBCodeBlock methods &gt;&gt;
	

</t>
<t tx="pap.120703001453.953">@c

translations = {
		r'(?&lt;=\s)If(?=\s+)' : 'if',
		r'(?&lt;=\s)Else(?=\s+)' : 'else',
		r'(?&lt;=\s)ElseIf(?=\s+)' : 'elif',
		r'(?&lt;=\s)Then(?=\s+)' : ':',
		r'(?&lt;=\s)&amp;(?=\s+)' : '+',
		r'(?&lt;=\s)End [Ii]f(?=\s+)' : '',
		r'(?&lt;=\W)CInt(?=\W)' : 'int',
		r'(?&lt;=\W)CStr(?=\W)' : 'str',
}</t>
<t tx="pap.120703001453.954">&lt;&lt; class VBCodeBlock methods &gt;&gt;=

def __init__(self, code_type, scope, name, args, code):
	"""Initialise the code block"""
	self.code_type = code_type
	self.scope = scope
	self.name = name
	self.args = args
	self.code = code</t>
<t tx="pap.120703001453.955">&lt;&lt; class VBCodeBlock methods &gt;&gt;=

def convertCode(self, form):
	"""Convert the code from VB to Python"""
	#
	if Config["General", "UseFullParser"] == "Yes":
		#
		# Finally perform the conversion
		try:
			m = vbparser.parseVB(self.code)
			self.code = m.renderAsCode(indent=1)
		except vbparser.VBParserError:
			self.code = "# Untranslated!\n" + self.code
	else:
		&lt;&lt; Translate VB keywords &gt;&gt;
		self.code = self.code.replace("'", "#") # Comments
		if self.code_type == "Function":
			&lt;&lt; Add return &gt;&gt;
</t>
<t tx="pap.120703001453.956">@c

for pattern, replace in self.translations.iteritems():
	self.code = re.sub(pattern, replace, self.code) 
</t>
<t tx="pap.120703001453.957">@doc
VB functions do not have returns, you set the name of the function to the value you want to return. This makes our job easy because we just tag a line on the end of the function.
@c

self.code += "\nreturn %s" % self.name</t>
<t tx="pap.120703001453.958">&lt;&lt; class VBCodeBlock methods &gt;&gt;=

def mapNamespaces(self, form, subs, fns):
	"""Map the namespaces from VB onto the Python ones"""
	&lt;&lt; Map control names &gt;&gt;
	&lt;&lt; Map sub and fn names &gt;&gt;

</t>
<t tx="pap.120703001453.959">@doc
In VB all the control names are in the local namespace of the form. In PythonCard we need to point them to the namespace of self.components.
@c

for control in form._getControlList():
	obj = form._get(control)
	pattern = re.compile(r'(?&lt;=\W)%s(?:(?:\.(\w+))|(?=(\W+)))' % obj._realName())
	self.code = pattern.sub(obj._mapNameReference, self.code)</t>
<t tx="pap.120703001453.960">@doc
In VB all the sub and fn names are in the local namespace of the form. In PythonCard we need to point them to the namespace of self.components.
@c

for block in subs + fns:
	pattern = re.compile(r'(?&lt;=\W)%s(?:(?:\.(\w+))|(?=(\W(?!=))))' % block.name)
	self.code = pattern.sub('self.%s' % block.name, self.code)</t>
<t tx="pap.120703001453.961">&lt;&lt; VBConverter &gt;&gt;=

class VBBaseControl:
	"""Base class for all VB controls"""
	
	pycard_name = "VBControl"
	is_container = 0 # 1 for container classes like frames
	
	_attribute_translations = { 
				"Visible" : "visible",
				"BackColor" : "backgroundColor",
				"ForeColor" : "foregroundColor",
				"ToolTipText" : "toolTip",
				}
	
	&lt;&lt; class VBControl methods &gt;&gt;
	

</t>
<t tx="pap.120703001453.962">&lt;&lt; class VBControl methods &gt;&gt;=

def _getPropertyList(cls):
	"""Return a list of the properties of this control"""
	items = []
	for item in dir(cls):
		if not (item.startswith("_") or item.startswith("vbobj_")):
			items.append(item)
	return items
		
_getPropertyList = classmethod(_getPropertyList)		</t>
<t tx="pap.120703001453.963">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlList(cls):
	"""Return a list of the controls contained in this control"""
	items = []
	for item in dir(cls):
		if not item.startswith("_") and item.startswith("vbobj_"):
			items.append(item)
	return items
		
_getControlList = classmethod(_getControlList)		</t>
<t tx="pap.120703001453.964">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlsOfType(cls, type_name):
	"""Return a control with a given type"""
	lst = []
	for item in dir(cls):
		if not item.startswith("_") and item.startswith("vbobj_"):
			obj = cls._get(item)
			if obj.pycard_name == type_name:
				lst.append(obj)
	return lst
		
_getControlsOfType = classmethod(_getControlsOfType)		</t>
<t tx="pap.120703001453.965">&lt;&lt; class VBControl methods &gt;&gt;=

def _getContainerControls(cls):
	"""Return all container controls"""
	lst = []
	for item in dir(cls):
		if not item.startswith("_"):
			obj = cls._get(item)
			try:
				is_container = obj.is_container
			except AttributeError:
				pass
			else:
				if is_container:
					lst.append(obj)
	return lst
		
_getContainerControls = classmethod(_getContainerControls)</t>
<t tx="pap.120703001453.966">&lt;&lt; class VBControl methods &gt;&gt;=

def _get(cls, name, default=None):
	"""Get one of our items"""
	try:
		return getattr(cls, name)
	except AttributeError:
		if default is not None:
			return default
		else:
			raise
	
_get = classmethod(_get)</t>
<t tx="pap.120703001453.967">&lt;&lt; class VBControl methods &gt;&gt;=

def _realName(cls):
	"""Return our real name"""
	return cls.__name__[6:]
	
_realName = classmethod(_realName)</t>
<t tx="pap.120703001453.968">&lt;&lt; class VBControl methods &gt;&gt;=

def _getControlEntry(cls):
	"""Return the pycard representation of this object"""
	#
	# Get dictionary entries for this object
	d = {}
	ret = [d]
	d['name'] = cls._realName()
	d['position'] = (cls.Left/twips_per_pixel, cls.Top/twips_per_pixel)
	d['type'] = cls.pycard_name
	#
	for attr, pycard_attr in cls._attribute_translations.iteritems():
		if hasattr(cls, attr):
			d[pycard_attr] = getattr(cls, attr)
			
	d.update(cls._getClassSpecificControlEntries())
	#
	# Watch out for container objects - we have to recur down them
	if cls.is_container:
		cls._processChildObjects()
		for cmp in cls._getControlList():
			obj = cls._get(cmp)
			entry = obj._getControlEntry()
			if entry:
				ret += entry
	return ret
	
_getControlEntry = classmethod(_getControlEntry)</t>
<t tx="pap.120703001453.969">&lt;&lt; class VBControl methods &gt;&gt;=

def _getClassSpecificControlEntries(cls):
	"""Return additional items for this entry
	
	This method is normally overriden in the subclass
	
	"""
	return {}
		
_getClassSpecificControlEntries = classmethod(_getClassSpecificControlEntries)

</t>
<t tx="pap.120703001453.970">&lt;&lt; class VBControl methods &gt;&gt;=

def _mapNameReference(cls, match):
	"""Map a reference to this object in code to something meaningful
	
	We have two issues, scope and attributes. The scope we need to map to self.components
	That was easy. But we also need to map attributes. We can't do that in the base class
	but a subclass can hopefully help us out via the _attributeTranslationClass
	
	"""
	if match.groups()[0] is not None:
		return "self.components.%s.%s" % (cls._realName(), 
										  cls._attributeTranslation(match.groups()[0]))
	else:
		return "self.components.%s" % (cls._realName(),)
		

_mapNameReference = classmethod(_mapNameReference)</t>
<t tx="pap.120703001453.971">&lt;&lt; class VBControl methods &gt;&gt;=

def _attributeTranslation(cls, name):
	"""Convert a VB attribute to a Python one"""
	try:
		return cls._attribute_translations[name]
	except KeyError:
		return VBControl._attribute_translations.get(name, name)
	
_attributeTranslation = classmethod(_attributeTranslation)	</t>
<t tx="pap.120703001453.972">&lt;&lt; class VBControl methods &gt;&gt;=

def _processChildObjects(cls):
	"""Before we deal with our child object we get a chance to do some processing
	
	Sub-classed can use this to do special things, like frames adjusting the
	properties of our children
	
	"""
	for container in cls._getContainerControls():
		container._processChildObject()
	
_processChildObjects = classmethod(_processChildObjects)</t>
<t tx="pap.120703001453.973">&lt;&lt; VB Classes &gt;&gt;=

"""
Copyright 2003 Jacob Halln
This is a work of fiction which may be used, reproduced and modified in any 
way
anyone sees fit.
"""

class Collection(dict):
    """
    An implementation of Visual Basic Collections.
    This implementation assumes that indexing by integers is rare and
    that memory is a less scarce resource than CPU time.
    """
    def __init__(self):
        dict.__init__(self)
        # self.insertOrder is used as the relative index when the collection
        # is treated as an array.
        # It is also used as the dictionary key for entries that have no
        # assigned key. This always works because VB keys can only be strings. 
        self.insertOrder = 1
        
    def __setitem__(self, key, value):
        if isinstance(key, int):
            raise TypeError("Index must be a non-numeric string")
        if key is None:
            key = self.insertOrder
        dict.__setitem__(self, key, (value, self.insertOrder, key))
        self.insertOrder += 1

    def __getitem__(self, key):
        try:
            key = int(key)
            if key &lt; 1:
                raise IndexError
            list = self.values()
            list.sort(self._order)
            return list[key-1][0]
        except ValueError:
            return dict.__getitem__(self, key)[0]

    def __delitem__(self, key):
        try:
            key = int(key)
            list = self.values()
            list.sort(self._order)
            _, _, key = list[key-1]
        except ValueError:
            pass
        dict.__delitem__(self, key)
        
    def _order(self, a, b):
        # Equality is impossible
        if a[1] &lt; b[1]:
            return -1
        else:
            return 1

    def _getElement(self, key):
        if isinstance(key, int):
            list = self.values()
            list.sort(self._order)
            return list[key-1]
        else:
            return dict.__getitem__(self, key)

    def Count(self):
        """
        Returns the number of items in the collection
        """
        return len(self)

    def Add(self, value, key=None, **kw):
        """
        Add's an item with an optional key. The item can also be added
        before or after an existing item. The before/after parameters
        can either be integer indices or keys.
        **kw can contain
        - key
        - before
        - after
        before and after exclude each other
        """
        #try:
        #    key = kw['key']
        #except KeyError:
        #    key = None
            
        if not kw.has_key('before') and not kw.has_key('after'): 
            self[key] = value

        elif kw.has_key('before') and not kw.has_key('after'):
            _, order, _ = self._getElement(kw['before'])
            for k, entry in self.iteritems():
                if entry[1] &gt;= order:
                    dict.__setitem__(self, k, (entry[0], entry[1]+1, k))
            if not isinstance(key, str):
                key = self.insertOrder
            dict.__setitem__(self, key, (value, order, key))
            self.insertOrder += 1

        elif kw.has_key('after') and not kw.has_key('before'):
            _, order, _ = self._getElement(kw['after'])
            for k, entry in self.iteritems():
                if entry[1] &gt; order:
                    dict.__setitem__(self, k, (entry[0], entry[1]+1, k))
            if not isinstance(key, str):
                key = self.insertOrder
            dict.__setitem__(self, key, (value, order+1, key))
            self.insertOrder += 1

        else:
            raise Error("Can't specify both 'before' and 'after' parameters.")

    def Item(self, key):
        """
        Returns the item specified by the index, which can either be a
        numerical index or a key.
        """
        self.__getitem__(key)

    def Remove(self, key):
        """
        Removes the item specified by the index, which can either be a
        numerical index or a key.
        """
        self.__delitem__(key)
    
if __name__ == '__main__':
    # Tests
    c = Collection()
    c['a'] = 'va'
    c['b'] = 'vb'
    print c['a']
    print c[2]
    del c[1]
    print c[1]

    c[None] = 'vc'
    print c

    c.add('xx')
    print c
    c.add('yy', before=1)
    print c
    print c[1]
    print c.count()
</t>
<t tx="pap.120703001453.974"></t>
<t tx="pap.120703001453.975">@root vbbutton.py
@ignore

import vb2py.targets.pythoncard.controlclasses as controlclasses
import vb2py.logger
log = vb2py.logger.getLogger("VBButton")

import button
from wxPython import wx
import sys
from PythonCardPrototype import binding, event, registry, widget

class VBButton(object):
	"""VB Button Control"""
	
	proxy_for = None
	
	def __init__(self, *args, **kw):
		log.debug("In __init__")
		self.__dict__["proxy_for"] = button.Button(*args, **kw)
		
	def __getattr__(self, name):
		log.debug("In __getattr__" + name)
		if name.startswith("_get"):
			raise AttributeError
		if hasattr(self, "_get%s" % name):
			log.debug("Getting %s" % (name, ))
			ret = getattr(self, "_get%s" % name)()
			log.debug("Done")
			return ret
		else:
			return getattr(self.proxy_for, name)
		
	def __setattr__(self, name, value):
		log.debug("In __setattr__" + name)
		if hasattr(self, "_set%s" % name):
			log.debug("Setting %s = %s" % (name, value))
			getattr(self, "_set%s" % name)(value)
			log.debug("Done")
		else:
			setattr(self.proxy_for, name, value)

	def _getTop(self):
		"""Get the Top"""
		return self.position[1]
		
	def _setTop(self, value):
		"""Set the Top"""
		self.position = [self.position[0], value]
		
	def _getLeft(self):
		"""Get the Left"""
		return self.position[0]
		
	def _setLeft(self, value):
		"""Set the Left"""
		self.position = [value, self.position[1]]
		
	def _getHeight(self):
		"""Get the Height"""
		return self.size[1]
		
	def _setHeight(self, value):
		"""Set the Height"""
		self.size = [self.size[0], value]
		
	def _getWidth(self):
		"""Get the Width"""
		return self.size[0]
		
	def _setWidth(self, value):
		"""Set the Width"""
		self.size = [value, self.size[1]]



VBButton._spec = button.Button._spec		
VBButton._spec.name = "VBButton"	


log.debug("Registering VBButton as '%s'" % sys.modules[__name__].VBButton)
registry.getRegistry().register( sys.modules[__name__].VBButton )
</t>
<t tx="pap.120703001453.976">@root vbbutton.py

import vb2py.targets.pythoncard.controlclasses as controlclasses
import vb2py.logger
log = vb2py.logger.getLogger("VBButton")

import button
from wxPython import wx
import sys
from PythonCardPrototype import binding, event, registry, widget

class VBButton(object):
	"""VB Button Control"""
	
	proxy_for = None
	
	def __init__(self, *args, **kw):
		log.debug("In __init__")
		self.__dict__["proxy_for"] = button.Button(*args, **kw)
		
	def __getattr__(self, name):
		log.debug("In __getattr__" + name)
		return getattr(self.proxy_for, name)
		
	def __setattr__(self, name, value):
		log.debug("In __setattr__" + name)
		setattr(self.proxy_for, name, value)

	def _getTop(self):
		"""Get the Top"""
		return self.position[1]
		
	def _setTop(self, value):
		"""Set the Top"""
		self.position = [self.position[0], value]
		
	Top = property(fget=_getTop, fset=_setTop)
	
	def _getLeft(self):
		"""Get the Left"""
		return self.position[0]
		
	def _setLeft(self, value):
		"""Set the Left"""
		self.position = [value, self.position[1]]

	Left = property(fget=_getLeft, fset=_setLeft)
		
	def _getHeight(self):
		"""Get the Height"""
		return self.size[1]
		
	def _setHeight(self, value):
		"""Set the Height"""
		self.size = [self.size[0], value]

	Height = property(fget=_getHeight, fset=_setHeight)
		
	def _getWidth(self):
		"""Get the Width"""
		return self.size[0]
		
	def _setWidth(self, value):
		"""Set the Width"""
		self.size = [value, self.size[1]]

	Width = property(fget=_getWidth, fset=_setWidth)


VBButton._spec = button.Button._spec		
VBButton._spec.name = "VBButton"	


log.debug("Registering VBButton as '%s'" % sys.modules[__name__].VBButton)
registry.getRegistry().register( sys.modules[__name__].VBButton )
</t>
<t tx="pap.120703001453.977">@root testparse.py

txt = """
Dim myvar As Integer
Dim x(10) As String, b(10, MAXINT) As Single
Public secret

Public Sub DoIt(x, y, z As String)
	' Do some work
	Dim locVar As Integer
	Dim i, j, k
	'
	locVar = 0
	If x &lt; 10 Then
		locVar = y
	ElseIf x &gt; 20 Then
		locVar = y/2.0
	ElseIf z = 43 Then
		locVar = Nothing
		anotherVar = 21
		If Time = "Out" Then
			a = Failed
			b = Quit
		Else
			If Now = "Today" Then
				c = "Yes"
			End If
		End If
	Else
		locVar = z
	End If
	doACall(locVar)
	locVar = locVar*2/24
	locString = (locVar+2) &amp; (locVar-(2/(10-3)))
	'
End Sub

"""

</t>
<t tx="pap.120703001453.978">@nocolor</t>
<t tx="pap.120703001453.979">@root doc/__init__.py

pass</t>
<t tx="pap.120703001453.980"></t>
<t tx="pap.120703001453.981">vb2Py User Guide
================

This is the user guide for v0.2 of vb2Py. 

**Important** If you installed v0.1, or the CVS version, prior to v0.2 please remove the old directories completely before installing v0.2. Changes in the package (in particular the renaming of ``vb2py.py``) **will** causes problems. Sorry for the confusion!

* `Installation instructions`_
* `Command line usage`_
* `GUI usage`_
* `Reference manual`_
* `List of all options`_

About_ this document.


.. _`Installation instructions`: installation.html
.. _`Command line usage`: commandline.html
.. _`GUI usage`: gui.html
.. _`Reference manual`: reference.html
.. _`List of all options`: optionslist.html

.. _About: about.html</t>
<t tx="pap.120703001453.982">vb2Py Reference Manual
======================

**Simple Statements**

* Assignment_
* Set_

**Compound Statements**

* If_
* Select_
* With_
* `Do ... Loop`_
* `While ... Wend`_
* `For (Each) ... Next`_

**Definitions**

* `Dim and Redim`_
* Sub_
* Function_
* Type_
* Enumerations_

**Modules**

* `Form modules`_
* `Class modules`_
* `Code modules`_

**Unsupported Elements**

* Labels_
* `On Error ...`_

**Other**

* `#If directives`_
* `VB Constants`_
* `General Options`_
* `Plug-ins`_
* `VB Control Properties and Methods`_



.. _Assignment: assignment.html
.. _Set: set.html

.. _Select: select.html
.. _If: if.html
.. _With: with.html
.. _`Do ... Loop`: doloop.html
.. _`While ... Wend`: while.html
.. _`For (Each) ... Next`: for.html
.. _Enumerations: enumerations.html

.. _Type: type.html
.. _Sub: sub.html
.. _Function: function.html
.. _`Dim and Redim`: dim.html

.. _`Class modules`: classmodules.html
.. _`Form modules`: formmodules.html
.. _`Code modules`: codemodules.html

.. _Labels: unsupported.html
.. _`On Error ...`: unsupported.html

.. _`#If directives` : ifdirective.html
.. _`VB Constants`: vbconstants.html
.. _`General Options`: optionslist.html
.. _`Plug-ins`: notimplemented.html
.. _`VB Control Properties and Methods`: vbcontrols/index.html</t>
<t tx="pap.120703001453.983">&lt;STYLE TYPE="text/css"&gt;



h1.title {
}


h1 {
    font-size : 24;
    font-family : ariel;
    background-color : wheat;
    padding : 5;
	border-width : thin;
	border-style : solid;
	border-color : black;
    text-align : center;
}


h2 {
    font-size : 20;
    font-family : ariel;
    background-color : oldlace;
    padding : 5;
	border-width : thin;
	border-style : solid;
	border-color : black;
}


table {
    width : 100%;
}


th.code-header {
	border-width : thin;
	border-style : solid;
	border-color : black;
    background-color : rgb(191, 223, 255);
}


td.vb-code-cell {
    padding : 10;
    background-color : rgb(255, 255, 204);    
	border-width : thin;
	border-style : solid;
	border-color : black;
    vertical-align : middle;
    font-family : Courier;
    font-size : 12;
    width : 50%;
}

td.python-code-cell {
    padding : 10;
    background-color : rgb(204, 255, 204);    
	border-width : thin;
	border-style : solid;
	border-color : black;
    vertical-align : middle;
    font-family : Courier;
    font-size : 12;
}

ul {
    font-size : 14;
    padding-top : 0;
    padding-bottom : 0;
    margin-bottom : 0;
    margin-top : 0;
    list-style : square ;
}

li {
    padding-bottom : 0;
    margin-top : 0;
    margin-bottom : 0;
}

pre.literal-block {
	border-width : thin;
	border-style : solid;
	border-color : grey;
    background-color : AliceBlue;
    padding : 10;
}</t>
<t tx="pap.120703001453.984"></t>
<t tx="pap.120703001453.985">vb2Py - NotImplemented
======================

This page is currently under construction!</t>
<t tx="pap.120703001453.986">vb2Py - Unsupported
===================

Conversion of this element type is currently not supported.</t>
<t tx="pap.120703001453.987">About this Document
===================

This documentation is generated using reStructured text. The text itself is written in Leo and the reStructured text plug-in converts the text into HTML. An external script (``vb2py\sandbox\makedocs.py``) then reads the HTML and searches for any VB code. It then translates the VB code into Python and presents the VB/Python conversion tables that you seel all through the documentation.

Using Leo and reStructured text is a great way to produce documentation. The ability to use outlines to structure the documentation helps to keep things ordered. Since reStructured text is very lightweight and readable in its raw form, this makes for a very intuitive development environment.

Using the converter itself to generate the Python examples is also a good way to both test the conversion and prevent copy and paste errors in the example code snippets.</t>
<t tx="pap.120703001453.988"></t>
<t tx="pap.120703001453.989">vb2Py Installation
==================

**Important** If you installed v0.1, or the CVS version, prior to v0.2 please remove the old directories completely before installing v0.2. Changes in the package (in particular the renaming of ``vb2py.py``) **will** causes problems. Sorry for the confusion!

* `Main Installation`_
* `GUI Installation`_
* `Simpleparse Installation`_
* `mxTextTools Installation`_
* `PythonCard Installation`_

``vb2Py`` uses Python and has been tested on Python 2.2. Python 2.3 should work but earlier versions will not.
 

Main Installation
~~~~~~~~~~~~~~~~~

vb2Py is written in Python and runs on any platform which has a Python interpreter.

Once you have downloaded the ``vb2py`` package you will have a zip file. Before you can do anything you must have Python installed. After Python is installed you can install the ``vb2py`` modules by going to the directory you unzipped the files to and typing::

	&gt; python setup.py install

Now you should have a 'vb2py' folder in your Python site packages directory.

You also need to make sure you have both PythonCard_ and Simpleparse_ installed on your system.

Once these additional resources are installed on your system you should be ready to go and use the converter.

Note: You do not need VB to run the converter!


GUI Installation
~~~~~~~~~~~~~~~~

The vb2Py GUI is also written in Python and uses the PythonCard GUI toolkit. Installation of the GUI is the same as for the main libraries. Once you have downloaded the ``vb2pygui`` you will have a zip file. You can install the ``vb2pygui`` module by going to the directory you unzipped the files to and typing::

	&gt; python setup.py install

Now you should have a 'vb2pygui' folder in your Python site packages directory.


Simpleparse Installation
~~~~~~~~~~~~~~~~~~~~~~~~

vb2Py uses the ``Simpleparse`` module to parse the Visual Basic code. You can download the ``Simpleparse`` files from the Simpleparse_ download site. *NB You need ``Simpleparse v2.0.1a2`` or later.* Follow the instructions on the `Simpleparse homepage`_ to install the software.

You will also need to do the `mxTools Installation`_.


mxTextTools Installation
~~~~~~~~~~~~~~~~~~~~

The ``Simpleparse`` library uses the mxTextTools_ libraries. Once you have downloaded these, follow the instructions on the `mxTools homepage`_.


PythonCard Installation
~~~~~~~~~~~~~~~~~~~~~~~

If you want to use the ``vb2Py`` GUI or view converted forms actually running, then you will need the ``PythonCard`` GUI library. You can download the software from the PythonCard_ download site. Installation instructions are on the `PythonCard homepage`_. ``vb2Py`` has been tested with the 0.7 Prototype version but should work with later versions also.



.. _Simpleparse: http://sourceforge.net/project/showfiles.php?group_id=55673
.. _`Simpleparse homepage`: http://simpleparse.sourceforge.net
.. _mxTools: http://www.egenix.com
.. _`mxTools homepage`: http://www.egenix.com
.. _PythonCard: http://sourceforge.net/project/showfiles.php?group_id=19015
.. _`PythonCard homepage`: http://pythoncard.sourceforge.net/installation.html</t>
<t tx="pap.120703001453.990"></t>
<t tx="pap.120703001453.991">Command Line Usage
==================

The easiest way to use vb2Py from the command line is by working in the vb2py directory in your Python site-packages location.

To check the basic usage from the command line::

	&gt; python converter.py -h

Two example projects should be installed in the folder, ``vb2py/vb/test1`` and ``test2``. To convert the ``test2`` project (which is slightly more meaningful than ``test1``!) to a PythonCard project, use the command::

	&gt; python converter.py -c vb/test/test2.vbp vb/test/test2
	
	-c = convert the code also	
	vb/test/test2.vbp = the VB project file for the project	
	vb/test/test2 = the location of the generated Python files

The directory where the Python files will be put **must** exist before you run the conversion.

If you have PythonCard_ installed you can see what the forms look like by typing::

	&gt; python vb/test/test2/frmMain.py

You should see a form open with a lot of controls on it. Clicking on the controls should perform the same actions as for the VB version.

.. image:: images/sm_test2_frmmain_py.gif

See the `full form`_

For cases where you don't have a VB project file (``*.vbp``), you can still use the converter to convert individual files on at a time. The following command will convert the single code module in the test2 project::

	&gt; python converter.py -c -f vb/test/Utils.bas vb/test/test2

The code will be placed in the destination directory. Note that when doing file-by-file conversions certain parts of the conversion will not be possible. In particular, global variables will not be correctly handled since in order to determine the correct qualified name for a global, vb2Py needs to know all the files within the project.

For example, when converting an entire project the following code segment (where ``BASEDIR`` is defined in a module called ``FileGlobals``)::

	Function addBaseDirectory(Path as String)
		addBaseDirectory = BASEDIR &amp; Path ' BASEDIR is a global
	End Function

Would be converted to::

	def addBaseDirectory(Path):
		_ret = FileGlobals.BASEDIR + Path
		return _ret

However, if the file is translated on its own (using the ``-f`` command line switch) then it would be converted to::

	def addBaseDirectory(Path):
		_ret = BASEDIR + Path
		return _ret



.. _PythonCard: intallation.htm#pythoncard-installation
.. _`full form`: images/test2_frmmain_py.gif</t>
<t tx="pap.120703001453.992">GUI Usage
=========

* `Converting Entire Projects`_
* `Converting Code Fragments`_
* `Changing Options`_








.. _`GUI package`: installation.html#gui-installation
.. _PythonCard: intallation.htm#pythoncard-installation
.. _`command line`: commandline.html

.. _`full startup screen`: images/guistart.gif
.. _`full open dialog`: images/openfull.gif
.. _`full code view`: images/viewfull.gif</t>
<t tx="pap.120703001453.993">
If you installed the `GUI package`_ and if you have PythonCard_ installed then you will be able to use the vb2Py GUI to monitor the conversion procedure. To start the gui, either double click on the ``vb2pygui.pyw`` file in your ``vb2pygui`` folder of change directory to that folder in a shell and type::

	&gt; python vb2pygui.pyw

The GUI should start and show the form below.

.. image:: images/sm_guistart.gif

See the `full startup screen`_

From the startup screen you would normally click on the ``File ... Open`` menu item (or press ``CTRL-O``). This brings up the open dialog.

.. image:: images/opensmall.gif

See the `full open dialog`_

Using the file selection box you can select the Visual Basic project file (``*.vbp``) that you want to convert. Note that in version 0.2, you are not able to convert individual files using the GUI. To convert individual files where you do not have a ``VBP`` file you need to use the `command line`_ version.

Having selected a file the application will then try to load all the files and modules associated with the project and parse the Visual Basic code and form definitions. You will see the progress in the log window (at the bottom of the screen). When this is complete the tree view (on the left of the screen) will indicate all the files in the project. Clicking on a file in the tree brings up the original VB code and the converted Python version in the two code windows on the right. The Python version is on the bottom.

.. image::images/viewsmall.gif

See the `full code view`_

To write out the converted files you select the ``File ... Save`` menu item. This brings up a menu selection dialog and asks you to point to a directory. This is where the converted files will be placed. Once you press ``OK`` the files will be written and you can then run them in the same way as any other Python programs.
</t>
<t tx="pap.120703001453.994">You can convert code fragments that you write by hand or copy from the clipboard using the VB code window (top right) and the ``Convert ... Convert Active`` (CTRL-A) menu item.

For example, type the following VB code into the top right window::

	Sub Scan()
	For i = 0 To 100
		Select Case i
			Case 0 To 50
				doOneThing i
			Case Else
				doAnotherThing i
		End Select
	Next i
	End Sub

and then hit ``CTRL-A``. The code gets converted as below,

.. image:: images/convertactive1.gif

On the ``Convert`` menu, you may have noticed that there were three options,

* Code module
* Class module
* Form module

These options determine the *context* of the conversion, ie. they tell vb2Py where the code you are typing comes from. This is important because some of the conversion depends on whether the code comes from a code, class or form module. For instance, in a cod module all the subroutines are just converted to functions. If the code comes from a class or form module then everything is encapsulated in a class.

To see this select ``Convert ... Class module`` from the menu and then hit ``CTRL-A`` again. You should get the following view,

.. image:: images/convertactive2.gif

If you have a large amount of text (for example if you pasted some in from another text editor) then you can just convert a small section of it by using the ``Convert ... Convert selection`` (``CTRL-SHIFT-S``) menu option. Select just the ``Select`` clause in the above code and then hit ``CTRL-SHIFT-S`` to get the following view,

.. image:: images/convertactive3.gif

Note, that you must be very carefull when choosing this option that you select the enitre *block* that you are interested in. If you don't select the entire block then vb2Py will not be able to parse the VB code as shown in the following example,

.. image:: images/convertactive4.gif

Also notice that when you have an incomplete block the parsing will stop at the begining of the incomplete block.</t>
<t tx="pap.120703001453.995">The vb2Py conversion process is controlled by an options file (``vb2py.ini``) in the main ``vb2py`` folder. You can quickly see the result of chaning various options by using the ``View ... Options`` menu item. Selecting this item brings up the Options window.

.. image:: images/optionsfull.gif

You can edit any of the options as you would in a text editor and then press ``OK`` to return to the converter. To see the result of your option change, click on a file in the tree view list or press ``CTRL-A`` to convert the current code in the VB window (refer to the `Converting Code Fragments` section for more details).

If you are changing many options then you may want to use the ``Apply`` button from the Options window. This applies the configuration changes without closing the options window. You can click on the main window again to see your changes (you need to select a file from the tree or press ``CTRL-A``) and switch between the Options and Main windows to see how different options change the code.

As an example, here is the screen after a default conversion of some text (in the context of a Code module),

.. image:: images/convertoptions1.gif

Note that the VB comments at the start of the text were converted to a Python docstring since the ``TryToConvertDocstrings`` option in vb2Py defaults to ``Yes``. If we now change the option,

.. image:: images/convertoptions2.gif

and hit ``OK`` and then ``CTRL-A`` again, we see that the comments are not converted to a docstring and remain as individual comments.

.. image:: images/convertoptions3.gif</t>
<t tx="pap.120703001453.996">List Of Options
===============

All the options are in the ``vb2py.ini`` file located in the main ``vb2py`` folder. 

General_

	IndentCharacter_
	
	IndentAmount_
	
	AttentionMarker_
	
	WarnAboutUnrenderedCode_
	
	LoadUserPlugins_
	
	LoggingLevel_
	
	DumpFormData_
	
	RespectPrivateStatus_
	
	PrivateDataPrefix_
	
	AlwaysUseRawStringLiterals_
	
	TryToExtractDocStrings_
	
	ReportPartialConversion_
	
	IncludeDebugCode_
	
	
Functions_

	ReturnVariableName_
	
	PreInitializeReturnVariable_

Select_

	EvaluateVariable_
	
	SelectVariablePrefix_
	
	UseNumericIndex_

Labels_

	IgnoreLabels_

With_

	`With EvaluateVariable`_
	
	WithVariablePrefix_
	
	`With UseNumericIndex`_

Properties_

	LetSetVariablePrefix_
	
	GetVariablePrefix_

Classes_

	UseNewStyleClasses_
</t>
<t tx="pap.120703001453.997">The list of all ``General`` options is shown in the following table::
	
	[General]
	# Space or Tab
	IndentCharacter = Space	
	# Number of spaces/tabs					
	IndentAmount = 4							 
	# Marker to use when code needs user attention
	AttentionMarker = VB2PY				
	# Yes or No
	WarnAboutUnrenderedCode = Yes	
	# Yes or No, whether to use user plugins or not. If No, system plugins will still work
	LoadUserPlugins = No
	# Default logging level, 0 is nothing
	LoggingLevel = 0
	# Yes or No, whether to dump form data to screen - Yes seems to crash the GUI!
	DumpFormData = No
	# Yes or No, whether the full VB parser is used to convert code
	UseFullParser = Yes
	# Yes or No, whether to respect Private status of variables
	RespectPrivateStatus = Yes
	# Prefix to use to tag data as private (Python normally uses __ but VB convention is m_)
	PrivateDataPrefix = __
	# Yes or No, whether to use raw strings for all literals - very safe but not necessarily good looking!
	AlwaysUseRawStringLiterals = No
	# Yes or No, whether to try to automatically extract docstrings from the code
	TryToExtractDocStrings = Yes
	# Yes or No, whether to return a partially converted file when an error is found
	ReportPartialConversion = Yes
	# Yes or No, whether to include debug code in the converted application
	IncludeDebugCode = No
</t>
<t tx="pap.120703001453.998">Syntax: ``IndentCharacter = Space | Tab``

::
		
	# Space or Tab
	IndentCharacter = Space	
	
Sets the indentation character as a Space or a Tab. The number of indent characters is set by the IndentAmount_. 

The default is a space.

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.IndentCharacter = Space
	If a = 10 Then
		b = 1
	Else
		b = 2
	End If
    ' VB2PY-Unset: General.IndentCharacter

Be careful when switching to ``Tab`` to set the IndentAmount_, or you will end up with four tabs!

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.IndentCharacter = Tab
	If a = 10 Then
		b = 1
	Else
		b = 2
	End If
    ' VB2PY-Unset: General.IndentCharacter


</t>
<t tx="pap.120703001453.999">Syntax: ``IndentAmount = &lt;integer&gt;``

::
		
	# Space or Tab
	IndentAmount = 4	
	
Sets the number of IndentCharacter_ 's to be used to indent code blocks.

The default is 4.

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.IndentAmount = 4
	If a = 10 Then
		b = 1
	Else
		b = 2
	End If
    ' VB2PY-Unset: General.IndentAmount

Other values are allowed.

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.IndentAmount = 8
	If a = 10 Then
		b = 1
	Else
		b = 2
	End If
    ' VB2PY-Unset: General.IndentAmount


</t>
<t tx="pap.120703001453.1000">Syntax: ``AttentionMarker = &lt;string&gt;``

::
		
	# Marker to use when code needs user attention
	AttentionMarker = VB2PY				
	
Sets the marker to use in comments when highlighting part of the converted code that needs attention.

The default is VB2PY.

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.AttentionMarker = VB2PY
	On Error Goto 0
    ' VB2PY-Unset: General.AttentionMarker

Other values are allowed.

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.AttentionMarker = TODO
	On Error Goto 0
    ' VB2PY-Unset: General.AttentionMarker
</t>
<t tx="pap.120703001453.1001">Syntax: ``WarnAboutUnrenderedCode = Yes | No``

::
		
	# Yes or No
	WarnAboutUnrenderedCode = Yes	
	
Determined whether an AttentionMarker_ is inserted in the Python code to highligh VB code which has not been rendered.

The default is Yes.

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.WarnAboutUnrenderedCode = Yes
	On Error Goto 0
    ' VB2PY-Unset: General.WarnAboutUnrenderedCode

Other values are allowed.

VB(VBCodeModule)::
	
    ' VB2PY-Set: General.WarnAboutUnrenderedCode = No
	On Error Goto 0
    ' VB2PY-Unset: General.WarnAboutUnrenderedCode</t>
<t tx="pap.120703001453.1002">Syntax: ``LoadUserPlugins = Yes | No``

::
		
	# Yes or No, whether to use user plugins or not. If No, system plugins will still work
	LoadUserPlugins = No
	

Determines whether user plug-ins are loaded and executed during the normal code conversion process. User plug-ins are kept in the ``extensions`` folder of the ``vb2py`` directory. System plug-ins are also located in this folder but are not affected by the value of this setting.</t>
<t tx="pap.120703001453.1003">Syntax: ``LoggingLevel = &lt;integer&gt;``

::
		
	# Default logging level, 0 is nothing
	LoggingLevel = 0
	

Sets the default logging level to use during the code conversion. If this is set to 0 then no logging messages will be output. The logging levels are defined in the standard Python logging module. </t>
<t tx="pap.120703001453.1004">Syntax: ``DumpFormData = Yes | No``

::
		
	# Yes or No, whether to dump form data to screen - Yes seems to crash the GUI!
	DumpFormData = No
	

If this is set to ``Yes`` then the form classes will be dumped to the screen during form conversion. This may be useful if there is a problem during the conversion process.

The default is No.</t>
<t tx="pap.120703001453.1005">Syntax: ``RespectPrivateStatus = Yes | No``

::
		
	# Yes or No, whether to respect Private status of variables
	RespectPrivateStatus = Yes
	
If this variable is set to ``Yes`` then variables, subroutines and functions in VB which are either explicitely or implicitely ``Private`` will have their Python names converted to have a PrivateDataPrefix_. Setting this variable to ``No`` will ignore the ``Private`` status of all variables.

The default is Yes.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: General.RespectPrivateStatus = Yes
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.RespectPrivateStatus

An example with No.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: General.RespectPrivateStatus = No
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.RespectPrivateStatus
</t>
<t tx="pap.120703001453.1006">Syntax: ``PrivateDataPrefix = &lt;string&gt;``

::
		
	# Prefix to use to tag data as private (Python normally uses __ but VB convention is m_)
	PrivateDataPrefix = __
	
If RespectPrivateStatus_ is set to ``Yes`` then variables, subroutines and functions in VB which are either explicitely or implicitely ``Private`` will have their Python names converted to have a prefix and this setting determines what that prefix will be. 

The default is ___.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: General.PrivateDataPrefix = prv
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.PrivateDataPrefix

If the value used is not "__" then the data will not be hidden as far as Python is concerned.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: General.PrivateDataPrefix = m_
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.PrivateDataPrefix
</t>
<t tx="pap.120703001453.1007">Syntax: ``AlwaysUseRawStringLiterals = Yes | No``

::
		
	# Yes or No, whether to use raw strings for all literals - very safe but not necessarily good looking!
	AlwaysUseRawStringLiterals = No
	
By default, all VB strings are just converted to Python strings. However, if the VB string contains the backslash character then it is quite likely that the Python version will not be the same since Python will interpret the backslash as a control character. Setting the ``AlwaysUseRawStringLiterals`` option to ``Yes`` will cause all VB strings to be converted to raw Python strings (r"string"), which will prevent such problems. 

The default is No.

VB(VBCodeModule)::

    ' VB2PY-GlobalSet: General.AlwaysUseRawStringLiterals = No
    myString = "a\path\name"
    ' VB2PY-Unset: General.AlwaysUseRawStringLiterals

Setting the option to ``Yes`` is safe but doesn't always look good in the code.

VB(VBCodeModule)::

    ' VB2PY-GlobalSet: General.AlwaysUseRawStringLiterals = Yes
    myString = "a\path\name"
    ' VB2PY-Unset: General.AlwaysUseRawStringLiterals
</t>
<t tx="pap.120703001453.1008">Syntax: ``TryToExtractDocStrings = Yes | No``

::
		
	# Yes or No, whether to try to automatically extract docstrings from the code
	TryToExtractDocStrings = Yes
	
If ``TryToExtractDocStrings`` is set then any contiguous block of comment lines found at the start of a module are interpretted as a docstring and added to the class definition. The docstring terminates with the first non-comment line.

The default is ``No``.

VB(VBCodeModule)::

    ' VB2PY-GlobalSet: General.TryToExtractDocStrings = No
	' This is the documentation for the module
	' This line is also documentation
	' So is this one
	' And this is the last

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.TryToExtractDocStrings

When the option is ``Yes`` docstrings will be created.

VB(VBCodeModule)::

    ' VB2PY-GlobalSet: General.TryToExtractDocStrings = Yes
	' This is the documentation for the module
	' This line is also documentation
	' So is this one
	' And this is the last

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.TryToExtractDocStrings
</t>
<t tx="pap.120703001453.1009">Syntax: ``ReportPartialConversion = Yes | No``

::
		
	# Yes or No, whether to return a partially converted file when an error is found
	ReportPartialConversion = Yes
	
This option is used to determine what happens when the conversion fails for some reason. If the option is set to ``Yes`` then the conversion will return as much code as it can. If the option is set to ``No`` then the conversion will just fail and return nothing at all.

The default is ``Yes``.

VB(VBCodeModule)::

    ' VB2PY-Set: General.ReportPartialConversion = Yes
	a = 10
	b = 20
	c = 30
	something that wont convert
	d = 40
	e = 50
   ' VB2PY-Unset: General.ReportPartialConversion

When the option is ``No`` you wont get any output if there is an error.

VB(VBCodeModule)::

    ' VB2PY-Set: General.ReportPartialConversion = No
	a = 10
	b = 20
	c = 30
	something that wont convert
	d = 40
	e = 50
   ' VB2PY-Unset: General.ReportPartialConversion
</t>
<t tx="pap.120703001453.1010">Syntax: ``IncludeDebugCode = Yes | No``

::
		
	# Yes or No, whether to include debug code in the converted application
	IncludeDebugCode = No
	
This option is used to determine whether debug code is included in the converted application. If the option is ``Yes`` then a ``from vbdebug import *`` will be inserted at the top of each module. ``vbdebug`` includes code to access the logger and is required if you need to view the output from ``Debug.Print`` statements.

The default is ``No``.

VB(VBCodeModule)::

    ' VB2PY-Set: General.IncludeDebugCode = No
	a = 10
	b = 20
	c = 30
   ' VB2PY-Unset: General.IncludeDebugCode

When the option is ``Yes`` you get the extra ``import`` statement

VB(VBCodeModule)::

    ' VB2PY-Set: General.IncludeDebugCode = Yes
	a = 10
	b = 20
	c = 30
   ' VB2PY-Unset: General.IncludeDebugCode
</t>
<t tx="pap.120703001453.1011">The list of all ``Function`` options is shown in the following table::
	
	[Functions]
	# Name of variable used in Functions
	ReturnVariableName = _ret             
	# Yes or No, leave at Yes unless good reasons!
	PreInitializeReturnVariable = Yes     
	
</t>
<t tx="pap.120703001453.1012">Syntax: ``ReturnVariableName = &lt;string&gt;``

::
		
	# Name of variable used in Functions
	ReturnVariableName = _ret             
	
This option allows the return variable name to be specified. No checking is done to ensure that the name does not clash with local or global variables, so care should be taken when selecting a suitable name.

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    ' VB2PY-GlobalSet: Functions.ReturnVariableName = _MyFunc
    Function MyFunc(X, Optional Y, Optional Z=20)
        Dim subLocal
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
        MyFunc = subLocal*10
    End Function
    ' VB2PY-Unset: Functions.ReturnVariableName 
    
    a = MyFunc(1, 2)
    a = MyFunc(1, Z:=10)

</t>
<t tx="pap.120703001453.1013">Syntax: ``PreInitializeReturnVariable = Yes | No``

::
		
	# Yes or No, leave at Yes unless good reasons!
	PreInitializeReturnVariable = Yes     
	
By default the return variable is initialized to ``None`` at the start of the function so that an error does not occur in the event that the function returns before the return variable has been assigned to. This option allows this initialization step to be omitted and is safe as long as all return paths from the function include an explicit assignment to the return value variable.

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    ' VB2PY-GlobalSet: Functions.PreInitializeReturnVariable = Yes
    Function MyFunc(X, Optional Y, Optional Z=20)
        Dim subLocal
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
        MyFunc = subLocal*10
    End Function
    ' VB2PY-Unset: Functions.PreInitializeReturnVariable 
    
    a = MyFunc(1, 2)
    a = MyFunc(1, Z:=10)

Compare this with,
	
VB::

    Dim moduleGlobal1, moduleGlobal2
    
    ' VB2PY-GlobalSet: Functions.PreInitializeReturnVariable = No
    Function MyFunc(X, Optional Y, Optional Z=20)
        Dim subLocal
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
        MyFunc = subLocal*10
    End Function
    ' VB2PY-Unset: Functions.PreInitializeReturnVariable 
    
    a = MyFunc(1, 2)
    a = MyFunc(1, Z:=10)</t>
<t tx="pap.120703001453.1014">The list of all ``Select`` options is shown in the following table::

	[Select]
	# Once or EachTime, how many times to evaluate the case variable  
	EvaluateVariable = Once
	# Name of select variable (only used if EvaluateVariable is Once)
	SelectVariablePrefix = _select
	# Yes or No, use numeric index on select variable (needed if you every have nested Selects and EvaluateVariable = Once)
	UseNumericIndex = Yes
</t>
<t tx="pap.120703001453.1015">Syntax: ``EvaluateVariable = Yes | No``

::
		
	# Once or EachTime, how many times to evaluate the case variable  
	EvaluateVariable = Once
	
The default behaviour when converting a ``Select`` is to evaluate the select expression once at the start of the block. By setting this option to ``EachTime`` you can force the expression to be evaluated for each ``if/elif`` statement. This generally looks cleaner but can lead to undesired side effects or slow run times depending on how expensive the expression is to calculate.

VB::

    ' VB2PY-Set: Select.EvaluateVariable = Once
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.EvaluateVariable

Compare this to,

VB::

    ' VB2PY-Set: Select.EvaluateVariable = EachTime
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.EvaluateVariable
</t>
<t tx="pap.120703001453.1016">Syntax: ``SelectVariablePrefix = &lt;string&gt;``

::
		
	# Name of select variable (only used if EvaluateVariable is Once)
	SelectVariablePrefix = _select
	
When EvaluateVariable_ is set to ``Once``, this option determines the prefix used to name the variable used in the select. If UseNumericIndex_ is set to ``No`` then this option sets the variable name used, otherwise this is the prefix and the final variable will also include a unique ID number.

VB::

    ' VB2PY-Set: Select.SelectVariablePrefix = selectVariable
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.SelectVariablePrefix
</t>
<t tx="pap.120703001453.1017">Syntax: ``UseNumericIndex = Yes | No``

::
		
	# Yes or No, use numeric index on select variable (needed if you every have nested Selects and EvaluateVariable = Once)
	UseNumericIndex = Yes
	
When EvaluateVariable_ is set to ``Once``, this option determines whether a unique ID number is appended to the SelectVariablePrefix_ to determine the variable name used to hold the select expression. If used, the index is incremented for each ``select`` constuct found. This option is always required to be ``Yes`` where the code includes nested ``Select`` blocks *and* EvaluateVariable_ is set to ``Once``. If neither of these conditions applies then it is safe to set this to ``No``

VB::

    ' VB2PY-Set: Select.UseNumericIndex = Yes
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.UseNumericIndex

Comapre this to,

VB::

    ' VB2PY-Set: Select.UseNumericIndex = No
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.UseNumericIndex
</t>
<t tx="pap.120703001453.1018">The list of all ``Labels`` options is shown in the following table::

	[Labels]
	# Yes or No, ignore labels completely
	IgnoreLabels = Yes
</t>
<t tx="pap.120703001453.1019">Syntax: ``IgnoreLabels = Yes | No``

::
		
	# Yes or No, ignore labels completely
	IgnoreLabels = Yes
	
Labels are not supported in vb2Py v0.2. If you have VB code with labels on every line then you will get a huge number of attention markers telling you that the label was not converted. You can silence these warning by setting the ``IgnoreLabels`` option to ``Yes``.

VB::

    ' VB2PY-Set: Labels.IgnoreLabels = No
	10: a=1
	20: b=2
	30: c=3
    ' VB2PY-Unset: Labels.IgnoreLabels

Comapre this to,

VB::

    ' VB2PY-Set: Labels.IgnoreLabels = Yes
	10: a=1
	20: b=2
	30: c=3
    ' VB2PY-Unset: Labels.IgnoreLabels
</t>
<t tx="pap.120703001453.1020">The list of all ``With`` options is shown in the following table::

	[With]
	# Once or EachTime, how many times to evaluate the with variable  
	EvaluateVariable = Once
	# Name of with variable (only used if EvaluateVariable is Once)
	WithVariablePrefix = _with
	# Yes or No, use numeric index on with variable (needed if you every have nested Withs and EvaluateVariable = Once)
	UseNumericIndex = Yes</t>
<t tx="pap.120703001453.1021">Syntax: ``EvaluateVariable = Yes | No``

::
		
	[With]
	# Once or EachTime, how many times to evaluate the with variable  
	
The default behaviour is to evaluate the ``With`` object once at the start of the block. By setting this option to ``EachTime`` you can force the object to be evaluated each time it is required. This generally looks more natural but can lead to undesired side effects or slow run times depending on how expensive [1]_ the object is to calculate.

VB::

    ' VB2PY-Set: With.EvaluateVariable = Once
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.EvaluateVariable

Compare this to,

VB::

    ' VB2PY-Set: With.EvaluateVariable = EveryTime
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.EvaluateVariable

</t>
<t tx="pap.120703001453.1022">Syntax: ``WithVariablePrefix = &lt;string&gt;``

::
		
	# Name of with variable (only used if EvaluateVariable is Once)
	WithVariablePrefix = _select
	
When `With EvaluateVariable`_ is set to ``Once``, this option determines the prefix used to name the variable used in the ``With``. If `With UseNumericIndex`_ is set to ``No`` then this option sets the variable name used, otherwise this is the prefix and the final variable will also include a unique ID number.

VB::

    ' VB2PY-Set: With.WithVariablePrefix = withVariable
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.WithVariablePrefix
</t>
<t tx="pap.120703001453.1023">Syntax: ``UseNumericIndex = Yes | No``

::
		
	# Yes or No, use numeric index on select variable (needed if you every have nested Selects and EvaluateVariable = Once)
	UseNumericIndex = Yes
	
When `With EvaluateVariable`_ is set to ``Once``, this option determines whether a unique ID number is appended to the WithVariablePrefix_ to determine the variable name used to hold the object. If used, the index is incremented for each ``With`` constuct found. This option is always required to be ``Yes`` where the code includes nested ``With`` blocks *and* `With EvaluateVariable`_ is set to ``Once``. If neither of these conditions applies then it is safe to set this to ``No``

VB::

    ' VB2PY-Set: With.UseNumericIndex = No
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.UseNumericIndex

Compare this to,

VB::

    ' VB2PY-Set: With.UseNumericIndex = Yes
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.UseNumericIndex
</t>
<t tx="pap.120703001453.1024">The list of all ``Property`` options is shown in the following table::

	[Properties]
	# Prefix to add to property Let/Set function name
	LetSetVariablePrefix = set
	# Prefix to add to property Get function name
	GetVariablePrefix = get
</t>
<t tx="pap.120703001453.1025">Syntax: ``LetSetVariablePrefix = &lt;string&gt;``

::
		
	# Prefix to add to property Let/Set function name
	LetSetVariablePrefix = set
	
In class modules where properties are defined, vb2Py creates ``get`` and ``set`` methods to access and assign to the property. Since VB uses a syntactic form to distinguish between the getters and setters but Python uses different names with the same syntax there is a need to automatically generate a name for the ``get`` and ``set`` methods. The ``getter`` and ``setter`` methods are determined by the LetSetVariablePrefix_ and GetVariablePrefix_ respectively.

VB::

    ' VB2PY-Set: Properties.LetSetVariablePrefix = doSet_
    Dim mName As String
    Dim mAge As Single

    Public Property Let Name(Value)
        mName = Value
    End Property
    '
    Public Property Get Name()
        Name = mName
    End Property
    
    ' VB2PY-Unset: Properties.LetSetVariablePrefix
</t>
<t tx="pap.120703001453.1026">Syntax: ``GetVariablePrefix = &lt;string&gt;``

::
		
	# Prefix to add to property Get function name
	GetVariablePrefix = set
	
In class modules where properties are defined, vb2Py creates ``get`` and ``set`` methods to access and assign to the property. Since VB uses a syntactic form to distinguish between the getters and setters but Python uses different names with the same syntax there is a need to automatically generate a name for the ``get`` and ``set`` methods. The ``getter`` and ``setter`` methods are determined by the LetSetVariablePrefix_ and GetVariablePrefix_ respectively.

VB::

    ' VB2PY-Set: Properties.GetVariablePrefix = doGet_
    Dim mName As String
    Dim mAge As Single

    Public Property Let Name(Value)
        mName = Value
    End Property
    '
    Public Property Get Name()
        Name = mName
    End Property
    
    ' VB2PY-Unset: Properties.GetVariablePrefix
</t>
<t tx="pap.120703001453.1027">The list of all ``Class`` options is shown in the following table::

	[Classes]
	# Yes or No, whether to use new style classes for all classes
	UseNewStyleClasses = Yes
</t>
<t tx="pap.120703001453.1028">Syntax: ``UseNewStyleClasses = Yes | No``

::
		
	# Yes or No, whether to use new style classes for all classes
	UseNewStyleClasses = Yes
	
By default, all classes are created as *new style* Python classes (inheriting from ``Object``). Old style classes can be created by setting the ``UseNewStyleClasses`` option to ``No``.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: Classes.UseNewStyleClasses = Yes
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: Classes.UseNewStyleClasses 

Compare this to,

VB(VBClassModule)::

    ' VB2PY-GlobalSet: Classes.UseNewStyleClasses = No
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: Classes.UseNewStyleClasses 
</t>
<t tx="pap.120703001453.1029"></t>
<t tx="pap.120703001453.1030">vb2Py - Assignment
==================

Contents of this page:

* General_
* `Default Conversion`_      
* `List of Options`_


General
-------

Assignment statements are translated to their equivalent Python versions. The main difference to VB is that un-assigned names which are not ``Dim``ed will cause a ``NameError`` in the Python code.


Default Conversion
------------------

VB::

    a = 10
	b = 20*30


List of Options
---------------

There are no options specific to the assignment statement.
</t>
<t tx="pap.120703001453.1031">vb2Py - Set
===========

Contents of this page:

* General_
* `Default Conversion`_      
* `List of Options`_


General
-------

VB uses the ``Set`` statement to assign objects to variables. In Python there is no distinction between assignments so ``Set`` statements are simply translated to an equivalent assigment.


Default Conversion
------------------

VB::

    Set a = MyObj
    Set MyObj.Parent = Me.Parent


List of Options
---------------

There are no options specific to the ``Set`` statement.
</t>
<t tx="pap.120703001453.1032"></t>
<t tx="pap.120703001453.1033">vb2Py - Select
==============

Contents of this page:

- General_
- `Default Conversion`_      
- `List of Options`_

Specific options:

- EvaluateVariable_
- SelectVariablePrefix_
- UseNumericIndex_


General
-------

``Select`` blocks are replaced by ``if/elif/else`` blocks. By default a ``select`` variable 
is created, which is used in subsequent tests. This means that the checked value is
only evaluated once per ``select`` and not once per condition. If this is not an issue then
an option allows the value to be evalutated each time as required. Also by default, a numeric index is appended to the select variable to prevent clashed for nested ``Select`` constructs.

The conversion handles multiple values per case and even range settings.


Default Conversion
------------------

VB::

    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select


List of Options
---------------

Here are the options in the INI file::

    [Select]
    # Once or EachTime, how many times to evaluate the case variable  
    EvaluateVariable = Once
    # Name of select variable (only used if EvaluateVariable is Once)
    SelectVariablePrefix = _select
    # Yes or No, use numeric index on select variable (needed if you every have nested Selects and EvaluateVariable = Once)
    UseNumericIndex = Yes


EvaluateVariable
~~~~~~~~~~~~~~~~

Syntax: ``EvaluateVariable = Once | EachTime``

The default behaviour is to evaluate the select expression once at the start of the block. By setting this option to ``EachTime`` you can force the expression to be evaluated for each ``if/elif`` statement. This generally looks cleaner but can lead to undesired side effects or slow run times depending on how expensive [1]_ the expression is to calculate.

VB::

    ' VB2PY-Set: Select.EvaluateVariable = EachTime
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.EvaluateVariable


SelectVariablePrefix
~~~~~~~~~~~~~~~~~~~~

Syntax: ``SelectVariablePrefix = name``

When EvaluateVariable_ is set to ``Once``, this option determines the prefix used to name the variable used in the select. If UseNumericIndex_ is set to ``No`` then this option sets the variable name used, otherwise this is the prefix and the final variable will also include a unique ID number.

VB::

    ' VB2PY-Set: Select.SelectVariablePrefix = selectVariable
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.SelectVariablePrefix



UseNumericIndex
~~~~~~~~~~~~~~~

Syntax: ``UseNumericIndex = Yes | No``

When EvaluateVariable_ is set to ``Once``, this option determines whether a unique ID number is appended to the SelectVariablePrefix_ to determine the variable name used to hold the select expression. If used, the index is incremented for each ``select`` constuct found. This option is always required to be ``Yes`` where the code includes nested ``Select`` blocks *and* EvaluateVariable_ is set to ``Once``. If neither of these conditions applies then it is safe to set this to ``No``

VB::

    ' VB2PY-Set: Select.UseNumericIndex = No
    Select Case Value
        Case 1
            DoOne
        Case 2
            DoTwo
        Case 3, 4
            DoThreeOrFour
        Case 5 To 10
            DoFiveToTen
        Case Else
            DoElse
    End Select
    ' VB2PY-Unset: Select.UseNumericIndex

--------------

.. [1] Expensive as in CPU time.</t>
<t tx="pap.120703001453.1034">vb2Py - If
==========

Contents of this page:

* General_
* `Default Conversion`_      
* `List of Options`_


General
-------

``If`` statements are translated to their equivalent Python versions. 


Default Conversion
------------------

VB::

    If Value = 10 Or Value = 20 Then
        DoSomething
    ElseIf Value = 30 Then
        DoSomethingElse
    Else
        DontDoAnything
    End If


List of Options
---------------

There are no options specific to the ``If`` statement.
</t>
<t tx="pap.120703001453.1035">vb2Py - With
============

Contents of this page:

* General_
* `Default Conversion`_      
* `List of Options`_

Specific options:

* EvaluateVariable_
* WithVariablePrefix_
* UseNumericIndex_


General
-------

In VB, ``With`` blocks represent a shorthand for refering to a specific object. Properties and methods of the object can be referenced by just prefixing the name with a '.' and the base object name is infered from the context. Python has no such equivalent and therefore the objects must be written out in full. By default, a ``with`` variable is created and this is used to fully qualify the references. This is *safe* in cases where evaluation of the ``With`` object is expensive [1]_ but may make the code look less clear. To get around this, an option is avaialble to use the actual variable name.


Default Conversion
------------------

VB::

    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With


List of Options
---------------

Here are the options in the INI file::

    [With]
    # Once or EachTime, how many times to evaluate the with variable  
    EvaluateVariable = Once
    # Name of with variable (only used if EvaluateVariable is Once)
    WithVariablePrefix = _with
    # Yes or No, use numeric index on with variable (needed if you every have nested Withs and EvaluateVariable = Once)
    UseNumericIndex = Yes


EvaluateVariable
~~~~~~~~~~~~~~~~

Syntax: ``EvaluateVariable = Once | EveryTime``

The default behaviour is to evaluate the ``With`` object once at the start of the block. By setting this option to ``EachTime`` you can force the object to be evaluated each time it is required. This generally looks more natural but can lead to undesired side effects or slow run times depending on how expensive [1]_ the object is to calculate.

VB::

    ' VB2PY-Set: With.EvaluateVariable = EveryTime
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.EvaluateVariable


WithVariablePrefix
~~~~~~~~~~~~~~~~~~~~

Syntax: ``WithVariablePrefix = name``

When EvaluateVariable_ is set to ``Once``, this option determines the prefix used to name the variable used in the ``With``. If UseNumericIndex_ is set to ``No`` then this option sets the variable name used, otherwise this is the prefix and the final variable will also include a unique ID number.

VB::

    ' VB2PY-Set: With.WithVariablePrefix = withVariable
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.WithVariablePrefix



UseNumericIndex
~~~~~~~~~~~~~~~

Syntax: ``UseNumericIndex = Yes | No``

When EvaluateVariable_ is set to ``Once``, this option determines whether a unique ID number is appended to the WithVariablePrefix_ to determine the variable name used to hold the object. If used, the index is incremented for each ``With`` constuct found. This option is always required to be ``Yes`` where the code includes nested ``With`` blocks *and* EvaluateVariable_ is set to ``Once``. If neither of these conditions applies then it is safe to set this to ``No``

VB::

    ' VB2PY-Set: With.UseNumericIndex = No
    With MyObject
        .Height = 10
        .Width = .Height * .ScaleFactor
    End With
    ' VB2PY-Unset: With.UseNumericIndex


--------------

.. [1] Expensive as in CPU time.</t>
<t tx="pap.120703001453.1036">vb2Py - Do ... Loop
===================

Contents of this page:

* General_
* `Default Conversion`_ 
* `List of Options`_

Different forms:

* `Do ... Loop`_
* `Do While ... Loop`_     
* `Do ... Loop While`_
* `Do Until ... Loop`_
* `Do ... Loop Until`_



General
-------

All variations of VB's ``Do ... Loop`` construct are converted to an equivalent Python ``while`` block. Preconditions are converted to the equivalent condition in the ``while`` statement itself, whereas post-conditions are implemented using an ``if ...: break`` . ``Exit's`` from the loop are also implemented using ``break`` . ``Until`` conditions (pre or post) are implemented by negating the condition itself but do not affect the structure.

Default Conversion
------------------

Do ... Loop
~~~~~~~~~~~

VB::

    Do
        Val = Val + 1
        If SomeCondition Then Exit Do
    Loop


Do While ... Loop
~~~~~~~~~~~~~~~~~

VB::

    Do While Condition
        Val = Val + 1
        If SomeCondition Then Exit Do
    Loop


Do ... Loop While
~~~~~~~~~~~~~~~~~

VB::

    Do 
        Val = Val + 1
        If SomeCondition Then Exit Do
    Loop While Condition


Do Until ... Loop
~~~~~~~~~~~~~~~~~

VB::

    Do Until Condition
        Val = Val + 1
        If SomeCondition Then Exit Do
    Loop

Do ... Loop Until
~~~~~~~~~~~~~~~~~

VB::

    Do 
        Val = Val + 1
        If SomeCondition Then Exit Do
    Loop Until Condition


List of Options
---------------

There are no options for the ``Do ... Loop`` construct.</t>
<t tx="pap.120703001453.1037">vb2Py - While
=============

Contents of this page:

* General_
* `Default Conversion`_ 
* `List of Options`_



General
-------

``While`` constructs are converted to their Python equivalents.

Default Conversion
------------------

VB::

    While Condition
        Val = Val + 1
    Wend


List of Options
---------------

There are no options for the ``While`` construct.</t>
<t tx="pap.120703001453.1038">vb2Py - For and For Each
========================

Contents of this page:

* General_
* `Default Conversion`_ 
* `List of Options`_

Different forms:

* `For i = 0 To 10`_
* `For Each Obj In Container`_
     


General
-------

``For`` and ``For Each`` statements are converted to an equivalent Python for block. Where the iteration is over an iterable object, the translation just uses the iterable. Where the VB statement is an iteration between two numbers, the ``vb2Py`` function ``vbForRange`` is used to match the behaviour.


Default Conversion
------------------

For i = 0 To 10
~~~~~~~~~~~~~~~

VB::

    For i = 0 To 10
        DoSomething i
        If Condition Then Exit For
    Next i


For Each Obj In Container
~~~~~~~~~~~~~~~~~~~~~~~~~

VB::

    For Each Obj In Container
        DoSomethingWith i
        If i.Condition Then Exit For
    Next i


List of Options
---------------

There are no options specific to the ``For`` statement.
</t>
<t tx="pap.120703001453.1039"></t>
<t tx="pap.120703001453.1040">vb2Py - User Types
==================

Contents of this page:

* General_
* `Default Conversion`_ 
* `List of Options`_


General
-------

VB has the concept of a user ``Type``. A user can define a ``Type`` which can then be used to define variables which have one or more *properties*, each with its own type. The closest Python equivalent is a bare class. VB User ``Types`` are converted to bare classes with the appropriate properties. When a user ``Type`` is used, an istance of the class is created in the Python code.

Class properties are defined in an ``__init__`` method to avoid having mutable class properties.


Default Conversion
------------------

VB::

    Type Point
        X As Single
        Y As Single
    End Type
    '
    Type Line2D
        Start As Point
        Finish As Point
    End Type
    '
    Dim p1 As Point, p2 As Point
    p1.X = 10
    p1.Y = 20
    p2.X = 30
    p3.Y = 40
    '
    Dim l1 As Line2D
    l1.Start = p1
    l1.Finish = p2


List of Options
---------------

There are no options specific to the ``Type`` statement.
</t>
<t tx="pap.120703001453.1041">vb2Py - Subroutines
===================

Contents of this page:

* General_
* `Default Conversion`_ 
* `List of Options`_

Additional

* `Missing Arguments`_
* `Argument passing`_

General
-------

Subroutines are converted to Python functions with no return statement. Local variables in the VB subroutine are also local in the Python version. If a module global is used on the left hand side of an assignment then a Python ``global`` statement will be inserted at the head of the function. Project *globals* will be replaced by their fully-qualified versions.


Default Conversion
------------------

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    Sub MySub(X, Optional Y, Optional Z=20)
        Dim subLocal
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
    End Sub
    
    MySub 1, 2
    MySub 1, Z:=10


Missing Arguments
~~~~~~~~~~~~~~~~~

Optional arguments which are not supplied and have no defaults are initialized with the ``VBMissingArgument`` object. This object can be detected by the ``vbfunctions.IsMissing`` function to provide initialization of missing arguments within the body of the subroutine. This functionality is transparent under normal conditions, but if the subroutine manually assigns a value to the missing parameter prior to the IsMissing call then the behaviour may not match that of VB, since the ``vbfunctions.IsMissing`` function has no way to detect that the parameter was not supplied.

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    Sub MySub(X, Optional Y, Optional Z=20)
        Dim subLocal
        If IsMissing(Y) Then Y = 12
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
    End Sub
    
    MySub 1, 2
    MySub 1, Z:=10


Argument Passing
~~~~~~~~~~~~~~~~

VB has two argument passing schemes,

1. ``ByRef`` (Default) - arguments are passed by reference. Changes to the value inside the
   subroutine are reflected in the corresponding parameter in the calling scope.
2. ``ByVal`` - arguments are passed by value. Changes to the value inside the subroutine do
   not affect the parameter in the calling scope.

Although Python's argument passing semantics are often refered to as pass-by-reference, the actual behaviour does not always match VB's ``ByRef`` because of immutable object types and name re-binding. Although there are technical solutions for these issues, the current version of vb2Py does not make any attempt to match behaviours.

**This means that the following code, although converted, does not behave the same in the Python version**

VB::

    Sub DoIt(x, ByVal y)
        x = x + 1
        y = y + 1
    End Sub

    x = 0
    y = 0
    DoIt x, y
    ' x is now 1, y is still 0


List of Options
---------------

There are no options specific to the ``Sub`` statement.</t>
<t tx="pap.120703001453.1042">vb2Py - Functions
=================

Contents of this page:

* General_
* `Default Conversion`_ 
* `List of Options`_

Specific options:

* ReturnVariableName_
* PreInitializeReturnVariable_

Additional

* `Missing Arguments`_
* `Argument Passing`_

General
-------

Functions are converted to Python functions with an explicit return statement. By default, a return variable is created and initialize as soon as the function starts (in case the function exits before the variable is assigned a proper value). Assignments to the VB function name are mapped to the return variable. 

Local variables in the VB functions are also local in the Python version. If a module global is used on the left hand side of an assignment then a Python ``global`` statement will be inserted at the head of the function. Project *globals* will be replaced by their fully-qualified versions.


Default Conversion
------------------

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    Function MyFunc(X, Optional Y, Optional Z=20)
        Dim subLocal
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
        MyFunc = subLocal*10
    End Function
    
    a = MyFunc(1, 2)
    a = MyFunc(1, Z:=10)


Missing Arguments
~~~~~~~~~~~~~~~~~

Optional arguments which are not supplied and have no defaults are initialized with the ``VBMissingArgument`` object. This object can be detected by the ``vbfunctions.IsMissing`` function to provide initialization of missing arguments within the body of the function. This functionality is transparent under normal conditions, but if the function manually assigns a value to the missing parameter prior to the IsMissing call then the behaviour may not match that of VB, since the ``vbfunctions.IsMissing`` function has no way to detect that the parameter was not supplied.

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    Function MyFunc(X, Optional Y, Optional Z=20)
        Dim subLocal
        If IsMissing(Y) Then Y = 12
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
        MyFunc = subLocal*10
    End Function
    
    a = MyFunc(1, 2)
    a = MyFunc(1, Z:=10)


Argument Passing
~~~~~~~~~~~~~~~~

VB has two argument passing schemes,

1. ``ByRef`` (Default) - arguments are passed by reference. Changes to the value inside the
   subroutine are reflected in the corresponding parameter in the calling scope.
2. ``ByVal`` - arguments are passed by value. Changes to the value inside the subroutine do
   not affect the parameter in the calling scope.

Although Python's argument passing semantics are often refered to as pass-by-reference, the actual behaviour does not always match VB's ``ByRef`` because of immutable object types and name re-binding. Although there are technical solutions for these issues, the current version of vb2Py does not make any attempt to match behaviours.

**This means that the following code, although converted, does not behave the same in the Python version**

VB::

    Sub DoIt(x, ByVal y)
        x = x + 1
        y = y + 1
    End Sub

    x = 0
    y = 0
    DoIt x, y
    ' x is now 1, y is still 0



List of Options
---------------

Here are the options in the INI file::

    [Functions]
    # Name of variable used in Functions
    ReturnVariableName = _ret             
    # Yes or No, leave at Yes unless good reasons!
    PreInitializeReturnVariable = Yes     


ReturnVariableName
~~~~~~~~~~~~~~~~~~

Syntax: ``ReturnVariableName = name``

This option allows the return variable name to be specified. No checking is done to ensure that the name does not clash with local or global variables, so care should be taken when selecting a suitable name.

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    ' VB2PY-GlobalSet: Functions.ReturnVariableName = _MyFunc
    Function MyFunc(X, Optional Y, Optional Z=20)
        Dim subLocal
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
        MyFunc = subLocal*10
    End Function
    ' VB2PY-Unset: Functions.ReturnVariableName 
    
    a = MyFunc(1, 2)
    a = MyFunc(1, Z:=10)


PreInitializeReturnVariable
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Syntax: ``PreInitializeReturnVariable = Yes | No``

By default the return variable is initialized to ``None`` at the start of the function so that an error does not occur in the event that the function returns before the return variable has been assigned to. This option allows this initialization step to be omitted and is safe as long as all return paths from the function include an explicit assignment to the return value variable.

VB::

    Dim moduleGlobal1, moduleGlobal2
    
    ' VB2PY-GlobalSet: Functions.PreInitializeReturnVariable = No
    Function MyFunc(X, Optional Y, Optional Z=20)
        Dim subLocal
        subLocal = X + Y + Z + moduleGlobal
        moduleGlobal2 = moduleGlobal2 + 1
        MyFunc = subLocal*10
    End Function
    ' VB2PY-Unset: Functions.PreInitializeReturnVariable 
    
    a = MyFunc(1, 2)
    a = MyFunc(1, Z:=10)</t>
<t tx="pap.120703001453.1043">vb2Py - Dim and Redim
=====================

Contents of this page:

* General_
* `Default Conversion`_ 
* `List of Options`_


General
-------

VB variables can be defined or dimensioned using the ``Dim`` keyword to specify their type and/or size (for arrays). Python has no equivalent of the ``Dim`` statement but the converted code attempts to match the semantics of the ``Dim`` by,

1. Initializing the named variables to an empty object of the required type
2. Creating an array of the required size (using the ``vbfunctions.vbObjectInitialize`` function)

Note, however, that this conversion does not fix the type and size of the object and subsequent rebindings of the name will remove all reference to the previous *type*. Using the ``Preserve`` option with the ``ReDim`` command causes the original variable to be passed to the ``vbfunctions.vbObjectInitialize`` so that the contents of the object can be retained after resizing.


Default Conversion
------------------

VB::

    Dim a, b, c(20)
    Dim x As Integer, y As String, z(10) As Variant
    Dim obj As New Collection

    ReDim c(10)
    ReDim Preserve c(10)


List of Options
---------------

There are no options specific to the ``Dim`` statement.</t>
<t tx="pap.120703001453.1044">vb2Py - Enumerations
====================

Contents of this page:

* General_
* `Default Conversion`_      
* `List of Options`_


General
-------

``Enumeration`` types in VB allow the representation of a single value by a number of different *states*. Python has no equivalent concept and so enumerations are simply mapped to a series of integer values. The enumeration names become local or global names depending on the scope of the enumeration. If the values for the enumeration items are specified then these are used, if not then the values are chosen sequentially starting at zero.


Default Conversion
------------------

VB::

    Enum Number
		One = 1
		Two = 2
		Three = 3
		Four = 4
		Ten = 10
		Hundred = 100
	End Enum

	Enum Day	
		Mon
		Tue
		Wed
		Thu
		Fri
	End Enum
		


List of Options
---------------

There are no options specific to the ``Enum`` statement.
</t>
<t tx="pap.120703001453.1045"></t>
<t tx="pap.120703001453.1046">vb2Py - Class Modules
=====================

Contents of this page:

- General_
- `Default Conversion`_      
- `List of Options`_

Options:

- UseNewStyleClasses_
- RespectPrivateStatus_
- PrivateDataPrefix_
- TryToExtractDocStrings_

Special Features:

- Properties_
- Class_Initialize_
- Class_Terminate_

General
-------

Class modules are translated into Python code modules with a single class whose name is the nane of the VB class. By default, this class is a *new style* Python class (inherits from ``Object``). All methods in the class are converted to unbound methods of the class. Properties are converted to Python properties but an error is raised if the property has both ``Let`` and ``Set`` decorators. Since Python has no equivalent of the ``Set`` keyword, the ``Property Set`` method is treated in the same way as a ``Property Let``.

Attributes defined at the class level are assumed to be class attributes in the Python class. By default, the conversion respects the Public/Private scope of both attributes and methods but this can be disabled if desired.


Default Conversion
------------------

VB(VBClassModule)::

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub


List of Options
---------------

Here are the options in the INI file::

    [Classes]
    # Yes or No, whether to use new style classes for all classes
    UseNewStyleClasses = Yes


In addition to these specific options, some ``General`` options apply::

    [General]
    # Yes or No, whether to respect Private status of variables
    RespectPrivateStatus = Yes
    # Prefix to use to tag data as private (Python normally uses __ but VB convention is m)
    PrivateDataPrefix = __
	# Yes or No, whether to try to automatically extract docstrings from the code
	TryToExtractDocStrings = Yes


UseNewStyleClasses
~~~~~~~~~~~~~~~~~~

By default, all classes are created as *new style* Python classes (inheriting from ``Object``). Old style classes can be created by setting the ``UseNewStyleClasses`` option to ``No``.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: Classes.UseNewStyleClasses = No
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: Classes.UseNewStyleClasses 


RespectPrivateStatus
~~~~~~~~~~~~~~~~~~~~

Syntax: ``RespectPrivateStatus = Yes | No``

By default, variables or methods defined as Private (which is the default in VB), will be marked as private in the Python module also. Private Python variables will be prefixed with a private marker (two underscores by default). Since ``Private`` is the default in VB, this can lead to a lot of hidden variables in the Python code. The ``RespectPrivateStatus`` option allows you to turn off the ``Private/Public`` switch.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: General.RespectPrivateStatus = No
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.RespectPrivateStatus


PrivateDataPrefix
~~~~~~~~~~~~~~~~~

Syntax: ``PrivateDataPrefix = prefix``

If ``RespectPrivateStatus`` is set then each ``Private`` variable will be prefixed with the string specified by the ``PrivateDataPrefix`` option. By default this is two underscores, ``__``, which means that Python will use *name mangling* to ensure that the names really are private. Changing this option allows names to converted to some other convention (eg ``m``) which marks names but does not enforce privacy.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: General.PrivateDataPrefix = m
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.PrivateDataPrefix


TryToExtractDocStrings
~~~~~~~~~~~~~~~~~~~~~~

Syntax: ``TryToExtractDocStrings = Yes | No``

If ``TryToExtractDocStrings`` is set then any contiguous block of comment lines found at the start of the module are interpretted as a docstring and added to the class definition. The docstring terminates with the first non-comment line.

VB(VBClassModule)::

    ' VB2PY-GlobalSet: General.TryToExtractDocStrings = Yes
	' This is the documentation for the module
	' This line is also documentation
	' So is this one
	' And this is the last

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.TryToExtractDocStrings


Special Features
----------------

Properties
~~~~~~~~~~

Property ``Let``, ``Get`` and ``Set`` methods are grouped using Python 2.2's ``property`` decorator. The accessor functions are automatically called ``get&lt;Name&gt;`` and ``set&lt;Name&gt;``. No checking is performed to ensure that these names do not collide with other class methods.

VB(VBClassModule)::

    Dim mName As String
    Dim mAge As Single

    Public Property Let Name(Value)
        mName = Value
    End Property
    '
    Public Property Get Name()
        Name = mName
    End Property


Class_Initialize
~~~~~~~~~~~~~~~~

If the VB class includes a ``Class_Initialize`` method, then this is translated to an ``__init__`` method in the Python class. 

VB(VBClassModule)::

    Dim mName As String
    Dim mAge As Single

    Public Sub Class_Initialize()
        mAge = 0
    End Sub


Class_Terminate
~~~~~~~~~~~~~~~

If the VB class includes a ``Class_Terminate`` method, then this is translated to an ``__del__`` method in the Python class. Although the Python ``__del__`` method will be called upon object removal the exact details of when this is called are not guaranteed to match those in the VB program.

VB(VBClassModule)::

    Dim mObj As New Collection

    Public Sub Class_Terminate()
        Set mObj = Nothing
    End Sub</t>
<t tx="pap.120703001453.1047">vb2Py - Form Modules
====================

Contents of this page:

- General_
- `Default Conversion`_      
- `List of Options`_

Options:

- UseNewStyleClasses_
- RespectPrivateStatus_
- PrivateDataPrefix_
- TryToExtractDocStrings_


General
-------

Form modules are translated into Python code modules with a single class whose name is the nane of the VB form. By default, this class is a *new style* Python class (inherits from ``Object``). All methods in the class are converted to unbound methods of the class. Properties are converted to Python properties but an error is raised if the property has both ``Let`` and ``Set`` decorators. Since Python has no equivalent of the ``Set`` keyword, the ``Property Set`` method is treated in the same way as a ``Property Let``.

Attributes defined at the form level are assumed to be class attributes in the Python class. By default, the conversion respects the Public/Private scope of both attributes and methods but this can be disabled if desired.


Default Conversion
------------------

VB(VBFormModule)::

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub


List of Options
---------------

Here are the options in the INI file::

    [Classes]
    # Yes or No, whether to use new style classes for all classes
    UseNewStyleClasses = Yes


In addition to these specific options, some ``General`` options apply::

    [General]
    # Yes or No, whether to respect Private status of variables
    RespectPrivateStatus = Yes
    # Prefix to use to tag data as private (Python normally uses __ but VB convention is m)
    PrivateDataPrefix = __
	# Yes or No, whether to try to automatically extract docstrings from the code
	TryToExtractDocStrings = Yes


UseNewStyleClasses
~~~~~~~~~~~~~~~~~~

By default, all forms are created as *new style* Python classes (inheriting from ``Object``). Old style classes can be created by setting the ``UseNewStyleClasses`` option to ``No``.

VB(VBFormModule)::

    ' VB2PY-GlobalSet: Classes.UseNewStyleClasses = No
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: Classes.UseNewStyleClasses 


RespectPrivateStatus
~~~~~~~~~~~~~~~~~~~~

Syntax: ``RespectPrivateStatus = Yes | No``

By default, variables or methods defined as Private (which is the default in VB), will be marked as private in the Python module also. Private Python variables will be prefixed with a private marker (two underscores by default). Since ``Private`` is the default in VB, this can lead to a lot of hidden variables in the Python code. The ``RespectPrivateStatus`` option allows you to turn off the ``Private/Public`` switch.

VB(VBFormModule)::

    ' VB2PY-GlobalSet: General.RespectPrivateStatus = No
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.RespectPrivateStatus


PrivateDataPrefix
~~~~~~~~~~~~~~~~~

Syntax: ``PrivateDataPrefix = prefix``

If ``RespectPrivateStatus`` is set then each ``Private`` variable will be prefixed with the string specified by the ``PrivateDataPrefix`` option. By default this is two underscores, ``__``, which means that Python will use *name mangling* to ensure that the names really are private. Changing this option allows names to converted to some other convention (eg ``m``) which marks names but does not enforce privacy.

VB(VBFormModule)::

    ' VB2PYGlobal-Set: General.PrivateDataPrefix = m
    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub


TryToExtractDocStrings
~~~~~~~~~~~~~~~~~~~~~~

Syntax: ``TryToExtractDocStrings = Yes | No``

If ``TryToExtractDocStrings`` is set then any contiguous block of comment lines found at the start of the module are interpretted as a docstring and added to the class definition. The docstring terminates with the first non-comment line.

VB(VBFormModule)::

    ' VB2PY-GlobalSet: General.TryToExtractDocStrings = Yes
	' This is the documentation for the module
	' This line is also documentation
	' So is this one
	' And this is the last

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.TryToExtractDocStrings
</t>
<t tx="pap.120703001453.1048">vb2Py - Code Modules
====================

Contents of this page:

- General_
- `Default Conversion`_      
- `List of Options`_

Options:

- TryToExtractDocStrings_


General
-------

Code modules are translated into Python code modules with a functions and subroutines being converted to module level functions. Variables, functions and subroutines which are declared as ``Public`` or ``Global`` are flagged as globally accessible which means that, if another module tries to access them, then that module will acquire an ``import`` statement to import the code module and the variable reference will be replaced by a fully qualified name (``module.name``).



Default Conversion
------------------

VB(VBCodeModule)::

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub


List of Options
---------------

There are no specific options relating to code modules.

Some ``General`` options apply::

    [General]
	# Yes or No, whether to try to automatically extract docstrings from the code
	TryToExtractDocStrings = Yes


TryToExtractDocStrings
~~~~~~~~~~~~~~~~~~~~~~

Syntax: ``TryToExtractDocStrings = Yes | No``

If ``TryToExtractDocStrings`` is set then any contiguous block of comment lines found at the start of the module are interpretted as a docstring and added to the class definition. The docstring terminates with the first non-comment line.

VB(VBCodeModule)::

    ' VB2PY-GlobalSet: General.TryToExtractDocStrings = Yes
	' This is the documentation for the module
	' This line is also documentation
	' So is this one
	' And this is the last

    Public Name As String
    Public Age As Single
    Private ID As Long

    Public Sub checkAge()
        If Age = 0 Then Age = 1
    End Sub
    '
    Private Sub setUp()
        ID = Rnd()
        If ID = 0 Then setUp
    End Sub
    ' VB2PY-Unset: General.TryToExtractDocStrings
</t>
<t tx="pap.120703001453.1049"></t>
<t tx="pap.120703001453.1050">vb2Py - #If Directives
======================

*THE #IF DIRECTIVE DOES NOT WORK CORRECTLY IN v0.2*

Contents of this page:

* General_
* `Default Conversion`_      
* `List of Options`_


General
-------

``#If`` directives in VB are used to produce compile time switches (eg to define different constants or functions). Although Python doesn't have this concept, any of the use cases for #If directives are easily handled by Python's conventional ``if`` statement at runtime. Consequently, the ``#If`` conversion is simply converted to the equivalant Python ``if``. 


Default Conversion
------------------

VB::

    #If Value = 10 Or Value = 20 Then
        Const MaxCols = 10
    #ElseIf Value = 30 Then
        Const MaxCols = 20
    #Else
        Const MaxCols = 30
    #End If


List of Options
---------------

There are no options specific to the ``If`` statement.
</t>
<t tx="pap.120703001453.1051">vb2Py - VB Constants
====================

Contents of this page:

* General_
* `List of Constants`_  


General
-------

VB has many pre-defined constants. These have been translated into a module ``vbconstants.py`` which is automatically imported into the current namespace by the ``vbfunctions`` module. This means that the VB constants will be resolved in any module which does a ``from vb2py.vbfunctions import *``. It does also mean that you get a fair amount of namespace polution. On the positive side, the vb constants begin with the ``vb`` prefix so clashes are not very likely.


List of Constants
-----------------

Here is the list::


	"""VB Constants"""
	
	# Key Codes
	vbKeyLButton = 0x1 # Left mouse button
	vbKeyRButton = 0x2 # Right mouse button
	vbKeyCancel = 0x3 # CANCEL key
	vbKeyMButton = 0x4 # Middle mouse button
	vbKeyBack = 0x8 # BACKSPACE key
	vbKeyTab = 0x9 # TAB key
	vbKeyClear = 0xC # CLEAR key
	vbKeyReturn = 0xD # ENTER key
	vbKeyShift = 0x10 # SHIFT key
	vbKeyControl = 0x11 # CTRL key
	vbKeyMenu = 0x12 # MENU key
	vbKeyPause = 0x13 # PAUSE key
	vbKeyCapital = 0x14 # CAPS LOCK key
	vbKeyEscape = 0x1B # ESC key
	vbKeySpace = 0x20 # SPACEBAR key
	vbKeyPageUp = 0x21 # PAGE UP key
	vbKeyPageDown = 0x22 # PAGE DOWN key
	vbKeyEnd = 0x23 # END key
	vbKeyHome = 0x24 # HOME key
	vbKeyLeft = 0x25 # LEFT ARROW key
	vbKeyUp = 0x26 # UP ARROW key
	vbKeyRight = 0x27 # RIGHT ARROW key
	vbKeyDown = 0x28 # DOWN ARROW key
	vbKeySelect = 0x29 # SELECT key
	vbKeyPrint = 0x2A # PRINT SCREEN key
	vbKeyExecute = 0x2B # EXECUTE key
	vbKeySnapshot = 0x2C # SNAPSHOT key
	vbKeyInsert = 0x2D # INSERT key
	vbKeyDelete = 0x2E # DELETE key
	vbKeyHelp = 0x2F # HELP key
	vbKeyNumlock = 0x90 # NUM LOCK key
	
	
	# Form Codes
	vbModeless = 0 # UserForm is modeless.
	vbModal = 1 # UserForm is modal (default).
	
	
	# Colour Codes
	vbBlack = 0x0 # Black
	vbRed = 0xFF # Red
	vbGreen = 0xFF00 # Green
	vbYellow = 0xFFFF # Yellow
	vbBlue = 0xFF0000 # Blue
	vbMagenta = 0xFF00FF # Magenta
	vbCyan = 0xFFFF00 # Cyan
	vbWhite = 0xFFFFFF # White
	
	
	# Dir etc Codes
	vbNormal = 0 # Normal (default for Dir and SetAttr)
	vbReadOnly = 1 # Read-only
	vbHidden = 2 # Hidden
	vbSystem = 4 # System file
	vbVolume = 8 # Volume label
	vbDirectory = 16 # Directory or folder
	vbArchive = 32 # File has changed since last backup
	
	
	# File Attribute Codes
	Normal = 0 # Normal file. No attributes are set.
	ReadOnly = 1 # Read-only file. Attribute is read/write.
	Hidden = 2 # Hidden file. Attribute is read/write.
	System = 4 # System file. Attribute is read/write.
	Volume = 8 # Disk drive volume label. Attribute is read-only.
	Directory = 16 # Folder or directory. Attribute is read-only.
	Archive = 32 # File has changed since last backup. Attribute is read/write.
	Alias = 64 # Link or shortcut. Attribute is read-only.
	Compressed = 128 # Compressed file. Attribute is read-only.
	
	
	# Miscellaneous Codes
	vbCrLf = "\n" # Carriage returnlinefeed combination
	vbCr = chr(13) # Carriage return character
	vbLf = chr(10) # Linefeed character
	vbNewLine = "\n" # Platform-specific new line character; whichever is appropriate for current platform
	vbNullChar = chr(0) # Character having value 0
	vbNullString = chr(0) # String having value 0 Not the same as a zero-length string (""); used for calling external procedures
	vbObjectError = -2147221504 # User-defined error numbers should be greater than this value. For example: Err.Raise Number = vbObjectError + 1000
	vbTab = chr(9) # Tab character
	vbBack = chr(8) # Backspace character
	vbFormFeed = chr(12) # Not useful in Microsoft Windows
	vbVerticalTab = chr(11) # Not useful in Microsoft Windows
	
	
	# MsgBox Codes
	vbOKOnly = 0 # OK button only (default)
	vbOKCancel = 1 # OK and Cancel buttons
	vbAbortRetryIgnore = 2 # Abort, Retry, and Ignore buttons
	vbYesNoCancel = 3 # Yes, No, and Cancel buttons
	vbYesNo = 4 # Yes and No buttons
	vbRetryCancel = 5 # Retry and Cancel buttons
	vbCritical = 16 # Critical message
	vbQuestion = 32 # Warning query
	vbExclamation = 48 # Warning message
	vbInformation = 64 # Information message
	vbDefaultButton1 = 0 # First button is default (default)
	vbDefaultButton2 = 256 # Second button is default
	vbDefaultButton3 = 512 # Third button is default
	vbDefaultButton4 = 768 # Fourth button is default
	vbApplicationModal = 0 # Application modal message box (default)
	vbSystemModal = 4096 # System modal message box
	vbMsgBoxHelpButton = 16384 # Adds Help button to the message box
	VbMsgBoxSetForeground = 65536 # Specifies the message box window as the foreground window
	vbMsgBoxRight = 524288 # Text is right aligned
	vbMsgBoxRtlReading = 1048576 # Specifies text should appear as right-to-left reading on Hebrew and Arabic systems
	vbOK = 1 # OK button pressed
	vbCancel = 2 # Cancel button pressed
	vbAbort = 3 # Abort button pressed
	vbRetry = 4 # Retry button pressed
	vbIgnore = 5 # Ignore button pressed
	vbYes = 6 # Yes button pressed
	vbNo = 7 # No button pressed
	
	
	# Shell Codes
	vbHide = 0 # Window is hidden and focus is passed to the hidden window.
	vbNormalFocus = 1 # Window has focus and is restored to its original size and position.
	vbMinimizedFocus = 2 # Window is displayed as an icon with focus.
	vbMaximizedFocus = 3 # Window is maximized with focus.
	vbNormalNoFocus = 4 # Window is restored to its most recent size and position. The currently active window remains active.
	vbMinimizedNoFocus = 6 # Window is displayed as an icon. The currently active window remains active.
	
	
	# Special Folder Codes
	WindowsFolder = 0 # The Windows folder contains files installed by the Windows operating system.
	SystemFolder = 1 # The System folder contains libraries, fonts, and device drivers.
	TemporaryFolder = 2 # The Temp folder is used to store temporary files. Its path is found in the TMP environment variable.
	
	
	# StrConv Codes
	vbUpperCase = 1 # Converts the string to uppercase characters.
	vbLowerCase = 2 # Converts the string to lowercase characters.
	vbProperCase = 3 # Converts the first letter of every word in string to uppercase.
	vbWide = 4 # Converts narrow (single-byte) characters in string to wide (double-byte) characters. Applies to Far East locales.
	vbNarrow = 8 # Converts wide (double-byte) characters in string to narrow (single-byte) characters. Applies to Far East locales.
	vbKatakana = 16 # Converts Hiragana characters in string to Katakana characters. Applies to Japan only.
	vbHiragana = 32 # Converts Katakana characters in string to Hiragana characters. Applies to Japan only.
	vbUnicode = 64 # Converts the string to Unicode using the default code page of the system.
	vbFromUnicode = 128 # Converts the string from Unicode to the default code page of the system.
	
	
	# System Colour Codes
	vbScrollBars = 0x80000000 # Scroll bar color
	vbDesktop = 0x80000001 # Desktop color
	vbActiveTitleBar = 0x80000002 # Color of the title bar for the active window
	vbInactiveTitleBar = 0x80000003 # Color of the title bar for the inactive window
	vbMenuBar = 0x80000004 # Menu background color
	vbWindowBackground = 0x80000005 # Window background color
	vbWindowFrame = 0x80000006 # Window frame color
	vbMenuText = 0x80000007 # Color of text on menus
	vbWindowText = 0x80000008 # Color of text in windows
	vbTitleBarText = 0x80000009 # Color of text in caption, size box, and scroll arrow
	vbActiveBorder = 0x8000000A # Border color of active window
	vbInactiveBorder = 0x8000000B # Border color of inactive window
	vbApplicationWorkspace = 0x8000000C # Background color of multiple-document interface (MDI) applications
	vbHighlight = 0x8000000D # Background color of items selected in a control
	vbHighlightText = 0x8000000E # Text color of items selected in a control
	vbButtonFace = 0x8000000F # Color of shading on the face of command buttons
	vbButtonShadow = 0x80000010 # Color of shading on the edge of command buttons
	vbGrayText = 0x80000011 # Grayed (disabled) text
	vbButtonText = 0x80000012 # Text color on push buttons
	vbInactiveCaptionText = 0x80000013 # Color of text in an inactive caption
	vb3DHighlight = 0x80000014 # Highlight color for 3-D display elements
	vb3DDKShadow = 0x80000015 # Darkest shadow color for 3-D display elements
	vb3DLight = 0x80000016 # Second lightest 3-D color after vb3DHighlight
	vbInfoText = 0x80000017 # Color of text in ToolTips
	vbInfoBackground = 0x80000018 # Background color of ToolTips
	
	
	# Var Type Codes
	vbEmpty = 0 # Uninitialized (default)
	vbNull = 1 # Contains no valid data
	vbInteger = 2 # Integer
	vbLong = 3 # Long integer
	vbSingle = 4 # Single-precision floating-point number
	vbDouble = 5 # Double-precision floating-point number
	vbCurrency = 6 # Currency
	vbDate = 7 # Date
	vbString = 8 # String
	vbObject = 9 # Object
	vbError = 10 # Error
	vbBoolean = 11 # Boolean
	vbVariant = 12 # Variant (used only for arrays of variants)
	vbDataObject = 13 # Data access object
	vbDecimal = 14 # Decimal
	vbByte = 17 # Byte
	vbUserDefinedType = 36 # Variants that contain user-defined types
	vbArray = 8192 # Array
	

</t>
<t tx="pap.120703001453.1052"></t>
<t tx="pap.120703001453.1053">VB Control Properties and Methods
=================================

The following pages are a catalog of all the VB controls along with their properties and methods. This information was compiled from the type libraries supplied with VB. This list is being used in the development of the conversion to map VB properties and events onto their PythonCard equivalents.

The list is broken down by type library.

* `vb5.old`_
* `comctl32.oca`_



.. _`vb5.old`: vb5.html
.. _`comctl32.oca`: comctl32.html</t>
<t tx="pap.120703001453.1054">There are a number of issues to deal with when converting VB form and codes. This node collects together the various issues grouped by type.
</t>
<t tx="pap.120703001453.1055">1. Event names are different

2. Radio buttons work in a different way

3. Objects have default methods/properties

</t>
<t tx="pap.120703001453.1056">1. Keywords are different

2. Need to convert block structures to indentation

3. Function returns are implicit

4. Some operators are different (string concatenation, exponential)

5. Variable names are not case sensitive

6. On error goto and resume

7. Select case block

8. Do, while block

9. Implicit coercion of types

10. Static typing

11. Fixed size arrays

12. Global constants

13. Global variables

14. Comments

15. Non zero based indexing for arrays

16. Indexing uses () rather than []

17. Collection class

18. open statement and #file numbers

19. Implementation of iterable classes

20. Labels (eg for on error or goto)

21. Goto, Gosub, Return

22. Colons as separators on lines

23. Type definitions</t>
<t tx="pap.120703001453.1057">1. Property get and set is different</t>
<t tx="pap.120703001453.1058"></t>
<t tx="pap.120703001453.1059">There are various approaches which might be successful in converting code from one language to another. </t>
<t tx="pap.120703001453.1060">Nothing really!</t>
<t tx="pap.120703001453.1061">We could view the translation process as a multipass replacement. Each pass addresses one particular issue of translation. As the passess progress the code gets closer and closer to Python. 

Advantages

- easy to get started

- easy to see where a problem occurs

- modular

- easy to understand


Disadvantages

- some structures might conflict

- some things might not be possible

- no one process is going to understand the entire code</t>
<t tx="pap.120703001453.1062">We read and parse the entire application and try to understand the block structures.

Advantages

- More sophisticated, should be able to handle anything

- Can understand scopes of variables


Disadvantages

- Complex

- No quick results

- Hard to extend
</t>
<t tx="pap.120703001453.1063">Perhaps we could go to an intermediate language (LISP?). 

Then we could convert to Python from that.

Advantages

- Able to extend to other languages very easily

- Don't need to do a full conversion

Disadvantages

- Need to do two conversions

- VB is close to Python anyway so going to LISP makes is harder</t>
<t tx="pap.120703001453.1064">A spike solution based on a piecemeal approach worked quite well. Perhaps the full solution is to use piecemeal to get quick hits and low hanging fruit and then switch to full parsing for the really tricky stuff. 

The piecemeal approach also is a good way to find the really tricky stuff.

A modular approach is going to be key. Modules would need to successively parse the code making it closer and closer to VB.


The process should be as follows,

1. Read the code
2. Break into logical processing blocks
3. Identify processing blocks
4. Load a list of "processors"
5. Pass each block through its appropriate processors
6. Reassemble back into code


But aren't blocks heirarchical?
Can any non-heirarchical approach succeed?
Perhaps you have to be heirarchical and then start at the bottom.

- Handle characters
- Handle lines
- Handle code blocks
- Handle fns
- Handle modules


</t>
<t tx="pap.120703001453.1065"></t>
<t tx="pap.120703001453.1066">Version 0.1 of vb2py has been released.

What is vb2py?
==============

vb2py is a toolkit to aid in the conversion of Visual Basic projects to Python (using PythonCard). The conversion will eventually include both forms and code (modules and classes). Version 0.1 is mainly a form layout converter to PythonCard with a very simplistic code translation. The project roadmap (http://vb2py.sourceforge.net/roadmap.htm) shows the project's development timeline.

Converting VB to Python turns your VB projects into cross platform developments and allows full access to all Python's extensive library of modules. 


Getting the Software
====================

* The main website: http://vb2py.sourceforge.net
* Download this version: http://vb2py.sourceforge.net/downloads.htm
* Documentation: http://vb2py.sourceforge.net/documentation.htm


Requirements
============

* Python 2.1 or greater
* PythonCard
* simpleparse (not used in the 0.1 code but required to use the experimental VB parser)
* Visual Basic is *not* required (although it would help if you had some VB code ...)


Licence
=======

vb2py is released under the BSD licence.


Release History
===============

This is the first public release from the project.


Contributors Welcome
====================

In a project like this one there are many ways people can contribute. Coding, testing, advice, etc are all valuable and much appreciated.


----

Paul Paterson
(paulpaterson@users.sourceforge.net)

vb2py :: A Visual Basic to Python Conversion Toolkit
http://vb2py.sourceforge.net
</t>
<t tx="pap.120703001453.1067">Version 0.2 of vb2py has been released.

What is vb2py?
==============

vb2py is a toolkit to aid in the conversion of Visual Basic projects to Python. The aim of the conversion is to match, as close as possible, the original VB applications both in terms of code behaviour and form layout. Version 0.2 comprises a basic layout converter (converting to PythonCard) with a comprehensive code translation. The project roadmap (http://vb2py.sourceforge.net/roadmap.htm) shows the project's development timeline.

Converting VB to Python turns your VB projects into cross platform developments and allows full access to all Python's extensive library of modules. 


What's new in v0.2
==================

The key development in v0.2 is the inclusion of the full VB code parser and converter. Whereas v0.1 was just a form layout converter, v0.2 parses all the VB code and translates it to the equivalent Python code. All major code constructs from VB are covered (Sub, Fn, If, While, For, Select, With, Classes, Properties, Types, etc) and most instrinsic functions and constants are implemented as Python equivalents.

The other major addition to v0.2 is the inclusion of a GUI to enable the progress of the conversion to be monitored and tweaked using the options system. The GUI is a PythonCard application running on top of the main vb2py library. The GUI is not required to convert VB code, a fully functioning command line alternative is available.

Linux is now supported (this was badly broken in v0.1!)


Limitations of v0.2
===================

- Form layout translation is still at the v0.1 level. (target v0.3)
- Form event mapping is still primitive (target v0.3)
- Error handling, ByRef argument passing, Iterable classes are not currently supported (target v0.4)


Getting the Software
====================

* The main website: http://vb2py.sourceforge.net
* Download this version: http://vb2py.sourceforge.net/downloads.htm
* Documentation: http://vb2py.sourceforge.net/documentation.htm


Requirements
============

* Python 2.2 or greater
* PythonCard (0.7 or greater), wxWindows
* simpleparse (2.0.1a2 or greater), mxTools
* Visual Basic is *not* required (although it would help if you had some VB code ...)


Licence
=======

vb2py is released under the BSD licence.


Release History
===============

0.1    (July 9, 2003) - The first release from the project - a basic form layout translator
0.1.1  (August 1, 2003) - A bugfix release for 0.1
0.2    (September 8, 2003) - This release


Contributors Welcome
====================

This project would not be possible without the help and support of many people. Anyone who wants to get involved is more than welcome to participate in coding, testing, giving advice, etc. Some particular areas of interest right now are,

- testing on large VB projects
- testing on Mac
- testing out with VBScript, VBA

In the meantime I would like to thank all those who supported and contributed towards the v0.2 release. 

----

Paul Paterson

vb2py :: A Visual Basic to Python Conversion Toolkit
http://vb2py.sourceforge.net
</t>
<t tx="pap.120703001453.1068">The Online Version of vb2py has been released. 

You can now convert Visual Basic (and to a limited extent VBA, VBScript and ASP) to Python code right in your browser without having to download any additional libraries or software. The online version is based on the v0.2 codebase which includes all VB control structures and most intrinsic functions and keywords. Form layout conversion is not currently available in the online version. 

You can access the online version here: http://vb2py.sourceforge.net/demo.htm


What is vb2py?
==============

vb2py is a toolkit to aid in the conversion of Visual Basic projects to Python. The aim of the conversion is to match, as closely as possible, the original VB applications both in terms of code behaviour and form layout. Version 0.2 comprises a basic layout converter (converting to PythonCard) with a comprehensive code translation. The project roadmap (http://vb2py.sourceforge.net/roadmap.htm) shows the project's development timeline.

Converting VB to Python turns your VB projects into cross platform developments and allows full access to all Python's extensive library of modules. 


Limitations of the online version
=================================

- No form layouts
- A limit of 500 LOC per go to prevent server overload
- Single files only
- No project level global/public variable mapping
- **Please note** the important disclaimers on the site regarding **security** of your code (it is submitted in plain text and is not therefore suitable for commercially sensitive material).

Getting the Software
====================

* The main website: http://vb2py.sourceforge.net
* The online version: http://vb2py.sourceforge.net/demo.htm
* Download the current version: http://vb2py.sourceforge.net/downloads.htm
* Documentation: http://vb2py.sourceforge.net/documentation.htm


Requirements for the online version
===================================

* A web browser


Licence
=======

vb2py is released under the BSD licence.


Release History
===============

0.1    (July 9, 2003) 						- The first release from the project - a basic form layout translator
0.1.1  (August 1, 2003) 				- A bugfix release for 0.1
0.2    (September 8, 2003) 	- First implementation of the full VB parser
Online (October 14, 2003) 		- Online version made available


Contributors Welcome
====================

This project would not be possible without the help and support of many people. Anyone who wants to get involved is more than welcome to participate in coding, testing, giving advice, etc. Some particular areas of interest right now are,

- testing on large VB projects
- testing on Mac
- testing out with VBScript, VBA

In the meantime I would like to thank all those who supported and contributed towards the project. 

----

Paul Paterson

vb2py :: A Visual Basic to Python Conversion Toolkit
http://vb2py.sourceforge.net
</t>
<t tx="pap.120703001453.1069">Many people contributed and supported the project and each one had valuable input.

Here are just some of the many people who deserve thanks and credit! (please let me know if there is someone missing)

- Jacob Halln wrote the collection class
- Kevin Altis provided the positive feedback which drove the initial creation of the project
- Mike Fletcher helped sort out EBNF problems and offered Simpleparse advice
- Bengt Richter contributed a pointer class implementation for ByRef argument passing
- Nils Grotnes wrote the GUI and provided invaluable testing, bug fixes and discussion
- Alexandr Zamaraev wrote the plugin to convert short-form recordset notation (record!field)

and Jo-Ann, who helped develop and maintain the website, designed the logo's and other artwork and put up with too many late nights!</t>
<t tx="pap.120703001453.1070">@nocolor</t>
<t tx="pap.120703001453.1071">				</t>
<t tx="pap.120703001453.1072">1. Mapping of system colours on form controls
2. Re-enable the -s command line option
3. Colours which are not sent as rgb
4. Distinguish between form names and form file names
5. Form load
6. Form unload 
</t>
<t tx="pap.120703001453.1073"></t>
<t tx="pap.120703001453.1074">23. Refactor options to use getOptionChoice, getOptionYesNo methods
26. Static variables
32. Public Const SYMBOL_CHARSET As Long = 2  &lt;- converting properly
33. Render comments properly in type statements
34. Refactor the "assignParent" method to be a finalizeObject method
35. Type ids ($%&amp;#) as casts?
36. How to handle WithEvents?
37. How to handle "Option"
38. How to handle Event definitions
39. What is a "Friend" for the scope ???
40. What to do with "Set NewEnum = mCol.[_NewEnum]"
42. Implements(cINetHandler)
45. DoEvents
46. #x# as a date
47. converting date literal
53. With obj
	   ReDim .arr(20)
    End With

54. Need to render AddressOf
55. Refactor ExitStatement to be a method of parent
58. Refactor parser module
59. Remove namespace conversion from vb2py
60. Option groups
64. Grouping on Like
	&gt;&gt;&gt; c("c=f+a like b+g+h")
	from vb2py.vbfunctions import *
	c = Like(f + a, b + g) + h
50. Redim a.b(10).c(10)
15. External libraries
19. Get / Put
31. Document #If etc - not that when inside definitions, this doesn't work!
56. Use plug-in for method name conversion
73. AddressOf and TypeOf as in
    a = TypeOf b Is Whatever
70. Replace function?  Does this exist?
77. Move (Screen.Width - Width) / 2, (Screen.Height - Height) / 2
78. Time ...
</t>
<t tx="pap.120703001453.1075">1. In VB Script can have "Sub a\nEnd Sub" (ie no parenthesis)
2. What about converting VB scipt containing web pages to .... ? 
3. VB script has "else if" not "elseif"
</t>
<t tx="pap.120703001453.1076">3. Start unit tests for GUI
5. Change CTRL-A hotkey to something which is not used by the text controls
6. Group files in tree view
8. Startup splash screen
9. ASP
10. VBScript
11. VBA

</t>
<t tx="pap.120703001453.1077"></t>
<t tx="pap.120703001453.1078">Here's the link to the c.l.py discussion

http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;frame=right&amp;th=24cbd796f1798b9&amp;seekm=mailman.1059168446.20696.python-list%40python.org#link1

Essentially looks like we might have to use a custom namespace object



class Namespace: pass

# ByVal arguments passed directly, ByRef via a namespace
def change(x, byrefs):
    x = x + 1
    byrefs.y = byrefs.y + 1

ns = Namespace() # The local namespace
ns.x = 0
ns.y = 0
change(ns.x, ns)
# Now ns.x = 0, ns.y = 1 


</t>
<t tx="pap.120703001453.1079">1. Google "Convert VB to Python" still doesn't really hit vb2py - need to add meta tags or something
4. Add graphics to help and manual
</t>
<t tx="pap.120703001453.1080"></t>
<t tx="pap.120703001453.1081">
1. On Error
2. Close #chan
3. Why does "doit a:=10" work but not "b=doit(a:=10)" ??
4. Soring out the "If" parsing problem</t>
<t tx="pap.120703001453.1082">
4. Inline If
7. Dealing with missing arguments that don't have defaults
3. Set statement
10. Converting expressions to detect [] vs ()
14. Print (#)
5. How to test subroutines
6. Conversion of standard VB functions
9. Calls
16. Lurking comments at the end of lines?
13. Open
1. For each
17. Type identifiers ($, %, #)
21. Default properties
20. Properties
11. Classes
12. Nothing -&gt; None conversion
8. Named arguments
2. Conditional expressions
24. Enums
29. Ubound, LBound
30. Need to render the "End" statement
28. Dim A As String * 20
51. On Local Error Resume Next
44. Bare close statement
52. Val
48. "Like" operator
49. Xor operator
43. Seek statement conversion
27.a Trim$
27. Dir$ 
25. VB's Command line parameters
22. Non-integer for loops
57. Add imports for globals and classes
62. Add form controls to form namespace
63. Bug: c("Const a=1, b=20, c=5")  only renders the last one
42. Bug "a(fn(2)) = 10" -&gt; "a[fn[10]] = 1"
43. IsNumeric
61. Fail more gracefully when the parser can't cope
62. CreateObject
18. vbCRLF
41. vbKeyReturn
64. CDbl
65. Round function
66. a Is Nothing
57. Refactor rootPath in utils
67. Remove print statements from conversion
72. Rem whatever
75. a = b(c (10))
74. Private Declare Function SHGetFileInfo Lib "shell32.dll" _
        Alias "SHGetFileInfoA" ( _
        ByRef pszPath As Any, _
        ByVal dwFileAttributes As Long, _
        ByRef psfi As SHFILEINFO, _
        ByVal cbFileInfo As Long, _
        ByVal uFlags As Long _
              ) As Long
71. Input(Length, #chan)
76. modOptions in t5
78. Make the GUI exit more cleanly
68. Jacob's new collection class code
69. Update documentation to account for new name for vb2py (converter)
58. Test on Linux
79. Make package</t>
<t tx="pap.120703001453.1083">
1. form size is correct
2. textboxes and buttons have size
3. menus have shortcuts</t>
<t tx="pap.120703001453.1084">
1. Select variable name
2. Select variable safe mode (re-evaluate select variable)
3. Allow changes to config in VB comments</t>
<t tx="pap.120703001453.1085">
2. Fix While/Wend example on control structures
2. Fix graphics on Wiki
3. Fix graphics on Forum</t>
<t tx="pap.120703001453.1086">
1. Add help to GUI
2. Find dialog title
4. Make the GUI quit properly
7. Enable opening of single files</t>
<t tx="pap.120703001453.1087">
1. Path to GUI resources
2. cr/lf in vbp and other files</t>
<t tx="pap.120703001453.1088"></t>
<t tx="pap.120703001453.1089">Done</t>
<t tx="pap.120703001453.1090">Done
</t>
<t tx="pap.120703001453.1091">Done</t>
<t tx="pap.120703001453.1092">Done</t>
<t tx="pap.120703001453.1093">Done
</t>
<t tx="pap.120703001453.1094">Added to method definition ... Done
Need to add to object rendering ... Done</t>
<t tx="pap.120703001453.1095">Done</t>
<t tx="pap.120703001453.1096">Done
</t>
<t tx="pap.120703001453.1097">Done
</t>
<t tx="pap.120703001453.1098">Done
</t>
<t tx="pap.120703001453.1099">Changed name to vbparser to avoid clash with parser.pyd
Broke into two sections (classes and functions)
</t>
<t tx="pap.120703001453.1100">Done!</t>
<t tx="pap.120703001453.1101">Done!</t>
<t tx="pap.120703001453.1102">of the type "a = b" where b is a function</t>
<t tx="pap.120703001453.1103">Done</t>
<t tx="pap.120703001453.1104">Done
</t>
<t tx="pap.120703001453.1105"></t>
<t tx="pap.120703001453.1106"></t>
<t tx="pap.120703001453.1107"></t>
<t tx="pap.120703001453.1108">Done
</t>
<t tx="pap.120703001453.1109">Done
</t>
<t tx="pap.120703001453.1110"></t>
<t tx="pap.120703001453.1111">Bug fixing procedure,

1. Confirm the bug using 'python -i sandbox\commandline.py'
2. Ensure that there is a bug report on SourceForge
3. Add an item to this node with the SF bug #
4. Create unit test(s) which show(s) the bug
5. Clone key code sections to the bug node here
6. Fix the bug
7. Confirm that unit tests work now and that no other breakage
8. Upload to CVS
9. Change Bug status on CVS
10. Email the person who reported the bug</t>
<t tx="pap.120703001453.1112">1. Initialize channelid object to VBRenderDirect("None")
2. All writeText to do a 'print' if the channelid is None</t>
<t tx="pap.120703001453.1113">This turns out to be a bug whereby any line ending in a colon will fail.

Changed the 'line_body' pattern in the grammar:

From:
	
	line_body ::=
			 (implicit_call_statement / ((compound_statement / single_statement), (line_end / colon)) / inline_if_statement)
			 
			 
To:
	
	line_body ::=
			 (implicit_call_statement / ((compound_statement / single_statement), (line_end / (colon, line_end?))) / inline_if_statement)			 
			 
			 
			 
Now a colon can be followed by an aptional end of line.		 </t>
<t tx="pap.120703001453.1114">The problem is that the VBVariableDefinition.size_definitions is coming back as an empty list and in the render method we detect the empty list and just skip on by.


1. Added 'unsized_definition' pattern to the grammar to catch '()' and special case it
2. Added handler for this item to VBVariable
3. Special case this in VBVariableDefinition.renderAsCode
4. Special case no size in vbObjectInitialize</t>
<t tx="pap.120703001453.1115">Expressions which end up on the LHS of the assignment are not converted with the brackets_are_indexes context set</t>
<t tx="pap.120703001453.1116"></t>
<t tx="pap.120703001453.1117">For example,

If a=1 Then Resume Next

if a == 1:
    # VB2PY (UntranslatedCode) Resume Next
	
The comment also needs a pass statement


VBNamespace.containsStatements is too brittle - it doesn't recognize the VBUnrendered as a non-statement block	</t>
<t tx="pap.120703001453.1118"></t>
<t tx="pap.120703001453.1119">Changed the grammar for a bare_list to use a print_separator. The print_separator now accepts "," and ";" - both being equal. This results in identical code, which is wrong for Debug.Print - but at least it parses and the result is probably not too serious as we aren't trying to match the Debug behaviour exactly.</t>
<t tx="pap.120703001453.1120">Fixed
</t>
<t tx="pap.120703001453.1121">Fixed
</t>
<t tx="pap.120703001453.1122"></t>
<t tx="pap.120703001453.1123"></t>
<t tx="pap.120703001453.1124"></t>
<t tx="pap.120703001453.1125"></t>
<t tx="pap.120703001453.1126"></t>
<t tx="pap.120703001453.1127"></t>
<t tx="pap.120703001453.1128"></t>
<t tx="pap.120703001453.1129"></t>
<t tx="pap.120703001453.1130"></t>
<t tx="pap.120703001453.1131"></t>
<t tx="pap.120703001453.1132"></t>
<t tx="pap.120703001453.1133"></t>
<t tx="pap.120703001453.1134"></t>
<t tx="pap.120703001453.1135"></t>
<t tx="pap.120703001453.1136"></t>
<t tx="pap.120703001453.1137"></t>
<t tx="pap.120703001453.1138"></t>
<t tx="pap.120703001453.1139"></t>
<t tx="pap.120703001453.1140"></t>
<t tx="pap.120703001453.1141"></t>
<t tx="pap.120703001453.1142"></t>
<t tx="pap.120703001453.1143"></t>
<t tx="pap.120703001453.1144"></t>
<t tx="pap.120703001453.1145">@nocolor

One of the key problems in automated code conversion is trusting that the converted code works the same way as the original. With large projects, where code conversion pays off, this problem is particularly accute. 

One solution is to automatically generate unit tests in both VB and Python and have a system that can automatically check that the performance is the same. An additional benefit of this approach is that it makes it much easier to test the converter too!

So, what is required?

1. A tool to generate the VB and Python code
2. Some way to indicate what input values should be passed in the test
3. Perhaps some way of defaulting the test ranges
4. Some way of monitoring output
5. Some way of checking the output of the Python code with that of the VB

Perhaps this tool would also be helpful if the code is converted manually?

</t>
<t tx="pap.120703001453.1146">@nocolor

Take a function, f, which takes parameters x, y, z and returns a value v.

1. Setup
	- Create the function
	- Create the list of possible x, y and d

2. Execute
	- Run the function and collect x, y, z, v lists
	- Run the Python version and collect similar data

3. Validate
	- Compare the Python and VB

</t>
<t tx="pap.120703001453.1147">[DefaultRanges]
Integer = (0, 1, 2, 5, 10)
String = ("one", "two", "three", "four", "five")
Single = (-10.0, -5.5, -1.5, 0.0, 1.5, 5.5, 10.0)
</t>
<t tx="pap.120703001453.1148">@color
@root ../vb2pyautotest/autotest.py

"""An automatic testing framework to compare VB and Python versions of a function"""	
	
import os
import pprint
from vb2py import converter, vbparser, config
Config = config.VB2PYConfigObject("autotest.ini", "../vb2pyautotest")

&lt;&lt; AutoTest Functions &gt;&gt;
	
if __name__ == "__main__":
	filename = 'c:\\development\\python22\\lib\\site-packages\\vb2py\\vb\\test3\\Globals.bas'
	p = PythonTestMaker(filename)
	v = VBTestMaker(filename)</t>
<t tx="pap.120703001453.1149">&lt;&lt; AutoTest Functions &gt;&gt;=

class TestMaker:
	"""A Base Class to help in making unit tests"""
	
	default_filename = "testscript.txt"
	
	&lt;&lt; TestMaker methods &gt;&gt;</t>
<t tx="pap.120703001453.1150">&lt;&lt; TestMaker methods &gt;&gt;=

def __init__(self, filename):
	"""Initialize the test maker"""
	self.filename = filename</t>
<t tx="pap.120703001453.1151">&lt;&lt; TestMaker methods &gt;&gt;=

def parseVB(self):
	"""Parse the VB code"""
	self.parser =  converter.VBConverter(converter.importTarget("PythonCard"), converter.FileParser)	
	self.parser.doConversion(self.filename)
	</t>
<t tx="pap.120703001453.1152">&lt;&lt; TestMaker methods &gt;&gt;=

def createTests(self):
	"""Create the test signatures"""
	self.tests = self.extractSignatures(self.parser)
</t>
<t tx="pap.120703001453.1153">&lt;&lt; TestMaker methods &gt;&gt;=

def makeTestForFunction(self, testid, modulename, fnname, paramlist):
	"""Make a test script for a function
	
	The function resides in a module and takes a list of parameters which
	are specified in paramlist. Paramlist also includes a list of values
	to pass as that particular parameter.
	
	The results of the test are written to a file testid
	
	"""
	raise NotImplementedError</t>
<t tx="pap.120703001453.1154">&lt;&lt; TestMaker methods &gt;&gt;=

def extractSignatures(self, project):
	"""Extract function test signatures from a project"""
	fns = []
	for module in project.modules:
		for defn in module.code_structure.locals:
			if isinstance(defn, vbparser.VBFunction):
				test = ["test_%s_%s" % (module.name, defn.identifier),
						module.name,
						defn.identifier]
				ranges = []
				for param in defn.parameters:
					try:
						thisrange = Config["DefaultRanges", param.type]
					except config.ConfigParser.NoOptionError:
						thisrange = []
					ranges.append((param.identifier, eval(thisrange)))
				test.append(ranges)
				fns.append(test)
	return fns
</t>
<t tx="pap.120703001453.1155">&lt;&lt; TestMaker methods &gt;&gt;=

def createTestScript(self):
	"""Create a script containing the tests"""
	ret = []
	for test in self.tests:
		ret.append(self.makeTestForFunction(*test))
	return "\n".join(ret)</t>
<t tx="pap.120703001453.1156">&lt;&lt; TestMaker methods &gt;&gt;=

def writeTestsToFile(self, filename=None):
	"""Write the test script to a file"""
	script = self.createTestScript()
	if filename is None:
		filename = self.default_filename
	f = open(filename, "w")
	f.write(script)
	f.close()</t>
<t tx="pap.120703001453.1157">&lt;&lt; TestMaker methods &gt;&gt;=

def makeTestFile(self, filename=None):
	"""Translate VB and make tests"""
	self.parseVB()
	self.createTests()
	self.writeTestsToFile(filename)</t>
<t tx="pap.120703001453.1158">&lt;&lt; AutoTest Functions &gt;&gt;=

class PythonTestMaker(TestMaker):
	"""A Class to help in making Python unit tests"""
	
	default_filename = "testscript.py"

	&lt;&lt; PythonTestMaker methods &gt;&gt;</t>
<t tx="pap.120703001453.1159">&lt;&lt; PythonTestMaker Methods &gt;&gt;=

def makeTestForFunction(self, testid, modulename, fnname, paramlist):
	"""Make a Python test script for a function
	
	The function resides in a module and takes a list of parameters which
	are specified in paramlist. Paramlist also includes a list of values
	to pass as that particular parameter.
	
	The results of the test are written to a file testid
	
	"""
	ret = []
	ret.append("from %s import %s" % (modulename, fnname))
	ret.append("results = []")
	tabs = ""
	#
	for param, values in paramlist:
		ret.append("%sfor %s in %s:" % (tabs, param, values))
		tabs += "\t"
	#
	arg_list = ",".join([param[0] for param in paramlist])
	ret.append("%sresults.append((%s(%s), %s))" % (tabs, fnname, arg_list, arg_list))
	ret.extend(("f = open('%s_py.txt', 'w')" % testid,
			   r"f.write('# vb2Py Autotest results\n')",
			   r"f.write('\n'.join([', '.join(map(str, x)) for x in results]))",
			   r"f.close()"))											 
	#
	return "\n".join(ret)</t>
<t tx="pap.120703001453.1160">&lt;&lt; AutoTest Functions &gt;&gt;=

class VBTestMaker(TestMaker):
	"""A Class to help in making VB unit tests"""
	
	default_filename = "testscript.bas"

	&lt;&lt; VBTestMaker methods &gt;&gt;</t>
<t tx="pap.120703001453.1161">&lt;&lt; VBTestMaker methods &gt;&gt;=

def makeTestForFunction(self, testid, modulename, fnname, paramlist):
	"""Make a VB test script for a function
	
	The function resides in a module and takes a list of parameters which
	are specified in paramlist. Paramlist also includes a list of values
	to pass as that particular parameter.
	
	The results of the test are written to a file testid
	
	"""
	ret = []
	ret.append("Dim Results()")
	ret.append("ReDim Results(0)")
	tabs = ""
	#
	for param, values in paramlist:
		ret.append("%sfor each %s in Array%s" % (tabs, param, tuple(values)))
		tabs += "\t"
	#
	arg_list = ",".join([param[0] for param in paramlist])
	ret.append("%sRedim Preserve Results(UBound(Results)+1)" % tabs)
	ret.append("%sAnswer = %s(%s)" % (tabs, fnname, arg_list))
	#
	result_list = ' &amp; "," &amp; '.join(["Str(%s)" % x for x in ["Answer"] + [param[0] for param in paramlist]])
	ret.append("%sResults(Ubound(Results)) = %s" % (tabs, result_list))
	#
	for param, values in paramlist:
		tabs = tabs[:-1]
		ret.append("Next %s" % param)
	#
	ret.extend(("Chn = NextFile",
				"Open '%s_vb.txt' For Output As #Chn" % testid,
				'Print #Chn, "# vb2Py Autotest results"',
				"For Each X In Results",
				"    Print #Chn, X",
				"Next X",
				"Close #Chn"))											 
	#
	return "\n".join(ret)</t>
<t tx="pap.120703001453.1162"></t>
<t tx="pap.120703001453.1163"></t>
<t tx="pap.120703001453.1164"></t>
<t tx="pap.120703001453.1165">ChDir Statement
See Also    Example    Specifics

Changes the current directory or folder.

Syntax

ChDir path

The required path argument is a string expression that identifies which directory or folder becomes the new default directory or folder. The path may include the drive. If no drive is specified, ChDir changes the default directory or folder on the current drive.

Remarks

The ChDir statement changes the default directory but not the default drive. For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:

ChDir "D:\TMP"   


</t>
<t tx="pap.120703001453.1166">


</t>
<t tx="pap.120703001453.1167">Kill Statement
See Also    Example    Specifics

Deletes files from a disk.

Syntax

Kill pathname

The required pathname argument is a string expression that specifies one or more file names to be deleted. The pathname may include the directory or folder, and the drive.

Remarks

In Microsoft Windows, Kill supports the use of multiple-character (*) and single-character (?) wildcards to specify multiple files
</t>
<t tx="pap.120703001453.1168">MkDir Statement
See Also    Example    Specifics

Creates a new directory or folder.

Syntax

MkDir path

The required path argument is a string expression that identifies the directory or folder to be created. The path may include the drive. If no drive is specified, MkDir creates the new directory or folder on the current drive.
</t>
<t tx="pap.120703001453.1169">RmDir Statement
See Also    Example    Specifics

Removes an existing directory or folder.

Syntax

RmDir path

The required path argument is a string expression that identifies the directory or folder to be removed. The path may include the drive. If no drive is specified, RmDir removes the directory or folder on the current drive.

Remarks

An error occurs if you try to use RmDir on a directory or folder containing files. Use the Kill statement to delete all files before attempting to remove a directory or folder.
</t>
<t tx="pap.120703001453.1170">Let Statement
See Also    Example    Specifics

Assigns the value of an expression to a variable or property.

Syntax

[Let] varname = expression

The Let statement syntax has these parts:

Part Description 
Let Optional. Explicit use of the Let keyword is a matter of style, but it is usually omitted. 
varname Required. Name of the variable or property; follows standard variable naming conventions. 
expression Required. Value assigned to the variable or property. 


Remarks

A value expression can be assigned to a variable or property only if it is of a data type that is compatible with the variable. You can't assign string expressions to numeric variables, and you can't assign numeric expressions to string variables. If you do, an error occurs at compile time.

Variant variables can be assigned either string or numeric expressions. However, the reverse is not always true. Any Variant except a Null can be assigned to a string variable, but only a Variant whose value can be interpreted as a number can be assigned to a numeric variable. Use the IsNumeric function to determine if the Variant can be converted to a number.

Caution   Assigning an expression of one numeric type to a variable of a different numeric type coerces the value of the expression into the numeric type of the resulting variable.

Let statements can be used to assign one record variable to another only when both variables are of the same user-defined type. Use the LSet statement to assign record variables of different user-defined types. Use the Set statement to assign object references to variables.
</t>
<t tx="pap.120703001453.1171">Name Statement
See Also    Example    Specifics

Renames a disk file, directory, or folder.

Syntax

Name oldpathname As newpathname

The Name statement syntax has these parts:

Part Description 
oldpathname Required. String expression that specifies the existing file name and location may include directory or folder, and drive.  
newpathname Required. String expression that specifies the new file name and location may include directory or folder, and drive. The file name specified by newpathname can't already exist. 


Remarks

The Name statement renames a file and moves it to a different directory or folder, if necessary. Name can move a file across drives, but it can only rename an existing directory or folder when both newpathname and oldpathname are located on the same drive. Name cannot create a new file, directory, or folder.

Using Name on an open file produces an error. You must close an open file before renaming it. Name arguments cannot include multiple-character (*) and single-character (?) wildcards.
</t>
<t tx="pap.120703001453.1172">FileCopy Statement
See Also    Example    Specifics

Copies a file.

Syntax

FileCopy source, destination

The FileCopy statement syntax has these named arguments:

Part Description 
source Required. String expression that specifies the name of the file to be copied. The source may include directory or folder, and drive. 
destination Required. String expression that specifies the target file name. The destination may include directory or folder, and drive. 


Remarks

If you try to use the FileCopy statement on a currently open file, an error occurs.
</t>
<t tx="pap.120703001453.1173">Rnd Function
See Also    Example    Specifics

Returns a Single containing a random number.

Syntax

Rnd[(number)]

The optional number argument is a Single or any valid numeric expression.

Return Values

If number is Rnd generates 
Less than zero The same number every time, using number as the seed. 
Greater than zero The next random number in the sequence. 
Equal to zero The most recently generated number. 
Not supplied The next random number in the sequence. 


Remarks

The Rnd function returns a value less than 1 but greater than or equal to zero.

The value of number determines how Rnd generates a random number:

For any given initial seed, the same number sequence is generated because each successive call to the Rnd function uses the previous number as a seed for the next number in the sequence.

Before calling Rnd, use the Randomize statement without an argument to initialize the random-number generator with a seed based on the system timer.

To produce random integers in a given range, use this formula:

Int((upperbound - lowerbound + 1) * Rnd + lowerbound)

Here, upperbound is the highest number in the range, and lowerbound is the lowest number in the range.

Note   To repeat sequences of random numbers, call Rnd with a negative argument immediately before using Randomize with a numeric argument. Using Randomize with the same value for number does not repeat the previous sequence.
</t>
<t tx="pap.120703001453.1174">Randomize Statement
See Also    Example    Specifics

Initializes the random-number generator.

Syntax

Randomize [number]

The optional number argument is a Variant or any valid numeric expression.

Remarks

Randomize uses number to initialize the Rnd function's random-number generator, giving it a new seed value. If you omit number, the value returned by the system timer is used as the new seed value.

If Randomize is not used, the Rnd function (with no arguments) uses the same number as a seed the first time it is called, and thereafter uses the last generated number as a seed value.

Note   To repeat sequences of random numbers, call Rnd with a negative argument immediately before using Randomize with a numeric argument. Using Randomize with the same value for number does not repeat the previous sequence.
</t>
<t tx="pap.120703001453.1175">Reset Statement
See Also    Example    Specifics

Closes all disk files opened using the Open statement.

Syntax

Reset

Remarks

The Reset statement closes all active files opened by the Open statement and writes the contents of all file buffers to disk.
</t>
<t tx="pap.120703001453.1176"></t>
<t tx="pap.120703001453.1177">GetSetting Function
See Also    Example    Specifics

Returns a key setting value from an application's entry in the Windows registry.

Syntax

GetSetting(appname, section, key[, default])

The GetSetting function syntax has these named arguments:

Part Description 
appname Required. String expression containing the name of the application or project whose key setting is requested. 
section Required. String expression containing the name of the section where the key setting is found. 
key Required. String expression containing the name of the key setting to return. 
default Optional. Expression containing the value to return if no value is set in the key setting. If omitted, default is assumed to be a zero-length string (""). 


Remarks

If any of the items named in the GetSetting arguments do not exist, GetSetting returns the value of default.
</t>
<t tx="pap.120703001453.1178">GetAllSettings Function
See Also    Example    Specifics

Returns a list of key settings and their respective values (originally created with SaveSetting) from an application's entry in the Windows registry.

Syntax

GetAllSettings(appname, section)

The GetAllSettings function syntax has these named arguments:

Part Description 
appname Required. String expression containing the name of the application or project whose key settings are requested. 
section Required. String expression containing the name of the section whose key settings are requested. GetAllSettings returns a Variant whose contents is a two-dimensional array of strings containing all the key settings in the specified section and their corresponding values. 


Remarks

GetAllSettings returns an uninitialized Variant if either appname or section does not exist.
</t>
<t tx="pap.120703001453.1179">DeleteSetting Statement
See Also    Example    Specifics

Deletes a section or key setting from an application's entry in the Windows registry.

Syntax

DeleteSetting appname, section[, key]

The DeleteSetting statement syntax has these named arguments:

Part Description 
appname Required. String expression containing the name of the application or project to which the section or key setting applies. 
section Required. String expression containing the name of the section where the key setting is being deleted. If only appname and section are provided, the specified section is deleted along with all related key settings. 
key Optional. String expression containing the name of the key setting being deleted. 


Remarks

If all arguments are provided, the specified setting is deleted. A run-time error occurs if you attempt to use the DeleteSetting statement on a non-existent section or key setting.
</t>
<t tx="pap.120703001453.1180">SaveSetting Statement
See Also    Example    Specifics

Saves or creates an application entry in the application's entry in the Windows registry.

Syntax

SaveSetting appname, section, key, setting

The SaveSetting statement syntax has these named arguments:

Part Description 
appname Required. String expression containing the name of the application or project to which the setting applies. 
section Required. String expression containing the name of the section where the key setting is being saved. 
key Required. String expression containing the name of the key setting being saved. 
setting Required. Expression containing the value that key is being set to. 


Remarks

An error occurs if the key setting cant be saved for any reason.
</t>
<t tx="pap.120703001453.1181">Erase Statement
See Also    Example    Specifics

Reinitializes the elements of fixed-size arrays and releases dynamic-array storage space.

Syntax

Erase arraylist

The required arraylist argument is one or more comma-delimited array variables to be erased.

Remarks

Erase behaves differently depending on whether an array is fixed-size (ordinary) or dynamic. Erase recovers no memory for fixed-size arrays. Erase sets the elements of a fixed array as follows:

Type of Array Effect of Erase on Fixed-Array Elements 
Fixed numeric array Sets each element to zero. 
Fixed string array (variable length) Sets each element to a zero-length string (""). 
Fixed string array (fixed length) Sets each element to zero. 
Fixed Variant array Sets each element to Empty. 
Array of user-defined types Sets each element as if it were a separate variable. 
Array of objects Sets each element to the special value Nothing. 


Erase frees the memory used by dynamic arrays. Before your program can refer to the dynamic array again, it must redeclare the array variable's dimensions using a ReDim statement.
</t>
<t tx="pap.120703001453.1182">LSet Statement
See Also    Example    Specifics

Left aligns a string within a string variable, or copies a variable of one user-defined type to another variable of a different user-defined type.

Syntax

LSet stringvar = string

LSet varname1 = varname2

The LSet statement syntax has these parts:

Part Description 
stringvar Required. Name of string variable. 
string Required. String expression to be left-aligned within stringvar. 
varname1 Required. Variable name of the user-defined type being copied to. 
varname2 Required. Variable name of the user-defined type being copied from. 


Remarks

LSet replaces any leftover characters in stringvar with spaces.

If string is longer than stringvar, LSet places only the leftmost characters, up to the length of the stringvar, in stringvar.

Warning   Using LSet to copy a variable of one user-defined type into a variable of a different user-defined type is not recommended. Copying data of one data type into space reserved for a different data type can cause unpredictable results.

When you copy a variable from one user-defined type to another, the binary data from one variable is copied into the memory space of the other, without regard for the data types specified for the elements.
</t>
<t tx="pap.120703001453.1183">RSet Statement
See Also    Example    Specifics

Right aligns a string within a string variable.

Syntax

RSet stringvar = string

The RSet statement syntax has these parts:

Part Description 
stringvar Required. Name of string variable. 
string Required. String expression to be right-aligned within stringvar. 


Remarks

If stringvar is longer than string, RSet replaces any leftover characters in stringvar with spaces, back to its beginning.

Note   RSet can't be used with user-defined types.
</t>
<t tx="pap.120703001453.1184">Array Function
See Also    Example    Specifics

Returns a Variant containing an array.

Syntax

Array(arglist)

The required arglist argument is a comma-delimited list of values that are assigned to the elements of the array contained within the Variant. If no arguments are specified, an array of zero length is created.

Remarks

The notation used to refer to an element of an array consists of the variable name followed by parentheses containing an index number indicating the desired element. In the following example, the first statement creates a variable named A as a Variant. The second statement assigns an array to variable A. The last statement assigns the value contained in the second array element to another variable.

Dim A As Variant
A = Array(10,20,30)
B = A(2)

The lower bound of an array created using the Array function is determined by the lower bound specified with the Option Base statement, unless Array is qualified with the name of the type library (for example VBA.Array). If qualified with the type-library name, Array is unaffected by Option Base.

Note   A Variant that is not declared as an array can still contain an array. A Variant variable can contain an array of any type, except fixed-length strings and user-defined types. Although a Variant containing an array is conceptually different from an array whose elements are of type Variant, the array elements are accessed in the same way.
</t>
<t tx="pap.120703001453.1185">IsArray Function
See Also    Example    Specifics

Returns a Boolean value indicating whether a variable is an array.

Syntax

IsArray(varname)

The required varname argument is an identifier specifying a variable.

Remarks

IsArray returns True if the variable is an array; otherwise, it returns False. IsArray is especially useful with variants containing arrays.
</t>
<t tx="pap.120703001453.1186">IIf Function
See Also    Example    Specifics

Returns one of two parts, depending on the evaluation of an expression.

Syntax

IIf(expr, truepart, falsepart)

The IIf function syntax has these named arguments:

Part Description 
expr Required. Expression you want to evaluate. 
truepart Required. Value or expression returned if expr is True. 
falsepart Required. Value or expression returned if expr is False. 


Remarks

IIf always evaluates both truepart and falsepart, even though it returns only one of them. Because of this, you should watch for undesirable side effects. For example, if evaluating falsepart results in a division by zero error, an error occurs even if expr is True.
</t>
<t tx="pap.120703001453.1187">StrReverse Function
See Also    Example    Specifics

Description

Returns a string in which the character order of a specified string is reversed.

Syntax

StrReverse(expression)

The expression argument is the string whose characters are to be reversed. If expression is a zero-length string (""), a zero-length string is returned. If expression is Null, an error occurs.
</t>
<t tx="pap.120703001453.1188">Choose Function
See Also    Example    Specifics

Selects and returns a value from a list of arguments.

Syntax

Choose(index, choice-1[, choice-2, ... [, choice-n]])

The Choose function syntax has these parts:

Part Description 
index Required. Numeric expression or field that results in a value between 1 and the number of available choices. 
choice Required. Variant expression containing one of the possible choices. 


Remarks

Choose returns a value from the list of choices based on the value of index. If index is 1, Choose returns the first choice in the list; if index is 2, it returns the second choice, and so on.

You can use Choose to look up a value in a list of possibilities. For example, if index evaluates to 3 and choice-1 = "one", choice-2 = "two", and choice-3 = "three", Choose returns "three". This capability is particularly useful if index represents the value in an option group.

Choose evaluates every choice in the list, even though it returns only one. For this reason, you should watch for undesirable side effects. For example, if you use the MsgBox function as part of an expression in all the choices, a message box will be displayed for each choice as it is evaluated, even though Choose returns the value of only one of them.

The Choose function returns a Null if index is less than 1 or greater than the number of choices listed.

If index is not a whole number, it is rounded to the nearest whole number before being evaluated.
</t>
<t tx="pap.120703001453.1189">Join Function
See Also    Example    Specifics

Description

Returns a string created by joining a number of substrings contained in an array.

Syntax

Join(sourcearray[, delimiter])

The Join function syntax has these named arguments:

Part Description 
sourcearray Required. One-dimensional array containing substrings to be joined. 
delimiter Optional. String character used to separate the substrings in the returned string. If omitted, the space character (" ") is used. If delimiter is a zero-length string (""), all items in the list are concatenated with no delimiters. 

</t>
<t tx="pap.120703001453.1190">Switch Function
See Also    Example    Specifics

Evaluates a list of expressions and returns a Variant value or an expression associated with the first expression in the list that is True.

Syntax

Switch(expr-1, value-1[, expr-2, value-2 [, expr-n,value-n]])

The Switch function syntax has these parts:

Part Description 
expr Required. Variant expression you want to evaluate. 
value Required. Value or expression to be returned if the corresponding expression is True. 


Remarks

The Switch function argument list consists of pairs of expressions and values. The expressions are evaluated from left to right, and the value associated with the first expression to evaluate to True is returned. If the parts aren't properly paired, a run-time error occurs. For example, if expr-1 is True, Switch returns value-1. If expr-1 is False, but expr-2 is True, Switch returns value-2, and so on.

Switch returns a Null value if: 

None of the expressions is True.


The first True expression has a corresponding value that is Null. 
Switch evaluates all of the expressions, even though it returns only one of them. For this reason, you should watch for undesirable side effects. For example, if the evaluation of any expression results in a division by zero error, an error occurs.
</t>
<t tx="pap.120703001453.1191">LTrim, RTrim, and Trim Functions
See Also    Example    Specifics

Returns a Variant (String) containing a copy of a specified string without leading spaces (LTrim), trailing spaces (RTrim), or both leading and trailing spaces (Trim).

Syntax

LTrim(string)

RTrim(string)

Trim(string)

The required string argument is any valid string expression. If string contains Null, Null is returned.
</t>
<t tx="pap.120703001453.1192">Spc Function
See Also    Example    Specifics

Used with the Print # statement or the Print method to position output.

Syntax

Spc(n)

The required n argument is the number of spaces to insert before displaying or printing the next expression in a list.

Remarks

If n is less than the output line width, the next print position immediately follows the number of spaces printed. If n is greater than the output line width, Spc calculates the next print position using the formula:

currentprintposition + (n Mod width)

For example, if the current print position is 24, the output line width is 80, and you specify Spc(90), the next print will start at position 34 (current print position + the remainder of 90/80). If the difference between the current print position and the output line width is less than n (or n Mod width), the Spc function skips to the beginning of the next line and generates spaces equal to n (width currentprintposition).

Note   Make sure your tabular columns are wide enough to accommodate wide letters.

When you use the Print method with a proportionally spaced font, the width of space characters printed using the Spc function is always an average of the width of all characters in the point size for the chosen font. However, there is no correlation between the number of characters printed and the number of fixed-width columns those characters occupy. For example, the uppercase letter W occupies more than one fixed-width column and the lowercase letter i occupies less than one fixed-width column.
</t>
<t tx="pap.120703001453.1193">Split Function
See Also    Example    Specifics

Description

Returns a zero-based, one-dimensional array containing a specified number of substrings.

Syntax

Split(expression[, delimiter[, limit[, compare]]])

The Split function syntax has these named arguments:

Part Description 
expression Required. String expression containing substrings and delimiters. If expression is a zero-length string(""), Split returns an empty array, that is, an array with no elements and no data. 
delimiter Optional. String character used to identify substring limits. If omitted, the space character (" ") is assumed to be the delimiter. If delimiter is a zero-length string, a single-element array containing the entire expression string is returned. 
limit Optional. Number of substrings to be returned; 1 indicates that all substrings are returned. 
compare Optional. Numeric value indicating the kind of comparison to use when evaluating substrings. See Settings section for values. 


Settings

The compare argument can have the following values:

Constant Value Description 
vbUseCompareOption 1 Performs a comparison using the setting of the Option Compare statement. 
vbBinaryCompare 0 Performs a binary comparison. 
vbTextCompare 1 Performs a textual comparison. 
vbDatabaseCompare 2 Microsoft Access only. Performs a comparison based on information in your database. 
</t>
<t tx="pap.120703001453.1194"></t>
<t tx="pap.120703001453.1195">CallByName Function
See Also    Example    Specifics

Executes a method of an object, or sets or returns a property of an object.

Syntax

CallByName(object, procname, calltype,[args()])

The CallByName function syntax has these named arguments:

Part Description 
object Required; Variant (Object). The name of the object on which the function will be executed. 
procname Required; Variant (String). A string expression containing the name of a property or method of the object. 
calltype Required; Constant. A constant of type vbCallType representing the type of procedure being called. 
args() Optional: Variant (Array). 


Remarks

The CallByName function is used to get or set a property, or invoke a method at run time using a string name.

In the following example, the first line uses CallByName to set the MousePointer property of a text box, the second line gets the value of the MousePointer property, and the third line invokes the Move method to move the text box:

CallByName Text1, "MousePointer", vbLet, vbCrosshair
Result = CallByName (Text1, "MousePointer", vbGet)
CallByName Text1, "Move", vbMethod, 100, 100

</t>
<t tx="pap.120703001453.1196">Environ Function
See Also    Example    Specifics

Returns the String associated with an operating system environment variable. 

Syntax

Environ({envstring | number})

The Environ function syntax has these named arguments:

Part Description 
envstring Optional. String expression containing the name of an environment variable. 
number Optional. Numeric expression corresponding to the numeric order of the environment string in the environment-string table. The number argument can be any numeric expression, but is rounded to a whole number before it is evaluated. 


Remarks

If envstring can't be found in the environment-string table, a zero-length string ("") is returned. Otherwise, Environ returns the text assigned to the specified envstring; that is, the text following the equal sign (=) in the environment-string table for that environment variable.

If you specify number, the string occupying that numeric position in the environment-string table is returned. In this case, Environ returns all of the text, including envstring. If there is no environment string in the specified position, Environ returns a zero-length string.
</t>
<t tx="pap.120703001453.1197">EOF Function
See Also    Example    Specifics

Returns an Integer containing the Boolean value True when the end of a file opened for Random or sequential Input has been reached.

Syntax

EOF(filenumber)

The required filenumber argument is an Integer containing any valid file number.

Remarks

Use EOF to avoid the error generated by attempting to get input past the end of a file.

The EOF function returns False until the end of the file has been reached. With files opened for Random or Binary access, EOF returns False until the last executed Get statement is unable to read an entire record.

With files opened for Binary access, an attempt to read through the file using the Input function until EOF returns True generates an error. Use the LOF and Loc functions instead of EOF when reading binary files with Input, or use Get when using the EOF function. With files opened for Output, EOF always returns True.
</t>
<t tx="pap.120703001453.1198">FileAttr Function
See Also    Example    Specifics

Returns a Long representing the file mode for files opened using the Open statement.

Syntax

FileAttr(filenumber, returntype)

The FileAttr function syntax has these named arguments:

Part Description 
filenumber Required; Integer. Any valid file number. 
returntype Required; Integer. Number indicating the type of information to return. Specify 1 to return a value indicating the file mode. On 16-bit systems only, specify 2 to retrieve an operating system file handle. Returntype 2 is not supported in 32-bit systems and causes an error. 


Return Values

When the returntype argument is 1, the following return values indicate the file access mode:

Mode Value 
Input 1 
Output 2 
Random 4 
Append 8 
Binary 32 
</t>
<t tx="pap.120703001453.1199">FileDateTime Function
See Also    Example    Specifics

Returns a Variant (Date) that indicates the date and time when a file was created or last modified.

Syntax

FileDateTime(pathname)

The required pathname argument is a string expression that specifies a file name. The pathname may include the directory or folder, and the drive.
</t>
<t tx="pap.120703001453.1200">FileLen Function
See Also    Example    Specifics

Returns a Long specifying the length of a file in bytes.

Syntax

FileLen(pathname)

The required pathname argument is a string expression that specifies a file. The pathname may include the directory or folder, and the drive.

Remarks

If the specified file is open when the FileLen function is called, the value returned represents the size of the file immediately before it was opened.

Note   To obtain the length of an open file, use the LOF function.
</t>
<t tx="pap.120703001453.1201">Filter Function
See Also    Example    Specifics

Description

Returns a zero-based array containing subset of a string array based on a specified filter criteria.

Syntax

Filter(sourcesrray, match[, include[, compare]])

The Filter function syntax has these named argument:

Part Description 
sourcearray Required. One-dimensional array of strings to be searched. 
match Required. String to search for. 
include Optional. Boolean value indicating whether to return substrings that include or exclude match. If include is True, Filter returns the subset of the array that contains match as a substring. If include is False, Filter returns the subset of the array that does not contain match as a substring. 
compare Optional. Numeric value indicating the kind of string comparison to use. See Settings section for values. 


Settings

The compare argument can have the following values:

Constant Value Description 
vbUseCompareOption 1 Performs a comparison using the setting of the Option Compare statement. 
vbBinaryCompare  0 Performs a binary comparison. 
vbTextCompare  1 Performs a textual comparison. 
vbDatabaseCompare  2 Microsoft Access only. Performs a comparison based on information in your database. 


Remarks

If no matches of match are found within sourcearray, Filter returns an empty array. An error occurs if sourcearray is Null or is not a one-dimensional array.

The array returned by the Filter function contains only enough elements to contain the number of matched items.
</t>
<t tx="pap.120703001453.1202">Format Function
See Also    Example    Specifics

Returns a Variant (String) containing an expression formatted according to instructions contained in a format expression.

Syntax

Format(expression[, format[, firstdayofweek[, firstweekofyear]]])

The Format function syntax has these parts:

Part Description 
expression Required. Any valid expression. 
format Optional. A valid named or user-defined format expression. 
firstdayofweek Optional. A constant that specifies the first day of the week. 
firstweekofyear Optional. A constant that specifies the first week of the year. 


Settings

The firstdayofweek argument has these settings:

Constant Value Description 
vbUseSystem 0 Use NLS API setting. 
VbSunday 1 Sunday (default) 
vbMonday 2 Monday 
vbTuesday 3 Tuesday 
vbWednesday 4 Wednesday 
vbThursday 5 Thursday 
vbFriday 6 Friday 
vbSaturday 7 Saturday 


The firstweekofyear argument has these settings:

Constant Value Description 
vbUseSystem 0 Use NLS API setting. 
vbFirstJan1 1 Start with week in which January 1 occurs (default). 
vbFirstFourDays 2 Start with the first week that has at least four days in the year. 
vbFirstFullWeek 3 Start with the first full week of the year. 


Remarks

To Format Do This 
Numbers Use predefined named numeric formats or create user-defined numeric formats. 
Dates and times Use predefined named date/time formats or create user-defined date/time formats. 
Date and time serial numbers Use date and time formats or numeric formats. 
Strings Create your own user-defined string formats. 


If you try to format a number without specifying format, Format provides functionality similar to the Str function, although it is internationally aware. However, positive numbers formatted as strings using Format dont include a leading space reserved for the sign of the value; those converted using Str retain the leading space.

If you are formatting a non-localized numeric string, you should use a user-defined numeric format to ensure that you get the look you want.

Note   If the Calendar property setting is Gregorian and format specifies date formatting, the supplied expression must be Gregorian. If the Visual Basic Calendar property setting is Hijri, the supplied expression must be Hijri.

If the calendar is Gregorian, the meaning of format expression symbols is unchanged. If the calendar is Hijri, all date format symbols (for example, dddd, mmmm, yyyy) have the same meaning but apply to the Hijri calendar. Format symbols remain in English; symbols that result in text display (for example, AM and PM) display the string (English or Arabic) associated with that symbol. The range of certain symbols changes when the calendar is Hijri.

Symbol Range 
d 1-30 
dd 1-30 
ww 1-51 
mmm Displays full month names (Hijri month names have no abbreviations). 
y 1-355 
yyyy 100-9666 
</t>
<t tx="pap.120703001453.1203">Input Function
See Also    Example    Specifics

Returns String containing characters from a file opened in Input or Binary mode.

Syntax

Input(number, [#]filenumber)

The Input function syntax has these parts:

Part Description 
number Required. Any valid numeric expression specifying the number of characters to return. 
filenumber Required. Any valid file number. 


Remarks

Data read with the Input function is usually written to a file with Print # or Put. Use this function only with files opened in Input or Binary mode.

Unlike the Input # statement, the Input function returns all of the characters it reads, including commas, carriage returns, linefeeds, quotation marks, and leading spaces.

With files opened for Binary access, an attempt to read through the file using the Input function until EOF returns True generates an error. Use the LOF and Loc functions instead of EOF when reading binary files with Input, or use Get when using the EOF function.

Note   Use the InputB function for byte data contained within text files. With InputB, number specifies the number of bytes to return rather than the number of characters to return.
</t>
<t tx="pap.120703001453.1204">InStrRev Function
See Also    Example    Specifics

Description

Returns the position of an occurrence of one string within another, from the end of string.

Syntax

InstrRev(stringcheck, stringmatch[, start[, compare]])

The InstrRev function syntax has these named arguments:

Part Description 
stringcheck Required. String expression being searched. 
stringmatch Required. String expression being searched for. 
start Optional. Numeric expression that sets the starting position for each search. If omitted, 1 is used, which means that the search begins at the last character position. If start contains 
Null, an error occurs.
 
compare Optional. Numeric value indicating the kind of comparison to use when evaluating substrings. If omitted, a binary comparison is performed. See Settings section for values. 


Settings

The compare argument can have the following values:

Constant Value Description 
vbUseCompareOption 1 Performs a comparison using the setting of the Option Compare statement. 
vbBinaryCompare  0 Performs a binary comparison. 
vbTextCompare  1 Performs a textual comparison. 
vbDatabaseCompare  2 Microsoft Access only. Performs a comparison based on information in your database. 


Return Values

InStrRev returns the following values:

If InStrRev returns 
stringcheck is zero-length 0 
stringcheck is Null  Null 
stringmatch is zero-length start 
stringmatch is Null Null 
stringmatch is not found 0 
stringmatch is found within stringcheck Position at which match is found 
start &gt; Len(stringmatch) 0 


Remarks

Note that the syntax for the InstrRev function is not the same as the syntax for the Instr function.
</t>
<t tx="pap.120703001453.1205">IsDate Function
See Also    Example    Specifics

Returns a Boolean value indicating whether an expression can be converted to a date.

Syntax

IsDate(expression)

The required expression argument is a Variant containing a date expression or string expression recognizable as a date or time.

Remarks

IsDate returns True if the expression is a date or is recognizable as a valid date; otherwise, it returns False. In Microsoft Windows, the range of valid dates is January 1, 100 A.D. through December 31, 9999 A.D.; the ranges vary among operating systems.
</t>
<t tx="pap.120703001453.1206">IsEmpty Function
See Also    Example    Specifics

Returns a Boolean value indicating whether a variable has been initialized.

Syntax

IsEmpty(expression)

The required expression argument is a Variant containing a numeric or string expression. However, because IsEmpty is used to determine if individual variables are initialized, the expression argument is most often a single variable name.

Remarks

IsEmpty returns True if the variable is uninitialized, or is explicitly set to Empty; otherwise, it returns False. False is always returned if expression contains more than one variable. IsEmpty only returns meaningful information for variants.
</t>
<t tx="pap.120703001453.1207">IsError Function
See Also    Example    Specifics

Returns a Boolean value indicating whether an expression is an error value.

Syntax

IsError(expression)

The required expression argument can be any valid expression.

Remarks

Error values are created by converting real numbers to error values using the CVErr function. The IsError function is used to determine if a numeric expression represents an error. IsError returns True if the expression argument indicates an error; otherwise, it returns False. 
</t>
<t tx="pap.120703001453.1208">IsObject Function
See Also    Example    Specifics

Returns a Boolean value indicating whether an identifier represents an object variable.

Syntax

IsObject(identifier)

The required identifier argument is a variable name.

Remarks

IsObject is useful only in determining whether a Variant is of VarType vbObject. This could occur if the Variant actually references (or once referenced) an object, or if it contains Nothing.

IsObject returns True if identifier is a variable declared with Object type or any valid class type, or if identifier is a Variant of VarType vbObject, or a user-defined object; otherwise, it returns False. IsObject returns True even if the variable has been set to Nothing.

Use error trapping to be sure that an object reference is valid.
</t>
<t tx="pap.120703001453.1209">Loc Function
See Also    Example    Specifics

Returns a Long specifying the current read/write position within an open file.

Syntax

Loc(filenumber)

The required filenumber argument is any valid Integer file number.

Remarks

The following describes the return value for each file access mode:

Mode Return Value 
Random Number of the last record read from or written to the file. 
Sequential Current byte position in the file divided by 128. However, information returned by Loc for sequential files is neither used nor required. 
Binary Position of the last byte read or written. 

</t>
<t tx="pap.120703001453.1210">LOF Function
See Also    Example    Specifics

Returns a Long representing the size, in bytes, of a file opened using the Open statement.

Syntax

LOF(filenumber)

The required filenumber argument is an Integer containing a valid file number.

Note   Use the FileLen function to obtain the length of a file that is not open.
</t>
<t tx="pap.120703001453.1211">Partition Function
See Also    Example    Specifics

Returns a Variant (String) indicating where a number occurs within a calculated series of ranges.

Syntax

Partition(number, start, stop, interval)

The Partition function syntax has these named arguments:

Part Description 
number Required. Whole number that you want to evaluate against the ranges. 
start Required. Whole number that is the start of the overall range of numbers. The number can't be less than 0. 
stop Required. Whole number that is the end of the overall range of numbers. The number can't be equal to or less than start. 


Remarks

The Partition function identifies the particular range in which number falls and returns a Variant (String) describing that range. The Partition function is most useful in queries. You can create a select query that shows how many orders fall within various ranges, for example, order values from 1 to 1000, 1001 to 2000, and so on.

The following table shows how the ranges are determined using three sets of start, stop, and interval parts. The First Range and Last Range columns show what Partition returns. The ranges are represented by lowervalue:uppervalue, where the low end (lowervalue) of the range is separated from the high end (uppervalue) of the range with a colon (:).

start stop interval Before First First Range Last Range After Last 
0 99 5 "   :-1" "      0:  4" "     95: 99" "   100:   " 
20 199 10 "   :  19" "    20:  29" "   190: 199" "   200:   " 
100 1010 20 "   :   99" "  100:  119" " 1000: 1010" " 1011:   " 


In the table shown above, the third line shows the result when start and stop define a set of numbers that can't be evenly divided by interval. The last range extends to stop (11 numbers) even though interval is 20.

If necessary, Partition returns a range with enough leading spaces so that there are the same number of characters to the left and right of the colon as there are characters in stop, plus one. This ensures that if you use Partition with other numbers, the resulting text will be handled properly during any subsequent sort operation.

If interval is 1, the range is number:number, regardless of the start and stop arguments. For example, if interval is 1, number is 100 and stop is 1000, Partition returns "  100:  100".

If any of the parts is Null, Partition returns a Null.
</t>
<t tx="pap.120703001453.1212">Replace Function
See Also    Example    Specifics

Description

Returns a string in which a specified substring has been replaced with another substring a specified number of times.

Syntax

Replace(expression, find, replace[, start[, count[, compare]]])

The Replace function syntax has these named arguments:

Part Description 
expression Required. String expression containing substring to replace. 
find Required. Substring being searched for. 
replace Required. Replacement substring. 
start Optional. Position within expression where substring search is to begin. If omitted, 1 is assumed. 
count Optional. Number of substring substitutions to perform. If omitted, the default value is 1, which means make all possible substitutions. 
compare Optional. Numeric value indicating the kind of comparison to use when evaluating substrings. See Settings section for values. 


Settings

The compare argument can have the following values:

Constant Value Description 
vbUseCompareOption 1 Performs a comparison using the setting of the Option Compare statement. 
vbBinaryCompare 0 Performs a binary comparison. 
vbTextCompare 1 Performs a textual comparison. 
vbDatabaseCompare 2 Microsoft Access only. Performs a comparison based on information in your database. 


Return Values

Replace returns the following values:

If Replace returns 
expression is zero-length Zero-length string ("") 
expression is Null An error. 
find is zero-length Copy of expression. 
replace is zero-length Copy of expression with all occurences of find removed. 
start &gt; Len(expression) Zero-length string. 
count is 0 Copy of expression. 


Remarks

The return value of the Replace function is a string, with substitutions made, that begins at the position specified by start and and concludes at the end of the expression string. It is not a copy of the original string from start to finish.
</t>
<t tx="pap.120703001453.1213">RGB Function
See Also    Example    Specifics

Returns a Long whole number representing an RGB color value.

Syntax

RGB(red, green, blue)

The RGB function syntax has these named arguments:

Part Description 
red Required; Variant (Integer). Number in the range 0255, inclusive, that represents the red component of the color. 
green Required; Variant (Integer). Number in the range 0255, inclusive, that represents the green component of the color. 
blue Required; Variant (Integer). Number in the range 0255, inclusive, that represents the blue component of the color. 


Remarks

Application methods and properties that accept a color specification expect that specification to be a number representing an RGB color value. An RGB color value specifies the relative intensity of red, green, and blue to cause a specific color to be displayed.

The value for any argument to RGB that exceeds 255 is assumed to be 255.

The following table lists some standard colors and the red, green, and blue values they include:

Color Red Value Green Value Blue Value 
Black 0 0 0 
Blue 0 0 255 
Green 0 255 0 
Cyan 0 255 255 
Red 255 0 0 
Magenta 255 0 255 
Yellow 255 255 0 
White 255 255 255 
</t>
<t tx="pap.120703001453.1214">Round Function
See Also    Example    Specifics

Description

Returns a number rounded to a specified number of decimal places.

Syntax

Round(expression [,numdecimalplaces])

The Round function syntax has these parts:

Part Description 
expression Required. Numeric expression being rounded. 
numdecimalplaces Optional. Number indicating how many places to the right of the decimal are included in the rounding. If omitted, integers are returned by the Round function. 

</t>
<t tx="pap.120703001453.1215">Shell Function
See Also    Example    Specifics

Runs an executable program and returns a Variant (Double) representing the program's task ID if successful, otherwise it returns zero.

Syntax

Shell(pathname[,windowstyle])

The Shell function syntax has these named arguments:

Part Description 
pathname Required; Variant (String). Name of the program to execute and any required arguments or command-line switches; may include directory or folder and drive. 
windowstyle Optional. Variant (Integer) corresponding to the style of the window in which the program is to be run. If windowstyle is omitted, the program is started minimized with focus. 


The windowstyle named argument has these values:

Constant Value Description 
vbHide 0 Window is hidden and focus is passed to the hidden window.  
vbNormalFocus 1 Window has focus and is restored to its original size and position. 
vbMinimizedFocus 2 Window is displayed as an icon with focus. 
vbMaximizedFocus 3 Window is maximized with focus. 
vbNormalNoFocus 4 Window is restored to its most recent size and position. The currently active window remains active. 
vbMinimizedNoFocus 6 Window is displayed as an icon. The currently active window remains active. 


Remarks

If the Shell function successfully executes the named file, it returns the task ID of the started program. The task ID is a unique number that identifies the running program. If the Shell function can't start the named program, an error occurs.

Note   By default, the Shell function runs other programs asynchronously. This means that a program started with Shell might not finish executing before the statements following the Shell function are executed. 
</t>
<t tx="pap.120703001453.1216">Timer Function
See Also    Example    Specifics

Returns a Single representing the number of seconds elapsed since midnight.

Syntax

Timer

Remarks

In Microsoft Windows the Timer function returns fractional portions of a second. 
</t>
<t tx="pap.120703001453.1217">SetAttr Statement
See Also    Example    Specifics

Sets attribute information for a file.

Syntax

SetAttr pathname, attributes

The SetAttr statement syntax has these named arguments:

Part Description 
pathname Required. String expression that specifies a file name may include directory or folder, and drive.  
attributes Required. Constant or numeric expression, whose sum specifies file attributes. 


Settings

The attributes argument settings are:

Constant Value Description 
vbNormal 0 Normal (default). 
vbReadOnly 1 Read-only. 
vbHidden 2 Hidden. 
vbSystem 4 System file. 
vbArchive 32 File has changed since last backup. 


Note   These constants are specified by Visual Basic for Applications. The names can be used anywhere in your code in place of the actual values.

Remarks

A run-time error occurs if you try to set the attributes of an open file.
</t>
<t tx="pap.120703001453.1218">GetAttr Function
See Also    Example    Specifics

Returns an Integer representing the attributes of a file, directory, or folder.

Syntax

GetAttr(pathname)

The required pathname argument is a string expression that specifies a file name. The pathname may include the directory or folder, and the drive.

Return Values

The value returned by GetAttr is the sum of the following attribute values:

Constant Value Description 
vbNormal 0 Normal. 
vbReadOnly 1 Read-only. 
vbHidden 2 Hidden. 
vbSystem 4 System file. 
vbDirectory 16 Directory or folder. 
vbArchive 32 File has changed since last backup. 


Note   These constants are specified by Visual Basic for Applications. The names can be used anywhere in your code in place of the actual values.

Remarks

To determine which attributes are set, use the And operator to perform a bitwise comparison of the value returned by the GetAttr function and the value of the individual file attribute you want. If the result is not zero, that attribute is set for the named file. For example, the return value of the following And expression is zero if the Archive attribute is not set:

Result = GetAttr(FName) And vbArchive

A nonzero value is returned if the Archive attribute is set.
</t>
<t tx="pap.120703001453.1219"></t>
<t tx="pap.120703001453.1220">Get Statement
See Also    Example    Specifics

Reads data from an open disk file into a variable.

Syntax

Get [#]filenumber, [recnumber], varname 

The Get statement syntax has these parts:

Part Description 
filenumber Required. Any valid file number. 
recnumber Optional. Variant (Long). Record number (Random mode files) or byte number (Binary mode files) at which reading begins. 
varname Required. Valid variable name into which data is read. 


Remarks

Data read with Get is usually written to a file with Put.

The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit recnumber, the next record or byte following the last Get or Put statement (or pointed to by the last Seek function) is read. You must include delimiting commas, for example:

Get #4,,FileBuffer

For files opened in Random mode, the following rules apply: 

If the length of the data being read is less than the length specified in the Len clause of the Open statement, Get reads subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data can't be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.


If the variable being read into is a variable-length string, Get reads a 2-byte descriptor containing the string length and then reads the data that goes into the variable. Therefore, the record length specified by the Len clause in the Open statement must be at least 2 bytes greater than the actual length of the string.


If the variable being read into is a Variant of numeric type, Get reads 2 bytes identifying the VarType of the Variant and then the data that goes into the variable. For example, when reading a Variant of VarType 3, Get reads 6 bytes: 2 bytes identifying the Variant as VarType 3 (Long) and 4 bytes containing the Long data. The record length specified by the Len clause in the Open statement must be at least 2 bytes greater than the actual number of bytes required to store the variable. 
Note   You can use the Get statement to read a Variant array from disk, but you can't use Get to read a scalar Variant containing an array. You also can't use Get to read objects from disk.

If the variable being read into is a Variant of VarType 8 (String), Get reads 2 bytes identifying the VarType, 2 bytes indicating the length of the string, and then reads the string data. The record length specified by the Len clause in the Open statement must be at least 4 bytes greater than the actual length of the string.


If the variable being read into is a dynamic array, Get reads a descriptor whose length equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified by the Len clause in the Open statement must be greater than or equal to the sum of all the bytes required to read the array data and the array descriptor. For example, the following array declaration requires 118 bytes when the array is written to disk. 
Dim MyArray(1 To 5,1 To 10) As Integer

The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 2).

If the variable being read into is a fixed-size array, Get reads only the data. No descriptor is read.


If the variable being read into is any other type of variable (not a variable-length string or a Variant), Get reads only the variable data. The record length specified by the Len clause in the Open statement must be greater than or equal to the length of the data being read.


Get reads elements of user-defined types as if each were being read individually, except that there is no padding between elements. On disk, a dynamic array in a user-defined type (written with Put) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified by the Len clause in the Open statement must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors. 
For files opened in Binary mode, all of the Random rules apply, except: 

The Len clause in the Open statement has no effect. Get reads all variables from disk contiguously; that is, with no padding between records.


For any array other than an array in a user-defined type, Get reads only the data. No descriptor is read.


Get reads variable-length strings that aren't elements of user-defined types without expecting the 2-byte length descriptor. The number of bytes read equals the number of characters already in the string. For example, the following statements read 10 bytes from file number 1: 
VarString = String(10," ")
Get #1,,VarString

</t>
<t tx="pap.120703001453.1221">Put Statement
See Also    Example    Specifics

Writes data from a variable to a disk file.

Syntax

Put [#]filenumber, [recnumber], varname

The Put statement syntax has these parts:

Part Description 
filenumber Required. Any valid file number. 
recnumber Optional. Variant (Long). Record number (Random mode files) or byte number (Binary mode files) at which writing begins. 
varname Required. Name of variable containing data to be written to disk. 


Remarks

Data written with Put is usually read from a file with Get.

The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you omit recnumber, the next record or byte after the last Get or Put statement or pointed to by the last Seek function is written. You must include delimiting commas, for example:

Put #4,,FileBuffer

For files opened in Random mode, the following rules apply: 

If the length of the data being written is less than the length specified in the Len clause of the Open statement, Put writes subsequent records on record-length boundaries. The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer. Because the amount of padding data can't be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written. If the length of the data being written is greater than the length specified in the Len clause of the Open statement, an error occurs.


If the variable being written is a variable-length string, Put writes a 2-byte descriptor containing the string length and then the variable. The record length specified by the Len clause in the Open statement must be at least 2 bytes greater than the actual length of the string.


If the variable being written is a Variant of a numeric type, Put writes 2 bytes identifying the VarType of the Variant and then writes the variable. For example, when writing a Variant of VarType 3, Put writes 6 bytes: 2 bytes identifying the Variant as VarType 3 (Long) and 4 bytes containing the Long data. The record length specified by the Len clause in the Open statement must be at least 2 bytes greater than the actual number of bytes required to store the variable. 
Note   You can use the Put statement to write a Variant array to disk, but you can't use Put to write a scalar Variant containing an array to disk. You also can't use Put to write objects to disk. 

If the variable being written is a Variant of VarType 8 (String), Put writes 2 bytes identifying the VarType, 2 bytes indicating the length of the string, and then writes the string data. The record length specified by the Len clause in the Open statement must be at least 4 bytes greater than the actual length of the string.


If the variable being written is a dynamic array, Put writes a descriptor whose length equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified by the Len clause in the Open statement must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor. For example, the following array declaration requires 118 bytes when the array is written to disk. 
Dim MyArray(1 To 5,1 To 10) As Integer

The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 2).


If the variable being written is a fixed-size array, Put writes only the data. No descriptor is written to disk.


If the variable being written is any other type of variable (not a variable-length string or a Variant), Put writes only the variable data. The record length specified by the Len clause in the Open statement must be greater than or equal to the length of the data being written.


Put writes elements of user-defined types as if each were written individually, except there is no padding between elements. On disk, a dynamic array in a user-defined type written with Put is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified by the Len clause in the Open statement must be greater than or equal to the sum of all the bytes required to write the individual elements, including any arrays and their descriptors. 
For files opened in Binary mode, all of the Random rules apply, except: 

The Len clause in the Open statement has no effect. Put writes all variables to disk contiguously; that is, with no padding between records.


For any array other than an array in a user-defined type, Put writes only the data. No descriptor is written.


Put writes variable-length strings that are not elements of user-defined types without the 2-byte length descriptor. The number of bytes written equals the number of characters in the string. For example, the following statements write 10 bytes to file number 1: 
VarString$ = String$(10," ")
Put #1,,VarString$

</t>
<t tx="pap.120703001453.1222">Width # Statement
See Also    Example    Specifics

Assigns an output line width to a file opened using the Open statement.

Syntax

Width #filenumber, width

The Width # statement syntax has these parts:

Part Description 
filenumber Required. Any valid file number. 
width Required. Numeric expression in the range 0255, inclusive, that indicates how many characters appear on a line before a new line is started. If width equals 0, there is no limit to the length of a line. The default value for width is 0. 

</t>
<t tx="pap.120703001453.1223">AppActivate title[, wait]

The AppActivate statement syntax has these named arguments:

Part Description 
title Required. String expression specifying the title in the title bar of the application window you want to activate. The task ID returned by the Shell function can be used in place of title to activate an application. 
wait Optional. Boolean value specifying whether the calling application has the focus before activating another. If False (default), the specified application is immediately activated, even if the calling application does not have the focus. If True, the calling application waits until it has the focus, then activates the specified application. 


Remarks

The AppActivate statement changes the focus to the named application or window but does not affect whether it is maximized or minimized. Focus moves from the activated application window when the user takes some action to change the focus or close the window. Use the Shell function to start an application and set the window style.

In determining which application to activate, title is compared to the title string of each running application. If there is no exact match, any application whose title string begins with title is activated. If there is more than one instance of the application named by title, one instance is arbitrarily activated.
</t>
<t tx="pap.120703001453.1224">Beep Statement
See Also    Example    Specifics

Sounds a tone through the computer's speaker.

Syntax

Beep

Remarks

The frequency and duration of the beep depend on your hardware and system software, and vary among computers.
</t>
<t tx="pap.120703001453.1225">Deftype Statements
See Also    Example    Specifics

Used at module level to set the default data type for variables, arguments passed to procedures, and the return type for Function and Property Get procedures whose names start with the specified characters.

Syntax

DefBool letterrange[, letterrange] . . .

DefByte letterrange[, letterrange] . . .

DefInt letterrange[, letterrange] . . .

DefLng letterrange[, letterrange] . . .

DefCur letterrange[, letterrange] . . .

DefSng letterrange[, letterrange] . . .

DefDbl letterrange[, letterrange] . . .

DefDec letterrange[, letterrange] . . .

DefDate letterrange[, letterrange] . . .

DefStr letterrange[, letterrange] . . .

DefObj letterrange[, letterrange] . . .

DefVar letterrange[, letterrange] . . .

The required letterrange argument has the following syntax:

letter1[-letter2]

The letter1 and letter2 arguments specify the name range for which you can set a default data type. Each argument represents the first letter of the variable, argument, Function procedure, or Property Get procedure name and can be any letter of the alphabet. The case of letters in letterrange isn't significant.

Remarks

The statement name determines the data type:

Statement Data Type 
DefBool Boolean 
DefByte Byte 
DefInt Integer 
DefLng Long 
DefCur Currency 
DefSng Single 
DefDbl Double 
DefDec Decimal (not currently supported) 
DefDate Date 
DefStr String 
DefObj Object 
DefVar Variant 


For example, in the following program fragment, Message is a string variable:

DefStr A-Q
. . .
Message = "Out of stack space."

A Deftype statement affects only the module where it is used. For example, a DefInt statement in one module affects only the default data type of variables, arguments passed to procedures, and the return type for Function and Property Get procedures declared in that module; the default data type of variables, arguments, and return types in other modules is unaffected. If not explicitly declared with a Deftype statement, the default data type for all variables, all arguments, all Function procedures, and all Property Get procedures is Variant.

When you specify a letter range, it usually defines the data type for variables that begin with letters in the first 128 characters of the character set. However, when you specify the letter range AZ, you set the default to the specified data type for all variables, including variables that begin with international characters from the extended part of the character set (128255).

Once the range AZ has been specified, you can't further redefine any subranges of variables using Deftype statements. Once a range has been specified, if you include a previously defined letter in another Deftype statement, an error occurs. However, you can explicitly specify the data type of any variable, defined or not, using a Dim statement with an As type clause. For example, you can use the following code at module level to define a variable as a Double even though the default data type is Integer:

DefInt A-Z
Dim TaxRate As Double

Deftype statements don't affect elements of user-defined types because the elements must be explicitly declared.
</t>
<t tx="pap.120703001453.1226">GoSub...Return Statement
See Also    Example    Specifics

Branches to and returns from a subroutine within a procedure.

Syntax

GoSub line
...
line
...

Return

The line argument can be any line label or line number.

Remarks

You can use GoSub and Return anywhere in a procedure, but GoSub and the corresponding Return statement must be in the same procedure. A subroutine can contain more than one Return statement, but the first Return statement encountered causes the flow of execution to branch back to the statement immediately following the most recently executed GoSub statement.

Note   You can't enter or exit Sub procedures with GoSub...Return.

Tip   Creating separate procedures that you can call may provide a more structured alternative to using GoSub...Return.
</t>
<t tx="pap.120703001453.1227">GoTo Statement
See Also    Example    Specifics

Branches unconditionally to a specified line within a procedure.

Syntax

GoTo line

The required line argument can be any line label or line number.

Remarks

GoTo can branch only to lines within the procedure where it appears.

Note   Too many GoTo statements can make code difficult to read and debug. Use structured control statements (Do...Loop, For...Next, If...Then...Else, Select Case) whenever possible.
</t>
<t tx="pap.120703001453.1228">Implements Statement
See Also    Example    Specifics

Specifies an interface or class that will be implemented in the class module in which it appears.

Syntax

Implements [InterfaceName | Class]

The required InterfaceName or Class is the name of an interface or class in a type library whose methods will be implemented by the corresponding methods in the Visual Basic class.

Remarks

An interface is a collection of prototypes representing the members (methods and properties) the interface encapsulates; that is, it contains only the declarations for the member procedures. A class provides an implementation of all of the methods and properties of one or more interfaces. Classes provide the code used when each function is called by a controller of the class. All classes implement at least one interface, which is considered the default interface of the class. In Visual Basic, any member that isn't explicitly a member of an implemented interface is implicitly a member of the default interface.

When a Visual Basic class implements an interface, the Visual Basic class provides its own versions of all the Public procedures specified in the type library of the Interface. In addition to providing a mapping between the interface prototypes and your procedures, the Implements statement causes the class to accept COM QueryInterface calls for the specified interface ID.

Note   Visual Basic does not implement derived classes or interfaces.

When you implement an interface or class, you must include all the Public procedures involved. A missing member in an implementation of an interface or class causes an error. If you don't place code in one of the procedures in a class you are implementing, you can raise the appropriate error (Const E_NOTIMPL = &amp;H80004001) so a user of the implementation understands that a member is not implemented.

The Implements statement can't appear in a standard module.
</t>
<t tx="pap.120703001453.1229">Load Statement
See Also    Example

Loads a form or control into memory.

Syntax

Load object

The object placeholder is the name of a Form object, MDIForm object, or control array element to load.

Remarks

You don't need to use the Load statement with forms unless you want to load a form without displaying it. Any reference to a form (except in a Set or If...TypeOf statement) automatically loads it if it's not already loaded. For example, the Show method loads a form before displaying it. Once the form is loaded, its properties and controls can be altered by the application, whether or not the form is actually visible. Under some circumstances, you may want to load all your forms during initialization and display them later as they're needed.

When Visual Basic loads a Form object, it sets form properties to their initial values and then performs the Load event procedure. When an application starts, Visual Basic automatically loads and displays the application's startup form.

If you load a Form whose MDIChild property is set to True (in other words, the child form) before loading an MDIForm, the MDIForm is automatically loaded before the child form. MDI child forms cannot be hidden, and thus are immediately visible after the Form_Load event procedure ends.

The standard dialog boxes produced by Visual Basic functions such as MsgBox and InputBox do not need to be loaded, shown, or unloaded, but can simply be invoked directly.
</t>
<t tx="pap.120703001453.1230">Lock, Unlock Statements
See Also    Example    Specifics

Controls access by other processes to all or part of a file opened using the Open statement.

Syntax

Lock [#]filenumber[, recordrange]
. . .

Unlock [#]filenumber[, recordrange]

The Lock and Unlock statement syntax has these parts:

Part Description 
filenumber Required. Any valid file number. 
recordrange Optional. The range of records to lock or unlock. 


Settings

The recordrange argument settings are:

recnumber | [start] To end

Setting Description 
recnumber Record number (Random mode files) or byte number (Binary mode files) at which locking or unlocking begins. 
start Number of the first record or byte to lock or unlock. 
end Number of the last record or byte to lock or unlock. 


Remarks

The Lock and Unlock statements are used in environments where several processes might need access to the same file.

Lock and Unlock statements are always used in pairs. The arguments to Lock and Unlock must match exactly.

The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on. If you specify just one record, then only that record is locked or unlocked. If you specify a range of records and omit a starting record (start), all records from the first record to the end of the range (end) are locked or unlocked. Using Lock without recnumber locks the entire file; using Unlock without recnumber unlocks the entire file.

If the file has been opened for sequential input or output, Lock and Unlock affect the entire file, regardless of the range specified by start and end.

Caution   Be sure to remove all locks with an Unlock statement before closing a file or quitting your program. Failure to remove locks produces unpredictable results.
</t>
<t tx="pap.120703001453.1231">Option Base Statement
See Also    Example    Specifics

Used at module level to declare the default lower bound for array subscripts.

Syntax

Option Base {0 | 1}

Remarks

Because the default base is 0, the Option Base statement is never required. If used, the statement must appear in a module before any procedures. Option Base can appear only once in a module and must precede array declarations that include dimensions.

Note   The To clause in the Dim, Private, Public, ReDim, and Static statements provides a more flexible way to control the range of an array's subscripts. However, if you don't explicitly set the lower bound with a To clause, you can use Option Base to change the default lower bound to 1.  The base of an array created with the the ParamArray keyword is zero; Option Base does not affect ParamArray (or the Array function, when qualified with the name of its type library, for example VBA.Array).

The Option Base statement only affects the lower bound of arrays in the module where the statement is located.
</t>
<t tx="pap.120703001453.1232">Option Compare Statement
See Also    Example    Specifics

Used at module level to declare the default comparison method to use when string data is compared.

Syntax

Option Compare {Binary | Text | Database}

Remarks

If used, the Option Compare statement must appear in a module before any procedures.

The Option Compare statement specifies the string comparison method (Binary, Text, or Database) for a module. If a module doesn't include an Option Compare statement, the default text comparison method is Binary.

Option Compare Binary results in string comparisons based on a sort order derived from the internal binary representations of the characters. In Microsoft Windows, sort order is determined by the code page. A typical binary sort order is shown in the following example:

A &lt; B &lt; E &lt; Z &lt; a &lt; b &lt; e &lt; z &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 

Option Compare Text results in string comparisons based on a case-insensitive text sort order determined by your system's locale. When the same characters are sorted using Option Compare Text, the following text sort order is produced:

(A=a) &lt; ( =) &lt; (B=b) &lt; (E=e) &lt; (=) &lt; (Z=z) &lt; (=) 

Option Compare Database can only be used within Microsoft Access. This results in string comparisons based on the sort order determined by the locale ID of the database where the string comparisons occur.
</t>
<t tx="pap.120703001453.1233">Option Explicit Statement
See Also    Example    Specifics

Used at module level to force explicit declaration of all variables in that module.

Syntax

Option Explicit

Remarks

If used, the Option Explicit statement must appear in a module before any procedures.

When Option Explicit appears in a module, you must explicitly declare all variables using the Dim, Private, Public, ReDim, or Static statements. If you attempt to use an undeclared variable name, an error occurs at compile time.

If you don't use the Option Explicit statement, all undeclared variables are of Variant type unless the default type is otherwise specified with a Deftype statement.

Note   Use Option Explicit to avoid incorrectly typing the name of an existing variable or to avoid confusion in code where the scope of the variable is not clear.
</t>
<t tx="pap.120703001453.1234">Option Explicit Statement
See Also    Example    Specifics

Used at module level to force explicit declaration of all variables in that module.

Syntax

Option Explicit

Remarks

If used, the Option Explicit statement must appear in a module before any procedures.

When Option Explicit appears in a module, you must explicitly declare all variables using the Dim, Private, Public, ReDim, or Static statements. If you attempt to use an undeclared variable name, an error occurs at compile time.

If you don't use the Option Explicit statement, all undeclared variables are of Variant type unless the default type is otherwise specified with a Deftype statement.

Note   Use Option Explicit to avoid incorrectly typing the name of an existing variable or to avoid confusion in code where the scope of the variable is not clear.
</t>
<t tx="pap.120703001453.1235">RaiseEvent Statement
See Also    Example    Specifics

Fires an event declared at module level within a class, form, or document.

Syntax

RaiseEvent eventname [(argumentlist)]

The required eventname is the name of an event declared within the module and follows Basic variable naming conventions.

The RaiseEvent statement syntax has these parts:

Part Description 
eventname Required. Name of the event to fire. 
argumentlist Optional. Comma-delimited list of variables, arrays, or expressions The argumentlist must be enclosed by parentheses. If there are no arguments, the parentheses must be omitted. 


Remarks

If the event has not been declared within the module in which it is raised, an error occurs. The following fragment illustrates an event declaration and a procedure in which the event is raised.

' Declare an event at module level of a class module
Event LogonCompleted (UserName as String)

Sub
   ' Raise the event.
   RaiseEvent LogonCompleted ("AntoineJan")
End Sub

If the event has no arguments, including empty parentheses, in the RaiseEvent, invocation of the event causes an error. You can't use RaiseEvent to fire events that are not explicitly declared in the module. For example, if a form has a Click event, you can't fire its Click event using RaiseEvent. If you declare a Click event in the form module, it shadows the forms own Click event. You can still invoke the forms Click event using normal syntax for calling the event, but not using the RaiseEvent statement.

Event firing is done in the order that the connections are established. Since events can have ByRef parameters, a process that connects late may receive parameters that have been changed by an earlier event handler.
</t>
<t tx="pap.120703001453.1236">SavePicture Statement
See Also    Example

Saves a graphic from the Picture or Image property of an object or control (if one is associated with it) to a file.

Syntax

SavePicture picture, stringexpression

The SavePicture statement syntax has these parts:

Part Description 
picture Picture or Image control from which the graphics file is to be created. 
stringexpression Filename of the graphics file to save. 


Remarks

If a graphic was loaded from a file to the Picture property of an object, either at design time or at run time, and its a bitmap, icon, metafile, or enhanced metafile, it's saved using the same format as the original file. If it is a GIF or JPEG file, it is saved as a bitmap file.

Graphics in an Image property are always saved as bitmap (.bmp) files regardless of their original format.
</t>
<t tx="pap.120703001453.1237">SendKeys Statement
See Also    Example    Specifics

Sends one or more keystrokes to the active window as if typed at the keyboard.

Syntax

SendKeys string[, wait]

The SendKeys statement syntax has these named arguments:

Part Description 
string Required. String expression specifying the keystrokes to send. 
Wait Optional. Boolean value specifying the wait mode. If False (default), control is returned to the procedure immediately after the keys are sent. If True, keystrokes must be processed before control is returned to the procedure. 


Remarks

Each key is represented by one or more characters. To specify a single keyboard character, use the character itself. For example, to represent the letter A, use "A" for string. To represent more than one character, append each additional character to the one preceding it. To represent the letters A, B, and C, use "ABC" for string.

The plus sign (+), caret (^), percent sign (%), tilde (~), and parentheses ( ) have special meanings to SendKeys. To specify one of these characters, enclose it within braces ({}). For example, to specify the plus sign, use {+}. Brackets ([ ]) have no special meaning to SendKeys, but you must enclose them in braces. In other applications, brackets do have a special meaning that may be significant when dynamic data exchange (DDE) occurs. To specify brace characters, use {{} and {}}.

To specify characters that aren't displayed when you press a key, such as ENTER or TAB, and keys that represent actions rather than characters, use the codes shown below:

Key Code 
BACKSPACE {BACKSPACE}, {BS}, or {BKSP} 
BREAK {BREAK} 
CAPS LOCK {CAPSLOCK} 
DEL or DELETE {DELETE} or {DEL} 
DOWN ARROW {DOWN} 
END {END} 
ENTER  {ENTER}or ~ 
ESC {ESC} 
HELP {HELP} 
HOME {HOME} 
INS or INSERT {INSERT} or {INS} 
LEFT ARROW {LEFT} 
NUM LOCK {NUMLOCK} 
PAGE DOWN {PGDN} 
PAGE UP {PGUP} 
PRINT SCREEN {PRTSC} 
RIGHT ARROW {RIGHT} 
SCROLL LOCK {SCROLLLOCK} 
TAB {TAB} 
UP ARROW {UP} 
F1 {F1} 
F2 {F2} 
F3 {F3} 
F4 {F4} 
F5 {F5} 
F6 {F6} 
F7 {F7} 
F8 {F8} 
F9 {F9} 
F10 {F10} 
F11 {F11} 
F12 {F12} 
F13 {F13} 
F14 {F14} 
F15 {F15} 
F16 {F16} 


To specify keys combined with any combination of the SHIFT, CTRL, and ALT keys, precede the key code with one or more of the following codes:

Key Code 
SHIFT + 
CTRL  ^ 
ALT % 


To specify that any combination of SHIFT, CTRL, and ALT should be held down while several other keys are pressed, enclose the code for those keys in parentheses. For example, to specify to hold down SHIFT while E and C are pressed, use "+(EC)". To specify to hold down SHIFT while E is pressed, followed by C without SHIFT, use "+EC".

To specify repeating keys, use the form {key number}. You must put a space between key and number. For example, {LEFT 42} means press the LEFT ARROW key 42 times; {h 10} means press H 10 times.

Note   You can't use SendKeys to send keystrokes to an application that is not designed to run in Microsoft Windows. Sendkeys also can't send the PRINT SCREEN key {PRTSC} to any application.
</t>
<t tx="pap.120703001453.1238">Static Statement
See Also    Example    Specifics

Used at procedure level to declare variables and allocate storage space. Variables declared with the Static statement retain their values as long as the code is running.

Syntax

Static varname[([subscripts])] [As [New] type] [, varname[([subscripts])] [As [New] type]] . . .

The Static statement syntax has these parts:

Part Description 
varname Required. Name of the variable; follows standard variable naming conventions. 
subscripts Optional. Dimensions of an array variable; up to 60 multiple dimensions may be declared. The subscripts argument uses the following syntax: 
[lower To] upper [,[lower To] upper] . . .

When not explicitly stated in lower, the lower bound of an array is controlled by the Option Base statement. The lower bound is zero if no Option Base statement is present.
 
New Optional. Keyword that enables implicit creation of an object. If you use New when declaring the object variable, a new instance of the object is created on first reference to it, so you don't have to use the Set statement to assign the object reference. The New keyword can't be used to declare variables of any intrinsic data type and can't be used to declare instances of dependent objects. 
type Optional. Data type of the variable; may be Byte, Boolean, Integer, Long, Currency, Single, Double, Decimal (not currently supported), Date, String, (for variable-length strings), String * length (for fixed-length strings), Object, Variant, a user-defined type, or an object type. Use a separate As type clause for each variable being defined. 


Remarks

Once module code is running, variables declared with the Static statement retain their value until the module is reset or restarted. In class modules, variables declared with the Static statement retain their value in each class instance until that instance is destroyed. In form modules, static variables retain their value until the form is closed. Use the Static statement in nonstatic procedures to explicitly declare variables that are visible only within the procedure, but whose lifetime is the same as the module in which the procedure is defined.

Use a Static statement within a procedure to declare the data type of a variable that retains its value between procedure calls. For example, the following statement declares a fixed-size array of integers:

Static EmployeeNumber(200) As Integer

The following statement declares a variable for a new instance of a worksheet:

Static X As New Worksheet

If the New keyword isn't used when declaring an object variable, the variable that refers to the object must be assigned an existing object using the Set statement before it can be used. Until it is assigned an object, the declared object variable has the special value Nothing, which indicates that it doesn't refer to any particular instance of an object. When you use the New keyword in the declaration, an instance of the object is created on the first reference to the object.

If you don't specify a data type or object type, and there is no Deftype statement in the module, the variable is Variant by default.

Note   The Static statement and the Static keyword are similar, but used for different effects. If you declare a procedure using the Static keyword (as in Static Sub CountSales ()), the storage space for all local variables within the procedure is allocated once, and the value of the variables is preserved for the entire time the program is running. For nonstatic procedures, storage space for variables is allocated each time the procedure is called and released when the procedure is exited. The Static statement is used to declare specific variables within nonstatic procedures to preserve their value for as long as the program is running.

When variables are initialized, a numeric variable is initialized to 0, a variable-length string is initialized to a zero-length string (""), and a fixed-length string is filled with zeros. Variant variables are initialized to Empty. Each element of a user-defined type variable is initialized as if it were a separate variable.

Note   When you use Static statements within a procedure, put them at the beginning of the procedure with other declarative statements such as Dim.
</t>
<t tx="pap.120703001453.1239">Unload Statement
See Also    Example

Unloads a form or control from memory.

Syntax

Unload object

The object placeholder is the name of a Form object or control array element to unload.

Remarks

Unloading a form or control may be necessary or expedient in some cases where the memory used is needed for something else, or when you need to reset properties to their original values.

Before a form is unloaded, the Query_Unload event procedure occurs, followed by the Form_Unload event procedure. Setting the cancel argument to True in either of these events prevents the form from being unloaded. For MDIForm objects, the MDIForm object's Query_Unload event procedure occurs, followed by the Query_Unload event procedure and Form_Unload event procedure for each MDI child form, and finally the MDIForm object's Form_Unload event procedure.

When a form is unloaded, all controls placed on the form at run time are no longer accessible. Controls placed on the form at design time remain intact; however, any run-time changes to those controls and their properties are lost when the form is reloaded. All changes to form properties are also lost. Accessing any controls on the form causes it to be reloaded.

Note   When a form is unloaded, only the displayed component is unloaded. The code associated with the form module remains in memory.

Only control array elements added to a form at run time can be unloaded with the Unload statement. The properties of unloaded controls are reinitialized when the controls are reloaded.
</t>
<t tx="pap.120703001453.1240">Width # Statement
See Also    Example    Specifics

Assigns an output line width to a file opened using the Open statement.

Syntax

Width #filenumber, width

The Width # statement syntax has these parts:

Part Description 
filenumber Required. Any valid file number. 
width Required. Numeric expression in the range 0255, inclusive, that indicates how many characters appear on a line before a new line is started. If width equals 0, there is no limit to the length of a line. The default value for width is 0. 

</t>
<t tx="pap.120703001453.1241">ChDrive Statement
See Also    Example    Specifics

Changes the current drive.

Syntax

ChDrive drive

The required drive argument is a string expression that specifies an existing drive. If you supply a zero-length string (""), the current drive doesn't change. If the drive argument is a multiple-character string, ChDrive uses only the first letter.
</t>
<t tx="pap.120703001453.1242">Tab Function
See Also    Example    Specifics

Used with the Print # statement or the Print method to position output.

Syntax

Tab[(n)]

The optional n argument is the column number moved to before displaying or printing the next expression in a list. If omitted, Tab moves the insertion point to the beginning of the next print zone. This allows Tab to be used instead of a comma in locales where the comma is used as a decimal separator.

Remarks

If the current print position on the current line is greater than n, Tab skips to the nth column on the next output line. If n is less than 1, Tab moves the print position to column 1. If n is greater than the output line width, Tab calculates the next print position using the formula:

n Mod width

For example, if width is 80 and you specify Tab(90), the next print will start at column 10 (the remainder of 90/80). If n is less than the current print position, printing begins on the next line at the calculated print position. If the calculated print position is greater than the current print position, printing begins at the calculated print position on the same line.

The leftmost print position on an output line is always 1. When you use the Print # statement to print to files, the rightmost print position is the current width of the output file, which you can set using the Width # statement.

Note   Make sure your tabular columns are wide enough to accommodate wide letters.

When you use the Tab function with the Print method, the print surface is divided into uniform, fixed-width columns. The width of each column is an average of the width of all characters in the point size for the chosen font. However, there is no correlation between the number of characters printed and the number of fixed-width columns those characters occupy. For example, the uppercase letter W occupies more than one fixed-width column and the lowercase letter i occupies less than one fixed-width column.
</t>
<t tx="pap.120703001453.1243">MsgBox Function
See Also    Example    Specifics

Displays a message in a dialog box, waits for the user to click a button, and returns an Integer indicating which button the user clicked.

Syntax

MsgBox(prompt[, buttons] [, title] [, helpfile, context])

The MsgBox function syntax has these named arguments:

Part Description 
prompt Required. String expression displayed as the message in the dialog box. The maximum length of prompt is approximately 1024 characters, depending on the width of the characters used. If prompt consists of more than one line, you can separate the lines using a carriage return character (Chr(13)), a linefeed character (Chr(10)), or carriage return linefeed character combination (Chr(13) &amp; Chr(10)) between each line. 
buttons Optional. Numeric expression that is the sum of values specifying the number and type of buttons to display, the icon style to use, the identity of the default button, and the modality of the message box. If omitted, the default value for buttons is 0. 
title Optional. String expression displayed in the title bar of the dialog box. If you omit title, the application name is placed in the title bar. 
helpfile Optional. String expression that identifies the Help file to use to provide context-sensitive Help for the dialog box. If helpfile is provided, context must also be provided. 
context Optional. Numeric expression that is the Help context number assigned to the appropriate Help topic by the Help author. If context is provided, helpfile must also be provided. 


Settings

The buttons argument settings are:

Constant Value Description 
vbOKOnly 0 Display OK button only. 
vbOKCancel 1 Display OK and Cancel buttons. 
vbAbortRetryIgnore 2 Display Abort, Retry, and Ignore buttons. 
vbYesNoCancel 3 Display Yes, No, and Cancel buttons. 
vbYesNo 4 Display Yes and No buttons. 
vbRetryCancel 5 Display Retry and Cancel buttons. 
vbCritical 16 Display Critical Message icon.  
vbQuestion 32 Display Warning Query icon. 
vbExclamation 48 Display Warning Message icon. 
vbInformation 64 Display Information Message icon. 
vbDefaultButton1 0 First button is default. 
vbDefaultButton2 256 Second button is default. 
vbDefaultButton3 512 Third button is default. 
vbDefaultButton4 768 Fourth button is default. 
vbApplicationModal 0 Application modal; the user must respond to the message box before continuing work in the current application. 
vbSystemModal 4096 System modal; all applications are suspended until the user responds to the message box. 
vbMsgBoxHelpButton 16384 Adds Help button to the message box 
VbMsgBoxSetForeground 65536 Specifies the message box window as the foreground window 
vbMsgBoxRight 524288 Text is right aligned 
vbMsgBoxRtlReading 1048576 Specifies text should appear as right-to-left reading on Hebrew and Arabic systems 


The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; and the fourth group (0, 4096) determines the modality of the message box. When adding numbers to create a final value for the buttons argument, use only one number from each group.

Note   These constants are specified by Visual Basic for Applications. As a result, the names can be used anywhere in your code in place of the actual values.

Return Values

Constant Value Description 
vbOK 1 OK 
vbCancel 2 Cancel 
vbAbort 3 Abort 
vbRetry 4 Retry 
vbIgnore 5 Ignore 
vbYes 6 Yes 
vbNo 7 No 


Remarks

When both helpfile and context are provided, the user can press F1 to view the Help topic corresponding to the context. Some host applications, for example, Microsoft Excel, also automatically add a Help button to the dialog box.

If the dialog box displays a Cancel button, pressing the ESC key has the same effect as clicking Cancel. If the dialog box contains a Help button, context-sensitive Help is provided for the dialog box. However, no value is returned until one of the other buttons is clicked.

Note   To specify more than the first named argument, you must use MsgBox in an expression. To omit some positional arguments, you must include the corresponding comma delimiter.
</t>
<t tx="pap.120703001453.1244">InputBox Function
See Also    Example    Specifics

Displays a prompt in a dialog box, waits for the user to input text or click a button, and returns a String containing the contents of the text box.

Syntax

InputBox(prompt[, title] [, default] [, xpos] [, ypos] [, helpfile, context])

The InputBox function syntax has these named arguments:

Part Description 
prompt Required. String expression displayed as the message in the dialog box. The maximum length of prompt is approximately 1024 characters, depending on the width of the characters used. If prompt consists of more than one line, you can separate the lines using a carriage return character (Chr(13)), a linefeed character (Chr(10)), or carriage returnlinefeed character combination (Chr(13) &amp; Chr(10)) between each line. 
title Optional. String expression displayed in the title bar of the dialog box. If you omit title, the application name is placed in the title bar. 
default Optional. String expression displayed in the text box as the default response if no other input is provided. If you omit default, the text box is displayed empty. 
xpos Optional. Numeric expression that specifies, in twips, the horizontal distance of the left edge of the dialog box from the left edge of the screen. If xpos is omitted, the dialog box is horizontally centered. 
ypos Optional. Numeric expression that specifies, in twips, the vertical distance of the upper edge of the dialog box from the top of the screen. If ypos is omitted, the dialog box is vertically positioned approximately one-third of the way down the screen. 
helpfile Optional. String expression that identifies the Help file to use to provide context-sensitive Help for the dialog box. If helpfile is provided, context must also be provided. 
context Optional. Numeric expression that is the Help context number assigned to the appropriate Help topic by the Help author. If context is provided, helpfile must also be provided. 


Remarks

When both helpfile and context are provided, the user can press F1 to view the Help topic corresponding to the context. Some host applications, for example, Microsoft Excel, also automatically add a Help button to the dialog box. If the user clicks OK or presses ENTER , the InputBox function returns whatever is in the text box. If the user clicks Cancel, the function returns a zero-length string ("").

Note   To specify more than the first named argument, you must use InputBox in an expression. To omit some positional arguments, you must include the corresponding comma delimiter.
</t>
<t tx="pap.120703001453.1245">CVErr Function
See Also    Example    Specifics

Returns a Variant of subtype Error containing an error number specified by the user.

Syntax

CVErr(errornumber)

The required errornumber argument is any valid error number.

Remarks

Use the CVErr function to create user-defined errors in user-created procedures. For example, if you create a function that accepts several arguments and normally returns a string, you can have your function evaluate the input arguments to ensure they are within acceptable range. If they are not, it is likely your function will not return what you expect. In this event, CVErr allows you to return an error number that tells you what action to take.

Note that implicit conversion of an Error is not allowed. For example, you can't directly assign the return value of CVErr to a variable that is not a Variant. However, you can perform an explicit conversion (using CInt, CDbl, and so on) of the value returned by CVErr and assign that to a variable of the appropriate data type.
</t>
<t tx="pap.120703001453.1246"></t>
<t tx="pap.120703001453.1247"></t>
<t tx="pap.120703001453.1248">@path targets/pythoncard/vbcontrols</t>
<t tx="pap.120703001453.1249"></t>
<t tx="pap.120703001453.1250">@root vbbitmapcanvas.py

from vb2py.targets.pythoncard.controlclasses import VBWrapped, VBWidget
from vb2py.targets.pythoncard import Register
import vb2py.logger
log = vb2py.logger.getLogger("VBBitmapCanvas")

from PythonCard.components import bitmapcanvas
from wxPython import wx
import sys
from PythonCard import event, registry, widget


class VBBitmapCanvas(VBWidget): 
    __metaclass__ = VBWrapped 

    _translations = { 
            "Text" : "text", 
            "Enabled" : "enabled", 
            "Visible" : "visible", 
			"Value" : "checked",
			"Caption" : "label",
        } 

    _indexed_translations = { 
            "Left" : ("position", 0), 
            "Top" : ("position", 1), 
            "Width" : ("size", 0), 
            "Height" : ("size", 1), 
        } 
    
    _proxy_for = bitmapcanvas.BitmapCanvas
  
    _bitmap = None # Our bitmap
	Stretch = 0
	
	&lt;&lt; VBBitmapCanvas Methods &gt;&gt;  

VBBitmapCanvas._setters["Picture"] = VBBitmapCanvas._setPicture	

log.debug("Registering VBBitmapCanvas as '%s'" % sys.modules[__name__].VBBitmapCanvas)
Register(VBBitmapCanvas)

</t>
<t tx="pap.120703001453.1251">&lt;&lt; VBBitmapCanvas Methods &gt;&gt;=

def _setPicture(self, bitmap):
	"""Setting the picture property"""
	if self.Stretch:
		try:
			bitmap.setSize(self.size)
		except NotImplementedError:
			log.error("PythonCard bitmap resize not implemented, Stretch mode will not work")
	else:
		self.size = bitmap.getSize()
	self.drawBitmap(bitmap)
	self.__dict__["_bitmap"] = bitmap
	
def _getPicture(self):
	"""Get the bitmap property"""
	return self._bitmap
	
Picture = property(fget=_getPicture, fset=_setPicture)
</t>
<t tx="pap.120703001453.1252">   { L"ActiveControl"    },
   { L"ActiveForm"     },
   { L"ActiveProject"    },
   { L"AddInMenu"     },
   { L"Align"      },
   { L"Alignment"     },
   { L"AllowAddNew"     },
   { L"AllowDelete"     },
   { L"AllowRowSizing"    },
   { L"AllowSizing"     },
   { L"AllowUpdate"     },
   { L"AllowZeroLength"    },
   { L"AllPermissions"    },
   { L"Appearance"     },
   { L"AppIsRunning"    },
   { L"Application"     },
   { L"Archive"      },
   { L"Attributes"     },
   { L"AutoActivate"    },
   { L"AutoRedraw"     },
   { L"AutoShowChildren"   },
   { L"AutoSize"     },
   { L"AutoVerbMenu"    },
   { L"BackColor"     },
   { L"BackStyle"     },
   { L"BOF"       },
   { L"BOFAction"     },
   { L"Bold"      },
   { L"Bookmark"     },
   { L"Bookmarkable"    },
   { L"BorderColor"     },
   { L"BorderStyle"     },
   { L"BorderWidth"     },
   { L"BoundColumn"     },
   { L"BoundText"     },
   { L"CacheSize"     },
   { L"CacheStart"     },
   { L"Cancel"      },
   { L"CancelError"     },
   { L"Caption"      },
   { L"CellSelected"    },
   { L"Checked"      },
   { L"Class"      },
   { L"ClassName"     },
   { L"Clip"      },
   { L"ClipControls"    },
   { L"Clustered"     },
   { L"Col"       },
   { L"ColAlignment"    },
   { L"ColIndex"     },
   { L"ColIsVisible"    },
   { L"CollatingOrder"    },
   { L"Color"      },
   { L"ColorMode"     },
   { L"ColPos"      },
   { L"Cols"      },
   { L"ColumnCount"     },
   { L"ColumnHeaders"    },
   { L"ColumnName"     },
   { L"Columns"      },
   { L"ColWidth"     },
   { L"Comments"     },
   { L"CompanyName"     },
   { L"ConflictTable"    },
   { L"Connect"      },
   { L"Container"     },
   { L"ControlBox"     },
   { L"ControlTemplates"   },
   { L"Copies"      },
   { L"Count"      },
   { L"CurrentX"     },
   { L"CurrentY"     },
   { L"Data"      },
   { L"Database"     },
   { L"DatabaseName"    },
   { L"DataChanged"     },
   { L"DataField"     },
   { L"DataMode"     },
   { L"DataSource"     },
   { L"DataText"     },
   { L"DataUpdatable"    },
   { L"DateCreated"     },
   { L"Default"      },
   { L"DefaultExt"     },
   { L"DefaultPassword"    },
   { L"DefaultUser"     },
   { L"DefaultValue"    },
   { L"DefColWidth"     },
   { L"Description"     },
   { L"DesignMasterID"    },
   { L"DeviceName"     },
   { L"DialogTitle"     },
   { L"DisplayType"     },
   { L"DistinctCount"    },
   { L"DividerStyle"    },
   { L"DragIcon"     },
   { L"DragMode"     },
   { L"DrawMode"     },
   { L"DrawStyle"     },
   { L"DrawWidth"     },
   { L"Drive"      },
   { L"DriverName"     },
   { L"Duplex"      },
   { L"EditMode"     },
   { L"Enabled"      },
   { L"EOF"       },
   { L"EOFAction"     },
   { L"Exclusive"     },
   { L"EXEName"      },
   { L"Fields"      },
   { L"FileControl"     },
   { L"FileCount"     },
   { L"FileDescription"    },
   { L"FileName"     },
   { L"FileNames"     },
   { L"FileNumber"     },
   { L"FileTitle"     },
   { L"FillColor"     },
   { L"FillStyle"     },
   { L"Filter"      },
   { L"FilterIndex"     },
   { L"firstRow"     },
   { L"FixedAlignment"    },
   { L"FixedCols"     },
   { L"FixedRows"     },
   { L"Flags"      },
   { L"Font"      },
   { L"FontBold"     },
   { L"FontCount"     },
   { L"FontItalic"     },
   { L"FontName"     },
   { L"Fonts"      },
   { L"FontSize"     },
   { L"FontStrikethru"    },
   { L"FontTransparent"    },
   { L"FontUnderline"    },
   { L"ForeColor"     },
   { L"Foreign"      },
   { L"ForeignName"     },
   { L"ForeignTable"    },
   { L"Format"      },
   { L"FromPage"     },
   { L"FullName"     },
   { L"GridLines"     },
   { L"GridLineWidth"    },
   { L"Handle"      },
   { L"hDC"       },
   { L"HeadBackColor"    },
   { L"HeadFont"     },
   { L"HeadForeColor"    },
   { L"HeadLines"     },
   { L"Height"      },
   { L"HelpCommand"     },
   { L"HelpContext"     },
   { L"HelpContextID"    },
   { L"HelpFile"     },
   { L"HelpKey"      },
   { L"Hidden"      },
   { L"HideSelection"    },
   { L"HighLight"     },
   { L"hInstance"     },
   { L"HostName"     },
   { L"hPal"      },
   { L"hWnd"      },
   { L"Icon"      },
   { L"IconState"     },
   { L"IgnoreNulls"     },
   { L"Image"      },
   { L"Index"      },
   { L"IndexedValue"    },
   { L"Inherit"      },
   { L"Inherited"     },
   { L"IniPath"      },
   { L"InitDir"      },
   { L"Instancing"     },
   { L"IntegralHeight"    },
   { L"Interval"     },
   { L"IsDirty"      },
   { L"IsolateODBCTrans"   },
   { L"Italic"      },
   { L"ItemData"     },
   { L"KeepLocal"     },
   { L"KeyPreview"     },
   { L"LargeChange"     },
   { L"LastDLLError"    },
   { L"LastModified"    },
   { L"LastUpdated"     },
   { L"LastUsedPath"    },
   { L"LBound"      },
   { L"Left"      },
   { L"LeftCol"      },
   { L"LegalCopyright"    },
   { L"LegalTrademarks"    },
   { L"LinkItem"     },
   { L"LinkMode"     },
   { L"LinkTimeout"     },
   { L"LinkTopic"     },
   { L"List"      },
   { L"ListCount"     },
   { L"ListField"     },
   { L"ListIndex"     },
   { L"Locked"      },
   { L"LockEdits"     },
   { L"LoginTimeout"    },
   { L"LogMessages"     },
   { L"lpOleObject"     },
   { L"Major"      },
   { L"MatchedWithList"    },
   { L"MatchEntry"     },
   { L"Max"       },
   { L"MaxButton"     },
   { L"MaxFileSize"     },
   { L"MaxLength"     },
   { L"MDIChild"     },
   { L"MenuItems"     },
   { L"Min"       },
   { L"MinButton"     },
   { L"Minor"      },
   { L"MiscFlags"     },
   { L"MouseIcon"     },
   { L"MousePointer"    },
   { L"MultiLine"     },
   { L"MultiSelect"     },
   { L"Name"      },
   { L"Negotiate"     },
   { L"NegotiateMenus"    },
   { L"NegotiatePosition"   },
   { L"NegotiateToolbars"   },
   { L"NewEnum"      },
   { L"NewIndex"     },
   { L"NoMatch"      },
   { L"Normal"      },
   { L"Number"      },
   { L"NumberFormat"    },
   { L"NumIndices"     },
   { L"Object"      },
   { L"ObjectAcceptFormats"         },
   { L"ObjectAcceptFormatsCount"    },
   { L"ObjectGetFormats"            },
   { L"ObjectGetFormatsCount"       },
   { L"ObjectVerbFlags"             },
   { L"ObjectVerbs"                 },
   { L"ObjectVerbsCount"            },
   { L"ODBCTimeout"     },
   { L"OLEDropAllowed"    },
   { L"OLERequestPendingMsgText" },
   { L"OLERequestPendingMsgTitle" },
   { L"OLERequestPendingTimeout" },
   { L"OLEServerBusyMsgText"  },
   { L"OLEServerBusyMsgTitle"  },
   { L"OLEServerBusyRaiseError"  },
   { L"OLEServerBusyTimeout"  },
   { L"OLEType"      },
   { L"OLETypeAllowed"    },
   { L"Options"      },
   { L"OrdinalPosition"    },
   { L"Orientation"     },
   { L"Owner"      },
   { L"Page"      },
   { L"PaperBin"     },
   { L"PaperSize"     },
   { L"Parent"      },
   { L"Password"     },
   { L"PasswordChar"    },
   { L"PasteOK"      },
   { L"Path"      },
   { L"Pattern"      },
   { L"PercentPosition"    },
   { L"Permissions"     },
   { L"Picture"      },
   { L"PID"       },
   { L"Port"      },
   { L"PrevInstance"    },
   { L"Primary"      },
   { L"PrinterDefault"    },
   { L"PrintQuality"    },
   { L"ProductName"     },
   { L"Properties"     },
   { L"Public"      },
   { L"QueryTimeout"    },
   { L"ReadOnly"     },
   { L"ReadOnlyMode"    },
   { L"RecordCount"     },
   { L"RecordsAffected"    },
   { L"RecordSelectors"    },
   { L"Recordset"     },
   { L"RecordsetType"    },
   { L"RecordSource"    },
   { L"Replicable"     },
   { L"ReplicaID"     },
   { L"Required"     },
   { L"Restartable"     },
   { L"ReturnsRecords"    },
   { L"Revision"     },
   { L"Row"       },
   { L"RowCount"     },
   { L"RowDividerStyle"    },
   { L"RowHeight"     },
   { L"RowIsVisible"    },
   { L"RowPos"      },
   { L"Rows"      },
   { L"RowSource"     },
   { L"ScaleHeight"     },
   { L"ScaleLeft"     },
   { L"ScaleMode"     },
   { L"ScaleTop"     },
   { L"ScaleWidth"     },
   { L"ScrollBars"     },
   { L"SelBookmarks"    },
   { L"SelCount"     },
   { L"Selected"     },
   { L"SelectedComponents"   },
   { L"SelectedControlTemplates" },
   { L"SelectedItem"    },
   { L"SelEndCol"     },
   { L"SelEndRow"     },
   { L"SelLength"     },
   { L"SelStart"     },
   { L"SelStartCol"     },
   { L"SelStartRow"     },
   { L"SelText"      },
   { L"Shape"      },
   { L"Shortcut"     },
   { L"ShowInTaskbar"    },
   { L"Size"      },
   { L"SizeMode"     },
   { L"SmallChange"     },
   { L"Sort"      },
   { L"Sorted"      },
   { L"Source"      },
   { L"SourceDoc"     },
   { L"SourceField"     },
   { L"SourceItem"     },
   { L"SourceTable"     },
   { L"SourceTableName"    },
   { L"SQL"       },
   { L"StartMode"     },
   { L"Stretch"      },
   { L"StrikeThrough"    },
   { L"Style"      },
   { L"System"      },
   { L"TabIndex"     },
   { L"Table"      },
   { L"TabStop"      },
   { L"Tag"       },
   { L"TaskVisible"     },
   { L"Text"      },
   { L"Title"      },
   { L"Top"       },
   { L"ToPage"      },
   { L"TopIndex"     },
   { L"TopRow"      },
   { L"TrackDefault"    },
   { L"Transactions"    },
   { L"TwipsPerPixelX"    },
   { L"TwipsPerPixelY"    },
   { L"Type"      },
   { L"UBound"      },
   { L"Underline"     },
   { L"Unique"      },
   { L"Updatable"     },
   { L"UpdateOptions"    },
   { L"UseMnemonic"     },
   { L"UserName"     },
   { L"V1xNullBehavior"    },
   { L"ValidateOnSet"    },
   { L"ValidationRule"    },
   { L"ValidationText"    },
   { L"Value"      },
   { L"Version"      },
   { L"Visible"      },
   { L"VisibleCols"     },
   { L"VisibleCount"    },
   { L"VisibleItems"    },
   { L"VisibleRows"     },
   { L"Weight"      },
   { L"WhatsThisButton"    },
   { L"WhatsThisHelp"    },
   { L"WhatsThisHelpID"    },
   { L"Width"      },
   { L"WindowList"     },
   { L"WindowState"     },
   { L"WordWrap"     },
   { L"X1"       },
   { L"X2"       },
   { L"Y1"       },
   { L"Y2"       },
   { L"Zoom"      },
   { NULL       }
</t>
<t tx="pap.120703001453.1253"></t>
<t tx="pap.120703001453.1254"></t>
<t tx="pap.120703001453.1255"></t>
<t tx="pap.120703001453.1256"></t>
<t tx="pap.120703001453.1257"></t>
<t tx="pap.120703001453.1258"></t>
<t tx="pap.120703001453.1259"></t>
<t tx="pap.120703001453.1260"></t>
<t tx="pap.120703001453.1261"></t>
<t tx="pap.120703001453.1262"></t>
<t tx="pap.120703001453.1263"></t>
<t tx="pap.120703001453.1264"></t>
<t tx="pap.120703001453.1265"></t>
<t tx="pap.120703001453.1266"></t>
<t tx="pap.120703001453.1267"></t>
<t tx="pap.120703001453.1268"></t>
<t tx="pap.120703001453.1269"></t>
<t tx="pap.120703001453.1270"></t>
<t tx="pap.120703001453.1271"></t>
<t tx="pap.120703001453.1272"></t>
<t tx="pap.120703001453.1273"></t>
<t tx="pap.120703001453.1274"></t>
<t tx="pap.120703001453.1275">Done
</t>
<t tx="pap.120703001453.1276">@nocolor

This is a list of the significant changes in v0.3

</t>
<t tx="pap.120703001453.1277">
</t>
<t tx="pap.120703001453.1278">1. 805866 Print with no channel number fails during rendering 
2. 809979 On Error GoTo label: </t>
<t tx="pap.120703001453.1279">1. GUI can now load single files so you don't need a .vbp file</t>
<t tx="pap.120703001453.1280">*** a(1) = 10 - second time view in GUI is incorrect 

</t>
<t tx="pap.120703001453.1281">ComboBox, TextBox, Button working on mapping events

New approach using MetaClass and VBWidget proxy are working well.

Need to do for all objects
Need to make a list of all properties
Need to think about whether the event mapping should be done this way too


Just finished TextArea



Is Nothing from command line and from the GUI?!?

Need a test for

For Node in kakads
    Node.doit
Next</t>
<t tx="pap.120703001453.1282">@nocolor

What happens if someone calls the Control event directly ?
We have only one param!
Attribute translation machinery is still in controls.py


Improve logging
Check lower case and/or in expressions



MsgBox


Adding 'event' to form methods
Changing object attribute names (eg .Text to .text)

Best way is to delegate this to controls on the form themselves. So after we parse the code we call each control in sequence and it gets a chance to change the code.





Linux



Use function attributes for Statics?

def f(x):
	f.static = 10


To handle nothing we may need a Nothing object which compares to None etc. The tough use case is

Dim A as Object
If A Is Nothing ...
</t>
<t tx="pap.120703001453.1283">C:\Development\Python24\Lib\site-packages\vb2py&gt;..\..\..\python test\testall.py

Starting testall at Sat Feb 24 19:03:20 2007

Running 'test\testassignment.py' ...  *** 1 errors out of 99
Running 'test\testattributenames.py' ...  *** 1 errors out of 1
Running 'test\testclassmethods.py' ...  *** 1 errors out of 17
Running 'test\testcodemodules.py' ...  Passed 1 tests
Running 'test\testcollection.py' ...  Passed 9 tests
Running 'test\testconfig.py' ...  Passed 15 tests
Running 'test\testconst.py' ...  Passed 5 tests
Running 'test\testcustomimport.py' ...  Passed 1 tests
Running 'test\testdims.py' ...  Passed 17 tests
Running 'test\testenum.py' ...  Passed 2 tests
Running 'test\testerase.py' ...  Passed 2 tests
Running 'test\testexternal.py' ...  Passed 1 tests
Running 'test\testfailures.py' ...  *** 2 errors out of 2
Running 'test\testfiles.py' ...  Passed 25 tests
Running 'test\testfns.py' ...  Passed 13 tests
Running 'test\testfor.py' ...  Passed 16 tests
Running 'test\testglobals.py' ...  Passed 13 tests
Running 'test\testifs.py' ...  Passed 23 tests
Running 'test\testimports.py' ...  Passed 1 tests
Running 'test\testintrinsic.py' ...  Passed 172 tests
Running 'test\testintrinsic2.py' ...  Passed 40 tests
Running 'test\testintrinsic3.py' ...  Passed 12 tests
Running 'test\testmini.py' ...  *** 0 errors out of 0
Running 'test\testobjectdef.py' ...  Passed 8 tests
Running 'test\testoperators.py' ...  *** 1 errors out of 20
Running 'test\testparser.py' ...  *** 0 errors out of 0
Running 'test\testprivate.py' ...  Passed 9 tests
Running 'test\testproperties.py' ...  Passed 7 tests
Running 'test\testrandom.py' ...  Passed 5 tests
Running 'test\testselect.py' ...  Passed 165 tests
Running 'test\testsettings.py' ...  Passed 6 tests
Running 'test\testsubs.py' ...  Passed 9 tests
Running 'test\testtypes.py' ...  Passed 4 tests
Running 'test\testwhile.py' ...  Passed 14 tests
Running 'test\testwith.py' ...  Passed 5 tests

Ran 739 tests
Failed 6
Took 291 seconds</t>
<t tx="pap.20041206011550">@root test\testimports.py

from unittest import *
import vb2py.vbparser

class TestImports(TestCase):
    &lt;&lt; Imports tests &gt;&gt;

import vb2py.vbparser
vb2py.vbparser.log.setLevel(0) # Don't print all logging stuff

if __name__ == "__main__":
	main()</t>
<t tx="pap.20041206011605">&lt;&lt; Imports tests &gt;&gt;=

def testImportClassToModule(self):
    """Import from class to module"""
    self.proj = vb2py.vbparser.VBProject()
    self.utils = vb2py.vbparser.VBCodeModule(modulename="utils")
    self.cls = vb2py.vbparser.VBClassModule(modulename="Cls", classname="Cls")
    #
    self.utils.assignParent(self.proj)
    self.cls.assignParent(self.proj)
    #
    utils = vb2py.vbparser.parseVB("""
    Public Function Fact(x)
        Dim c As New Cls
    End Function
    """, container=self.utils)
    #
    cls = vb2py.vbparser.parseVB("""
    Public A
    """, container=self.cls)
    #
    utils_code = self.utils.renderAsCode()
    self.assertNotEqual(utils_code.find("import Cls"), -1)


</t>
<t tx="pap.20041206014616">&lt;&lt; VBClassModule methods &gt;&gt;=

def assignParent(self, parent):
    """Set our parent"""
    super(VBClassModule, self).assignParent(parent)
    self.identifier = self.classname 
    self.registerAsGlobal()    
    </t>
<t tx="pap.20041206020842">Time/Date
Scripting import</t>
<t tx="pap.20041206233451">Reverse DNS Lookup
IP Address 195.7.3.182 resolves to:
home-001404.b.astral.ro 

218.17.78.199 - China</t>
<t tx="pap.20041207001955">@c

if project.references:
    if not readtlb:
        self.logText("Unable to import ctypes - external references will not be converted")
    else:
        refs = self.handleReferences(project.references, self.project_structure, project_root)
        self.resources.append(ExternalRefParser(
                os.path.join(project_root, "COM_Externals.py"), refs))
    

</t>
<t tx="pap.20041207002557">&lt;&lt; class VBConverter methods &gt;&gt;=

def handleReferences(self, references, project, root):
    """Handle the external references
    
    The references tell us the DLL names. We can then load these using
    ctypes readtlb. This then tells us the objects which are exposed.
    We can then try to use this to insert global references in the
    project which will be replaced by the appropriate calls whenever
    we need them.
    
    """
    global_names = {}
    &lt;&lt; Add to project &gt;&gt;               
    for reference in references:
        &lt;&lt; Resolve references &gt;&gt;
    
    return externals</t>
<t tx="pap.20041207004101">@c
#
# Get all the external objects that we can reference
try:
    guid, ver, id, path, name = reference.split("#")
except ValueError:
    self.logText("Unable to extract reference from '%s'" % reference)
try:
    tlb = readtlb.TypeLibReader(os.path.join(root, path))
    self.logText("Found '%s' in DLL '%s'" % (tlb.name, path))
    for cls in tlb.coclasses.values():
        self.logText(" - Member class %s" % cls.name)
        global_names.setdefault(tlb.name, []).append(cls.name)
        project.global_objects["%s.%s" % (tlb.name, cls.name)] = externals
except Exception, err:
    self.logText("Failed while reading library '%s': %s" % (path, err))
</t>
<t tx="pap.20041207004101.1">@c
#
# Now stick these in a fake module
externals = vbparser.VBCOMExternalModule(modulename="COM_Externals")
externals.names = global_names
</t>
<t tx="pap.20041207004405">&lt;&lt; Classes &gt;&gt;=

class VBCOMExternalModule(VBModule):
	"""Handles external COM references"""
	
    
    
    &lt;&lt; VBCOMExternalModule methods &gt;&gt;
</t>
<t tx="pap.20041207005308">&lt;&lt; VBConverter &gt;&gt;=

class ExternalRefParser(ModuleParser):
    """Handlers writing out of external references"""
    
    &lt;&lt; class ExternalRefParser methods &gt;&gt;</t>
<t tx="pap.20041207005609">&lt;&lt; class ExternalRefParser methods &gt;&gt;=

def __init__(self, filename, refs):
	"""Initialize the parser"""
	self.filename = filename
	self.name = os.path.splitext(os.path.split(filename)[1])[0]
	self.basedir = os.path.split(filename)[0]
    self.code_structure = refs
</t>
<t tx="pap.20041207011116">&lt;&lt; VBCOMExternalModule methods &gt;&gt;=

def renderDeclarations(self, indent):
    """Render all the declarations
    
    We have a list of libraries and objects in our names attribute
    so we create a series of dummy classes with callable
    attributes which return COM objects.
    
    """
    library_code = []
    for library, members in self.names.iteritems():
        member_code = []
        for member in members:
            member_code.append(
                    '    def %s(self):\n'
                    '        """Create the %s.%s object"""\n'
                    '        return win32com.client.Dispatch("%s.%s")\n'
                    '\n' % (member, library, member, library, member))
        library_code.append('class _%s:\n'
                            '    """COM Library"""\n'
                            '\n%s%s = _%s()\n' % (library, ''.join(member_code), library, library))

    return '\n\n'.join(library_code)</t>
<t tx="pap.20041207012020">&lt;&lt; VBCOMExternalModule methods &gt;&gt;=

def __init__(self, *args, **kw):
    """Initialize the COM module
    
    We always need win32com.client to be imported
    
    """
    super(VBCOMExternalModule, self).__init__(*args, **kw)
    self.module_imports.append("win32com.client")
    self.docstrings.append(
            VBRenderDirect("Automatically generated file based on project references"))</t>
<t tx="pap.20070203003154">@path ../vb2pygui
</t>
<t tx="pap.20070203103920"></t>
<t tx="pap.20070203103920.1"></t>
<t tx="pap.20070203103920.2">{'type':'CustomDialog',
    'name':'Find',
    'title':'Find',
    'position':(467, 157),
    'size':(437, 164),
    'components': [

{'type':'Button', 
    'name':'btnFindNext', 
    'position':(347, 30), 
    'label':'Find Next', 
    },

{'type':'RadioGroup', 
    'name':'optSearchIn', 
    'position':(10, 40), 
    'size':(151, 47), 
    'items':['Python', 'VB'], 
    'label':'Search in', 
    'layout':'horizontal', 
    'max':1, 
    'selected':'Python', 
    },

{'type':'TextField', 
    'name':'txtFind', 
    'position':(67, 7), 
    'size':(272, -1), 
    },

{'type':'StaticText', 
    'name':'StaticText1', 
    'position':(11, 10), 
    'text':'Find what', 
    },

{'type':'Button', 
    'id':5100, 
    'name':'btnFind', 
    'position':(347, 6), 
    'label':'Find', 
    },

{'type':'Button', 
    'id':5101, 
    'name':'btnCancel', 
    'position':(347, 55), 
    'label':'Close', 
    },

] # end components
} # end CustomDialog
</t>
<t tx="pap.20070203103920.3"></t>
<t tx="pap.20070203103920.4"></t>
<t tx="pap.20070203154528">&lt;&lt; VBFunctions &gt;&gt;=


def MakeDate(*args):
	"""Return a date from the given string"""
    raise NotImplementedError("MakeDate has not been written yet")</t>
<t tx="pap.20070203162417"></t>
<t tx="pap.20070203162417.6">@ignore

{'application':{'type':'Application',
          'name':'Template',
    'backgrounds': [
    {'type':'Background',
          'name':'Wizard',
          'title':'vb2Py : Conversion Wizard',
          'position':(340, 102),
          'size':(608, 637),
          'style':['resizeable'],

        'menubar': {'type':'MenuBar',
         'menus': [
             {'type':'Menu',
             'name':'menuFile',
             'label':'&amp;File',
             'items': [
                  {'type':'MenuItem',
                   'name':'menuFileOpen',
                   'label':'&amp;Open\tCtrl+O',
                  },
                  {'type':'MenuItem',
                   'name':'menuFileSave',
                   'label':'&amp;Save\tCtrl+S',
                  },
                  {'type':'MenuItem',
                   'name':'menuFileExit',
                   'label':'E&amp;xit\tCtrl+X',
                  },
              ]
             },
             {'type':'Menu',
             'name':'menuEdit',
             'label':'Edit',
             'items': [
                  {'type':'MenuItem',
                   'name':'menuFind',
                   'label':'Find\tCtrl+F',
                  },
                  {'type':'MenuItem',
                   'name':'menuFindNext',
                   'label':'Find next\tF3',
                  },
              ]
             },
             {'type':'Menu',
             'name':'menuView',
             'label':'View',
             'items': [
                  {'type':'MenuItem',
                   'name':'menuOptions',
                   'label':'Options ...',
                  },
                  {'type':'MenuItem',
                   'name':'menuViewStructure',
                   'label':'View Structure',
                  },
                  {'type':'MenuItem',
                   'name':'menuTestView',
                   'label':'Testing Window',
                  },
              ]
             },
             {'type':'Menu',
             'name':'menuConversion',
             'label':'Convert',
             'items': [
                  {'type':'MenuItem',
                   'name':'menuConvert',
                   'label':'Convert active\tCtrl+A',
                  },
                  {'type':'MenuItem',
                   'name':'menuConvertSelection',
                   'label':'Convert selection\tCtrl+Shift+S',
                  },
                  {'type':'MenuItem',
                   'name':'menuSep1',
                   'label':'-',
                  },
                  {'type':'MenuItem',
                   'name':'menuCodeModuleContext',
                   'label':'Code Module',
                   'checkable':1,
                   'checked':1,
                  },
                  {'type':'MenuItem',
                   'name':'menuClassModuleContext',
                   'label':'Class Module',
                   'checkable':1,
                  },
                  {'type':'MenuItem',
                   'name':'menuFormModuleContext',
                   'label':'Form Module',
                   'checkable':1,
                  },
              ]
             },
             {'type':'Menu',
             'name':'menuHelp',
             'label':'Help',
             'items': [
                  {'type':'MenuItem',
                   'name':'menuHelp',
                   'label':'vb2Py Help\tF1',
                  },
                  {'type':'MenuItem',
                   'name':'menuHelpGUI',
                   'label':'GUI Help',
                  },
                  {'type':'MenuItem',
                   'name':'menuSep2',
                   'label':'-',
                  },
                  {'type':'MenuItem',
                   'name':'menuAbout',
                   'label':'About vb2Py',
                  },
              ]
             },
         ]
     },
         'components': [



] # end components
} # end background
] # end backgrounds
} }
</t>
<t tx="pap.20070203172243.5">@ignore
{'application':{'type':'Application',
          'name':'Template',
    'backgrounds': [
    {'type':'Background',
          'name':'bgTemplate',
          'title':'Standard Template with no menus',
          'size':(929, 741),
          'backgroundColor':(255, 255, 255),

         'components': [

{'type':'StaticText', 
    'name':'PythonBlurb', 
    'position':(648, 12), 
    'text':'Python code appears below', 
    },

{'type':'Button', 
    'name':'Convert', 
    'position':(427, 4), 
    'label':'Convert --&gt;', 
    },

{'type':'StaticText', 
    'name':'VBBlurb', 
    'position':(156, 13), 
    'text':'Enter the VB code below', 
    },

{'type':'CodeEditor', 
    'name':'Python', 
    'position':(461, 47), 
    'size':(454, 619), 
    'backgroundColor':(255, 255, 255, 255), 
    },

{'type':'CodeEditor', 
    'name':'VB', 
    'position':(10, 46), 
    'size':(448, 621), 
    'backgroundColor':(255, 255, 255, 255), 
    },

] # end components
} # end background
] # end backgrounds
} }
</t>
<t tx="pap.20070203192530">
[Style]
# Style of conversion, Pythonic or VB
# VB tries to make sure that the code works identically
# Pythonic tries to make sure the code looks like Python, but it might behave differently
ConversionStyle = VB
</t>
<t tx="pap.20070224180440">&lt;&lt; Parsing tests &gt;&gt;=

# Unicode
tests.extend([
'cI  = 10',
'a = cI + 30',
'a = "cI there"',

])

# Unicode sub
tests.append("""
Sub cI()
a=10
n=20
c="hello"
End Sub
""")

</t>
<t tx="pap.20070224183443">&lt;&lt; class BaseParser methods &gt;&gt;=

def readFileContent(self, filename):
    """Read the contents of the file"""
    text = open(filename.strip(), "r").read() # Use strip to remove \r 
    return text</t>
<t tx="pap.20070224185447">&lt;&lt; Utility functions &gt;&gt;=

def makeSafeFromUnicode(text):
    """Return a safe version of the text without unicode characters
    
    We do some ugly hacks here to handle unicode since the SimpleParse library
    doesn't have an easy way to deal with it.
    
    """
    result = []
    letters = map(ord, text)
    marker1 = [ord('x'), ord('X')]
    marker2 = [ord('X'), ord('x')]    
    #
    # Replace all non asc characters with a marker
    for letter in letters:
        if letter &lt; 128:
            result.append(letter)
        else:
            result.extend(marker1)
            result.extend(map(ord, str(letter)))
            result.extend(marker2)
    #
    return "".join(map(chr, result))</t>
<t tx="pap.20070224185546">&lt;&lt; Utility functions &gt;&gt;=

def makeUnicodeFromSafe(text):
    """Recover the unicode text from a safe version of the text
    
    We do some ugly hacks here to handle unicode since the SimpleParse library
    doesn't have an easy way to deal with it.
    
    """
    def replacer(match):
        """Replace the safe unicode thingumy"""
        text = match.groups()[1]
        code = int(text)
        return chr(code)
    
    proper_text = re.sub('(xX)(\d+)(Xx)', replacer, text)
    
    return proper_text
    </t>
<t tx="pap.20070224191421">@c
# Try to buid the parse - if this fails we probably have an early
# version of Simpleparse
try:
    parser = Parser(declaration, starttoken)
except Exception, err:
    log.warn("Failed to build parse (%s) - trying case sensitive grammar" % err)
    parser = Parser(declaration.replace('c"', ' "'), starttoken)
    log.info("Downgraded to case sensitive grammar")
</t>
<t tx="pap.20070225000746">&lt;&lt; VBFor methods &gt;&gt;=

def handleDottedName(self, indent):
	"""Handle a dotted name as the identifier
    
    The For can reference a dotted name, which presumably changes the
    value of that attribute. We can only do this by a local re-assignment
    
    """
    name = self.object
    if "." not in name:
        # Ok, normal case
        self.loopname = name
        self.copiedname = ""
    else:
        # Ooops, assigning to a dotted name in the loop
        self.loopname = "_idx%s" % VBFor._for_variable_index
        VBFor._for_variable_index += 1
        self.copiedname = "%s%s = %s\n" % (
            self.getIndent(indent+1),
            name,
            self.loopname
        )
    	
</t>
</tnodes>
</leo_file>
